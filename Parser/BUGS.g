grammar BUGS ;

options {language = Cpp;}

tokens {
	MODEL = 'model';
	LOGOPENBRACKET = 'log(';
	LOGITOPENBRACKET = 'logit(';
	CLOGLOGOPENBRACKET = 'cloglog(';
	PROBITOPENBRACKET = 'probit(';
	ABSOPENBRACKET = 'abs(';
	INVERSEOPENBRACKET = 'inverse(';

	BERNOULLIOPENBRACKET = 'dbern(';
	BETAOPENBRACKET = 'dbeta(';
	MUTLTINOMIALOPENBRACKET = 'dmulti(';
	DIRICHLETOPENBRACKET = 'ddirich(';

	FORSTART = 'for';
	IN = 'in';

	OPENBRACE = '{';
	CLOSEBRACE = '}';
	TILDE = '~';
	CENSORBEGINWITHC = 'C(';
	CENSORBEGINWITHI = 'I(';
	TRUNCATIONBEGIN = 'T(';
	OPENBRACKET = '(';
	CLOSEBRACKET = ')';
	COMMA =  ',';
	OPENSQUAREBRACKET = '[';
	CLOSESQUAREBRACKET = ']';
	LEFTPOINTER = '<-';
	PLUS = '+';
	MINUS = '-';
	MULT = '*';
	DIV = '/';
	COLON = ':';	
}

@lexer::namespace {BUGS}
@parser::namespace {BUGS}
@lexer::traits {

     class BUGSLexer; class BUGSParser;

     typedef antlr3::Traits< BUGSLexer, BUGSParser > BUGSLexerTraits;

     typedef BUGSLexerTraits BUGSParserTraits;

}
@lexer::includes{

}
@parser::includes{
#include "BUGSLexer.hpp"
}

@parser::members {
int main(int argc, char* argv[])
{
BUGSLexerTraits::InputStreamType input("Test", ANTLR_ENC_8BIT);
BUGSLexer lxr(&input); // TLexerNew is generated by ANTLR
BUGSParserTraits::TokenStreamType tstream(ANTLR_SIZE_HINT, lxr.get_tokSource() );
BUGSParser psr(&tstream); // TParserNew is generated by ANTLR3

psr.prog();

}
}
/* Parser Rules*/
prog : (MODEL OPENBRACE statements CLOSEBRACE) *;

statements :  ((uvNode TILDE) => stochasticNodeExpr 
	| (mvNode TILDE) => stochasticNodeExpr
	| (uvNode LEFTPOINTER) => logicalNodeExpr 
	| (mvNode LEFTPOINTER) => logicalNodeExpr 
	| (linkFunction LEFTPOINTER) => logicalNodeExpr 
	| (startFor statements endFor) 
	)+
	;

stochasticNodeExpr 
	: (uvNode) => uvStochasticNodeExpr (censor | truncation)?
	| mvStochasticNodeExpr 
	;

uvStochasticNodeExpr
	:uvNode TILDE uvDistribution
	;
mvStochasticNodeExpr 
	:mvNode TILDE mvDistribution
	;
	
censor
	 : (CENSORBEGINWITHC|CENSORBEGINWITHI) ( (uvNode|CONSTANTVALUE) =>lowerWithOptionalUpper  | upperWithOptionalLower )  CLOSEBRACKET
	 ;
truncation 
	: TRUNCATIONBEGIN (  (uvNode|CONSTANTVALUE) => lowerWithOptionalUpper | upperWithOptionalLower )  CLOSEBRACKET
	;
	
lowerWithOptionalUpper 
	:  (uvNode|CONSTANTVALUE) COMMA (uvNode|CONSTANTVALUE)?
	;
	
upperWithOptionalLower 
	:  (uvNode|CONSTANTVALUE)? COMMA (uvNode|CONSTANTVALUE)
	;

logicalNodeExpr 
	: (uvNode | linkFunction) => (uvNode | linkFunction) LEFTPOINTER exprWithNodesFunctions
	|  mvNode LEFTPOINTER exprWithNodesFunctions
	;

linkFunction 
	: LOGOPENBRACKET uvNode CLOSEBRACKET 
	| LOGITOPENBRACKET uvNode CLOSEBRACKET
	| CLOGLOGOPENBRACKET uvNode CLOSEBRACKET
	| PROBITOPENBRACKET uvNode CLOSEBRACKET
	;

exprWithNodesFunctions 
	: (unaryExpression | OPENBRACKET MINUS unaryExpression  CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions ) ((PLUS|MINUS|MULT|DIV) exprWithNodesFunctions)?
	;

uvNode 
	: NODENAME (OPENSQUAREBRACKET expression (COMMA expression)*  CLOSESQUAREBRACKET)?
	;
mvNode 
	: NODENAME OPENSQUAREBRACKET multiIndices CLOSESQUAREBRACKET
	;

expression 
	: unaryExpression ((PLUS|MINUS|MULT|DIV) expression)?
	;

unaryExpression
	: CONSTANTINT  
	| CONSTANTVALUE
	| uvNode 
	| OPENBRACKET expression CLOSEBRACKET
	;

multiIndices 
	: multiDimExpression (COMMA multiDimExpression)*
	;
	
multiDimExpression
	: (OPENBRACKET expression COLON) => OPENBRACKET expression COLON expression CLOSEBRACKET
	| expression (COLON expression)?
	;

startFor 
	: FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE 
	;

endFor 
	: CLOSEBRACE
	;

loopVariable 
	: NODENAME
	;

loopBegin 
	: uvNode 
	| CONSTANTINT
	;

loopEnd 
	: uvNode 
	| CONSTANTINT
	;

CONSTANTINT
	: ('0'..'9')+
	;
	
NODENAME 
	:('a'..'z'| 'A'..'Z') ('a'..'z'| 'A'..'Z'| '0'..'9'| '.')*
	;

CONSTANTVALUE 
	: ('+'|'-')?('0'..'9')+('.'('0'..'9')+)?('E'('+'|'-')?('0'..'9')+)?
	;

WHITESPACE : ( '\t' | ' ' | '\r' | '\n'| ';' | '\u000C' )+    { $channel = HIDDEN; } ;

scalarFunctions 
	: ABSOPENBRACKET exprWithNodesFunctions CLOSEBRACKET
	;

vectorFunctions 
	: INVERSEOPENBRACKET mvNode CLOSEBRACKET
	;
	
uvDistribution 
	: discreteUnivariate 
	| continuousUnivariate
	;

mvDistribution 
	: discreteMultivariate 
	| continuousMultivariate
	;

discreteUnivariate 
	: bernoulli 
	;

continuousUnivariate 
	: beta 
	;

discreteMultivariate 
	: multinomial
	;

continuousMultivariate 
	: dirichlet
	;
	
distributionParameter 
	: uvNode | CONSTANTINT | CONSTANTVALUE
	;
	
bernoulli 
	: BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET
	;

beta 
	: BETAOPENBRACKET distributionParameter COMMA distributionParameter CLOSEBRACKET
	;

multinomial 
	: MUTLTINOMIALOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA 
	distributionParameter CLOSEBRACKET
	;

dirichlet 
	: DIRICHLETOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA
	;
