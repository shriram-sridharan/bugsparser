/** \file
 *  This C++ source file was generated by $ANTLR version 3.5-rc-2
 *
 *     -  From the grammar source file : /home/shriram/bugsparser/Parser/BUGS.g
 *     -                            On : 2013-01-05 17:07:20
 *     -                for the parser : BUGSParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "BUGSParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace BUGS {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   BUGSParserTokenNames[34+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ABSOPENBRACKET",
        (ANTLR_UINT8*) "BERNOULLIOPENBRACKET",
        (ANTLR_UINT8*) "BETAOPENBRACKET",
        (ANTLR_UINT8*) "CENSORBEGINWITHC",
        (ANTLR_UINT8*) "CENSORBEGINWITHI",
        (ANTLR_UINT8*) "CLOGLOGOPENBRACKET",
        (ANTLR_UINT8*) "CLOSEBRACE",
        (ANTLR_UINT8*) "CLOSEBRACKET",
        (ANTLR_UINT8*) "CLOSESQUAREBRACKET",
        (ANTLR_UINT8*) "COLON",
        (ANTLR_UINT8*) "COMMA",
        (ANTLR_UINT8*) "CONSTANTINT",
        (ANTLR_UINT8*) "CONSTANTVALUE",
        (ANTLR_UINT8*) "DIRICHLETOPENBRACKET",
        (ANTLR_UINT8*) "DIV",
        (ANTLR_UINT8*) "FORSTART",
        (ANTLR_UINT8*) "IN",
        (ANTLR_UINT8*) "INVERSEOPENBRACKET",
        (ANTLR_UINT8*) "LEFTPOINTER",
        (ANTLR_UINT8*) "LOGITOPENBRACKET",
        (ANTLR_UINT8*) "LOGOPENBRACKET",
        (ANTLR_UINT8*) "MINUS",
        (ANTLR_UINT8*) "MODEL",
        (ANTLR_UINT8*) "MULT",
        (ANTLR_UINT8*) "MUTLTINOMIALOPENBRACKET",
        (ANTLR_UINT8*) "NODENAME",
        (ANTLR_UINT8*) "OPENBRACE",
        (ANTLR_UINT8*) "OPENBRACKET",
        (ANTLR_UINT8*) "OPENSQUAREBRACKET",
        (ANTLR_UINT8*) "PLUS",
        (ANTLR_UINT8*) "PROBITOPENBRACKET",
        (ANTLR_UINT8*) "TILDE",
        (ANTLR_UINT8*) "TRUNCATIONBEGIN",
        (ANTLR_UINT8*) "WHITESPACE"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/shriram/bugsparser/Parser/BUGS.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* BUGSParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new BUGSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
BUGSParser::BUGSParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new BUGSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
BUGSParser::BUGSParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void BUGSParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( BUGSParserTokenNames );


}

void
BUGSParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
BUGSParser::~BUGSParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return BUGSParserTokenNames;
}


    int main(int argc, char* argv[])
    {
    BUGSTraits::InputStreamType input(fName, ANTLR_ENC_8BIT);
    BUGSLexer lxr(&input); // TLexerNew is generated by ANTLR
    BUGSTraits::TokenStreamType tstream(ANTLR_SIZE_HINT, lxr.get_tokSource() );
    BUGSParser psr(&tstream); // TParserNew is generated by ANTLR3

    psr.prog();

    }


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MODEL_in_prog313_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MODEL_in_prog313( FOLLOW_MODEL_in_prog313_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACE_in_prog315_bits[]	= { ANTLR_UINT64_LIT(0x0000000421880200) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACE_in_prog315( FOLLOW_OPENBRACE_in_prog315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_statements_in_prog317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_statements_in_prog317( FOLLOW_statements_in_prog317_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACE_in_prog319_bits[]	= { ANTLR_UINT64_LIT(0x0000000004000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACE_in_prog319( FOLLOW_CLOSEBRACE_in_prog319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_stochasticNodeExpr_in_statements340_bits[]	= { ANTLR_UINT64_LIT(0x0000000421880202) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_stochasticNodeExpr_in_statements340( FOLLOW_stochasticNodeExpr_in_statements340_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_stochasticNodeExpr_in_statements354_bits[]	= { ANTLR_UINT64_LIT(0x0000000421880202) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_stochasticNodeExpr_in_statements354( FOLLOW_stochasticNodeExpr_in_statements354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_logicalNodeExpr_in_statements367_bits[]	= { ANTLR_UINT64_LIT(0x0000000421880202) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_logicalNodeExpr_in_statements367( FOLLOW_logicalNodeExpr_in_statements367_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_logicalNodeExpr_in_statements381_bits[]	= { ANTLR_UINT64_LIT(0x0000000421880202) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_logicalNodeExpr_in_statements381( FOLLOW_logicalNodeExpr_in_statements381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_logicalNodeExpr_in_statements395_bits[]	= { ANTLR_UINT64_LIT(0x0000000421880202) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_logicalNodeExpr_in_statements395( FOLLOW_logicalNodeExpr_in_statements395_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_startFor_in_statements402_bits[]	= { ANTLR_UINT64_LIT(0x0000000421880200) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_startFor_in_statements402( FOLLOW_startFor_in_statements402_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_statements_in_statements404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_statements_in_statements404( FOLLOW_statements_in_statements404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_endFor_in_statements406_bits[]	= { ANTLR_UINT64_LIT(0x0000000421880202) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_endFor_in_statements406( FOLLOW_endFor_in_statements406_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr430_bits[]	= { ANTLR_UINT64_LIT(0x0000001000000182) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr430( FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr430_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_censor_in_stochasticNodeExpr433_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_censor_in_stochasticNodeExpr433( FOLLOW_censor_in_stochasticNodeExpr433_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_truncation_in_stochasticNodeExpr437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_truncation_in_stochasticNodeExpr437( FOLLOW_truncation_in_stochasticNodeExpr437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr444( FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_uvStochasticNodeExpr455_bits[]	= { ANTLR_UINT64_LIT(0x0000000800000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_uvStochasticNodeExpr455( FOLLOW_uvNode_in_uvStochasticNodeExpr455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TILDE_in_uvStochasticNodeExpr457_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000060) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TILDE_in_uvStochasticNodeExpr457( FOLLOW_TILDE_in_uvStochasticNodeExpr457_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvDistribution_in_uvStochasticNodeExpr459_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvDistribution_in_uvStochasticNodeExpr459( FOLLOW_uvDistribution_in_uvStochasticNodeExpr459_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_mvStochasticNodeExpr469_bits[]	= { ANTLR_UINT64_LIT(0x0000000800000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_mvStochasticNodeExpr469( FOLLOW_mvNode_in_mvStochasticNodeExpr469_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TILDE_in_mvStochasticNodeExpr471_bits[]	= { ANTLR_UINT64_LIT(0x0000000010020000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TILDE_in_mvStochasticNodeExpr471( FOLLOW_TILDE_in_mvStochasticNodeExpr471_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvDistribution_in_mvStochasticNodeExpr473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvDistribution_in_mvStochasticNodeExpr473( FOLLOW_mvDistribution_in_mvStochasticNodeExpr473_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_set_in_censor486_bits[]	= { ANTLR_UINT64_LIT(0x0000000020014000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_set_in_censor486( FOLLOW_set_in_censor486_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_lowerWithOptionalUpper_in_censor501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_lowerWithOptionalUpper_in_censor501( FOLLOW_lowerWithOptionalUpper_in_censor501_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_upperWithOptionalLower_in_censor506_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_upperWithOptionalLower_in_censor506( FOLLOW_upperWithOptionalLower_in_censor506_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_censor511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_censor511( FOLLOW_CLOSEBRACKET_in_censor511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TRUNCATIONBEGIN_in_truncation523_bits[]	= { ANTLR_UINT64_LIT(0x0000000020014000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TRUNCATIONBEGIN_in_truncation523( FOLLOW_TRUNCATIONBEGIN_in_truncation523_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_lowerWithOptionalUpper_in_truncation536_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_lowerWithOptionalUpper_in_truncation536( FOLLOW_lowerWithOptionalUpper_in_truncation536_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_upperWithOptionalLower_in_truncation540_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_upperWithOptionalLower_in_truncation540( FOLLOW_upperWithOptionalLower_in_truncation540_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_truncation545_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_truncation545( FOLLOW_CLOSEBRACKET_in_truncation545_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_lowerWithOptionalUpper560_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_lowerWithOptionalUpper560( FOLLOW_uvNode_in_lowerWithOptionalUpper560_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper562_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper562( FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper562_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_lowerWithOptionalUpper565_bits[]	= { ANTLR_UINT64_LIT(0x0000000020010002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_lowerWithOptionalUpper565( FOLLOW_COMMA_in_lowerWithOptionalUpper565_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_lowerWithOptionalUpper568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_lowerWithOptionalUpper568( FOLLOW_uvNode_in_lowerWithOptionalUpper568_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper570_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper570( FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper570_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_upperWithOptionalLower587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_upperWithOptionalLower587( FOLLOW_uvNode_in_upperWithOptionalLower587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower589_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower589( FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower589_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_upperWithOptionalLower593_bits[]	= { ANTLR_UINT64_LIT(0x0000000020010000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_upperWithOptionalLower593( FOLLOW_COMMA_in_upperWithOptionalLower593_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_upperWithOptionalLower596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_upperWithOptionalLower596( FOLLOW_uvNode_in_upperWithOptionalLower596_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower598_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower598( FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower598_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_logicalNodeExpr622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_logicalNodeExpr622( FOLLOW_uvNode_in_logicalNodeExpr622_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_linkFunction_in_logicalNodeExpr626_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_linkFunction_in_logicalNodeExpr626( FOLLOW_linkFunction_in_logicalNodeExpr626_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_logicalNodeExpr629_bits[]	= { ANTLR_UINT64_LIT(0x00000000A2218010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_logicalNodeExpr629( FOLLOW_LEFTPOINTER_in_logicalNodeExpr629_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr631_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr631( FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr631_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_logicalNodeExpr637_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_logicalNodeExpr637( FOLLOW_mvNode_in_logicalNodeExpr637_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_logicalNodeExpr639_bits[]	= { ANTLR_UINT64_LIT(0x00000000A2218010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_logicalNodeExpr639( FOLLOW_LEFTPOINTER_in_logicalNodeExpr639_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr641_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr641( FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr641_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LOGOPENBRACKET_in_linkFunction653_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LOGOPENBRACKET_in_linkFunction653( FOLLOW_LOGOPENBRACKET_in_linkFunction653_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_linkFunction655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_linkFunction655( FOLLOW_uvNode_in_linkFunction655_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction657_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_linkFunction657( FOLLOW_CLOSEBRACKET_in_linkFunction657_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LOGITOPENBRACKET_in_linkFunction663_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LOGITOPENBRACKET_in_linkFunction663( FOLLOW_LOGITOPENBRACKET_in_linkFunction663_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_linkFunction665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_linkFunction665( FOLLOW_uvNode_in_linkFunction665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction667_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_linkFunction667( FOLLOW_CLOSEBRACKET_in_linkFunction667_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction672_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction672( FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction672_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_linkFunction674_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_linkFunction674( FOLLOW_uvNode_in_linkFunction674_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction676_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_linkFunction676( FOLLOW_CLOSEBRACKET_in_linkFunction676_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_PROBITOPENBRACKET_in_linkFunction681_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_PROBITOPENBRACKET_in_linkFunction681( FOLLOW_PROBITOPENBRACKET_in_linkFunction681_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_linkFunction683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_linkFunction683( FOLLOW_uvNode_in_linkFunction683_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction685_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_linkFunction685( FOLLOW_CLOSEBRACKET_in_linkFunction685_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_unaryExpression_in_exprWithNodesFunctions698_bits[]	= { ANTLR_UINT64_LIT(0x000000020A040002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_unaryExpression_in_exprWithNodesFunctions698( FOLLOW_unaryExpression_in_exprWithNodesFunctions698_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_exprWithNodesFunctions702_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_exprWithNodesFunctions702( FOLLOW_OPENBRACKET_in_exprWithNodesFunctions702_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MINUS_in_exprWithNodesFunctions704_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MINUS_in_exprWithNodesFunctions704( FOLLOW_MINUS_in_exprWithNodesFunctions704_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_unaryExpression_in_exprWithNodesFunctions706_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_unaryExpression_in_exprWithNodesFunctions706( FOLLOW_unaryExpression_in_exprWithNodesFunctions706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions709_bits[]	= { ANTLR_UINT64_LIT(0x000000020A040002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions709( FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions709_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MINUS_in_exprWithNodesFunctions713_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MINUS_in_exprWithNodesFunctions713( FOLLOW_MINUS_in_exprWithNodesFunctions713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_unaryExpression_in_exprWithNodesFunctions715_bits[]	= { ANTLR_UINT64_LIT(0x000000020A040002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_unaryExpression_in_exprWithNodesFunctions715( FOLLOW_unaryExpression_in_exprWithNodesFunctions715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_scalarFunctions_in_exprWithNodesFunctions719_bits[]	= { ANTLR_UINT64_LIT(0x000000020A040002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_scalarFunctions_in_exprWithNodesFunctions719( FOLLOW_scalarFunctions_in_exprWithNodesFunctions719_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_vectorFunctions_in_exprWithNodesFunctions723_bits[]	= { ANTLR_UINT64_LIT(0x000000020A040002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_vectorFunctions_in_exprWithNodesFunctions723( FOLLOW_vectorFunctions_in_exprWithNodesFunctions723_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_set_in_exprWithNodesFunctions728_bits[]	= { ANTLR_UINT64_LIT(0x00000000A2218010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_set_in_exprWithNodesFunctions728( FOLLOW_set_in_exprWithNodesFunctions728_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions738( FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions738_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_uvNode752_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_NODENAME_in_uvNode752( FOLLOW_NODENAME_in_uvNode752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENSQUAREBRACKET_in_uvNode755_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENSQUAREBRACKET_in_uvNode755( FOLLOW_OPENSQUAREBRACKET_in_uvNode755_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_uvNode757_bits[]	= { ANTLR_UINT64_LIT(0x0000000000005000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_uvNode757( FOLLOW_expression_in_uvNode757_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_uvNode760_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_uvNode760( FOLLOW_COMMA_in_uvNode760_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_uvNode762_bits[]	= { ANTLR_UINT64_LIT(0x0000000000005000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_uvNode762( FOLLOW_expression_in_uvNode762_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_uvNode767_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSESQUAREBRACKET_in_uvNode767( FOLLOW_CLOSESQUAREBRACKET_in_uvNode767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_mvNode780_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_NODENAME_in_mvNode780( FOLLOW_NODENAME_in_mvNode780_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENSQUAREBRACKET_in_mvNode782_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENSQUAREBRACKET_in_mvNode782( FOLLOW_OPENSQUAREBRACKET_in_mvNode782_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_multiIndices_in_mvNode784_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_multiIndices_in_mvNode784( FOLLOW_multiIndices_in_mvNode784_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_mvNode786_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSESQUAREBRACKET_in_mvNode786( FOLLOW_CLOSESQUAREBRACKET_in_mvNode786_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_unaryExpression_in_expression798_bits[]	= { ANTLR_UINT64_LIT(0x000000020A040002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_unaryExpression_in_expression798( FOLLOW_unaryExpression_in_expression798_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_set_in_expression801_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_set_in_expression801( FOLLOW_set_in_expression801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression811_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_expression811( FOLLOW_expression_in_expression811_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTINT_in_unaryExpression824_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTINT_in_unaryExpression824( FOLLOW_CONSTANTINT_in_unaryExpression824_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_unaryExpression831_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_unaryExpression831( FOLLOW_CONSTANTVALUE_in_unaryExpression831_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_unaryExpression836_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_unaryExpression836( FOLLOW_uvNode_in_unaryExpression836_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_unaryExpression842_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_unaryExpression842( FOLLOW_OPENBRACKET_in_unaryExpression842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_unaryExpression844_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_unaryExpression844( FOLLOW_expression_in_unaryExpression844_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_unaryExpression846_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_unaryExpression846( FOLLOW_CLOSEBRACKET_in_unaryExpression846_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_multiDimExpression_in_multiIndices858_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_multiDimExpression_in_multiIndices858( FOLLOW_multiDimExpression_in_multiIndices858_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multiIndices861_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_multiIndices861( FOLLOW_COMMA_in_multiIndices861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_multiDimExpression_in_multiIndices863_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_multiDimExpression_in_multiIndices863( FOLLOW_multiDimExpression_in_multiIndices863_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_multiDimExpression887_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_multiDimExpression887( FOLLOW_OPENBRACKET_in_multiDimExpression887_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_multiDimExpression889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_multiDimExpression889( FOLLOW_expression_in_multiDimExpression889_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_multiDimExpression891_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COLON_in_multiDimExpression891( FOLLOW_COLON_in_multiDimExpression891_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_multiDimExpression893_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_multiDimExpression893( FOLLOW_expression_in_multiDimExpression893_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_multiDimExpression895_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_multiDimExpression895( FOLLOW_CLOSEBRACKET_in_multiDimExpression895_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_multiDimExpression900_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_multiDimExpression900( FOLLOW_expression_in_multiDimExpression900_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_multiDimExpression903_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COLON_in_multiDimExpression903( FOLLOW_COLON_in_multiDimExpression903_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_multiDimExpression905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_multiDimExpression905( FOLLOW_expression_in_multiDimExpression905_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_FORSTART_in_startFor919_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_FORSTART_in_startFor919( FOLLOW_FORSTART_in_startFor919_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_startFor921_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_startFor921( FOLLOW_OPENBRACKET_in_startFor921_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_loopVariable_in_startFor923_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_loopVariable_in_startFor923( FOLLOW_loopVariable_in_startFor923_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_IN_in_startFor925_bits[]	= { ANTLR_UINT64_LIT(0x0000000020008000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_IN_in_startFor925( FOLLOW_IN_in_startFor925_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_loopBegin_in_startFor927_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_loopBegin_in_startFor927( FOLLOW_loopBegin_in_startFor927_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_startFor929_bits[]	= { ANTLR_UINT64_LIT(0x0000000020008000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COLON_in_startFor929( FOLLOW_COLON_in_startFor929_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_loopEnd_in_startFor931_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_loopEnd_in_startFor931( FOLLOW_loopEnd_in_startFor931_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_startFor933_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_startFor933( FOLLOW_CLOSEBRACKET_in_startFor933_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACE_in_startFor935_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACE_in_startFor935( FOLLOW_OPENBRACE_in_startFor935_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACE_in_endFor948_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACE_in_endFor948( FOLLOW_CLOSEBRACE_in_endFor948_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_loopVariable960_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_NODENAME_in_loopVariable960( FOLLOW_NODENAME_in_loopVariable960_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_loopBegin972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_loopBegin972( FOLLOW_uvNode_in_loopBegin972_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTINT_in_loopBegin978_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTINT_in_loopBegin978( FOLLOW_CONSTANTINT_in_loopBegin978_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_loopEnd990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_loopEnd990( FOLLOW_uvNode_in_loopEnd990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTINT_in_loopEnd996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTINT_in_loopEnd996( FOLLOW_CONSTANTINT_in_loopEnd996_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_ABSOPENBRACKET_in_scalarFunctions1152_bits[]	= { ANTLR_UINT64_LIT(0x00000000A2218010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_ABSOPENBRACKET_in_scalarFunctions1152( FOLLOW_ABSOPENBRACKET_in_scalarFunctions1152_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_scalarFunctions1154_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_scalarFunctions1154( FOLLOW_exprWithNodesFunctions_in_scalarFunctions1154_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_scalarFunctions1156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_scalarFunctions1156( FOLLOW_CLOSEBRACKET_in_scalarFunctions1156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1168_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1168( FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_vectorFunctions1170_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_vectorFunctions1170( FOLLOW_mvNode_in_vectorFunctions1170_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_vectorFunctions1172_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_vectorFunctions1172( FOLLOW_CLOSEBRACKET_in_vectorFunctions1172_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_discreteUnivariate_in_uvDistribution1185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_discreteUnivariate_in_uvDistribution1185( FOLLOW_discreteUnivariate_in_uvDistribution1185_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_continuousUnivariate_in_uvDistribution1191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_continuousUnivariate_in_uvDistribution1191( FOLLOW_continuousUnivariate_in_uvDistribution1191_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_discreteMultivariate_in_mvDistribution1203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_discreteMultivariate_in_mvDistribution1203( FOLLOW_discreteMultivariate_in_mvDistribution1203_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_continuousMultivariate_in_mvDistribution1209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_continuousMultivariate_in_mvDistribution1209( FOLLOW_continuousMultivariate_in_mvDistribution1209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_bernoulli_in_discreteUnivariate1221_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_bernoulli_in_discreteUnivariate1221( FOLLOW_bernoulli_in_discreteUnivariate1221_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_beta_in_continuousUnivariate1234_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_beta_in_continuousUnivariate1234( FOLLOW_beta_in_continuousUnivariate1234_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_multinomial_in_discreteMultivariate1247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_multinomial_in_discreteMultivariate1247( FOLLOW_multinomial_in_discreteMultivariate1247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_dirichlet_in_continuousMultivariate1259_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_dirichlet_in_continuousMultivariate1259( FOLLOW_dirichlet_in_continuousMultivariate1259_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_distributionParameter1272_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_distributionParameter1272( FOLLOW_uvNode_in_distributionParameter1272_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTINT_in_distributionParameter1276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTINT_in_distributionParameter1276( FOLLOW_CONSTANTINT_in_distributionParameter1276_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_distributionParameter1280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_distributionParameter1280( FOLLOW_CONSTANTVALUE_in_distributionParameter1280_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1293_bits[]	= { ANTLR_UINT64_LIT(0x0000000020018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1293( FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_bernoulli1295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_bernoulli1295( FOLLOW_distributionParameter_in_bernoulli1295_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_bernoulli1297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_bernoulli1297( FOLLOW_CLOSEBRACKET_in_bernoulli1297_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_BETAOPENBRACKET_in_beta1309_bits[]	= { ANTLR_UINT64_LIT(0x0000000020018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_BETAOPENBRACKET_in_beta1309( FOLLOW_BETAOPENBRACKET_in_beta1309_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_beta1311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_beta1311( FOLLOW_distributionParameter_in_beta1311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_beta1313_bits[]	= { ANTLR_UINT64_LIT(0x0000000020018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_beta1313( FOLLOW_COMMA_in_beta1313_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_beta1315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_beta1315( FOLLOW_distributionParameter_in_beta1315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_beta1317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_beta1317( FOLLOW_CLOSEBRACKET_in_beta1317_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1329_bits[]	= { ANTLR_UINT64_LIT(0x0000000020018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1329( FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1329_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_multinomial1331_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_multinomial1331( FOLLOW_distributionParameter_in_multinomial1331_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENSQUAREBRACKET_in_multinomial1333_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENSQUAREBRACKET_in_multinomial1333( FOLLOW_OPENSQUAREBRACKET_in_multinomial1333_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_multinomial1335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSESQUAREBRACKET_in_multinomial1335( FOLLOW_CLOSESQUAREBRACKET_in_multinomial1335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multinomial1337_bits[]	= { ANTLR_UINT64_LIT(0x0000000020018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_multinomial1337( FOLLOW_COMMA_in_multinomial1337_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_multinomial1341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_multinomial1341( FOLLOW_distributionParameter_in_multinomial1341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_multinomial1343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_multinomial1343( FOLLOW_CLOSEBRACKET_in_multinomial1343_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1355_bits[]	= { ANTLR_UINT64_LIT(0x0000000020018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1355( FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1355_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_dirichlet1357_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_dirichlet1357( FOLLOW_distributionParameter_in_dirichlet1357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENSQUAREBRACKET_in_dirichlet1359_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENSQUAREBRACKET_in_dirichlet1359( FOLLOW_OPENSQUAREBRACKET_in_dirichlet1359_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1361( FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_dirichlet1363_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_dirichlet1363( FOLLOW_COMMA_in_dirichlet1363_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred1_BUGS333_bits[]	= { ANTLR_UINT64_LIT(0x0000000800000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred1_BUGS333( FOLLOW_uvNode_in_synpred1_BUGS333_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TILDE_in_synpred1_BUGS335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TILDE_in_synpred1_BUGS335( FOLLOW_TILDE_in_synpred1_BUGS335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_synpred2_BUGS347_bits[]	= { ANTLR_UINT64_LIT(0x0000000800000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_synpred2_BUGS347( FOLLOW_mvNode_in_synpred2_BUGS347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TILDE_in_synpred2_BUGS349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TILDE_in_synpred2_BUGS349( FOLLOW_TILDE_in_synpred2_BUGS349_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred3_BUGS360_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred3_BUGS360( FOLLOW_uvNode_in_synpred3_BUGS360_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_synpred3_BUGS362_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_synpred3_BUGS362( FOLLOW_LEFTPOINTER_in_synpred3_BUGS362_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_synpred4_BUGS374_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_synpred4_BUGS374( FOLLOW_mvNode_in_synpred4_BUGS374_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_synpred4_BUGS376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_synpred4_BUGS376( FOLLOW_LEFTPOINTER_in_synpred4_BUGS376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_linkFunction_in_synpred5_BUGS388_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_linkFunction_in_synpred5_BUGS388( FOLLOW_linkFunction_in_synpred5_BUGS388_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_synpred5_BUGS390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_synpred5_BUGS390( FOLLOW_LEFTPOINTER_in_synpred5_BUGS390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred6_BUGS425_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred6_BUGS425( FOLLOW_uvNode_in_synpred6_BUGS425_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred7_BUGS495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred7_BUGS495( FOLLOW_uvNode_in_synpred7_BUGS495_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_synpred7_BUGS497_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_synpred7_BUGS497( FOLLOW_CONSTANTVALUE_in_synpred7_BUGS497_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred8_BUGS529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred8_BUGS529( FOLLOW_uvNode_in_synpred8_BUGS529_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_synpred8_BUGS531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_synpred8_BUGS531( FOLLOW_CONSTANTVALUE_in_synpred8_BUGS531_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred9_BUGS612_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred9_BUGS612( FOLLOW_uvNode_in_synpred9_BUGS612_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_linkFunction_in_synpred9_BUGS616_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_linkFunction_in_synpred9_BUGS616( FOLLOW_linkFunction_in_synpred9_BUGS616_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_synpred10_BUGS878_bits[]	= { ANTLR_UINT64_LIT(0x00000000A0018000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_synpred10_BUGS878( FOLLOW_OPENBRACKET_in_synpred10_BUGS878_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred10_BUGS880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_synpred10_BUGS880( FOLLOW_expression_in_synpred10_BUGS880_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_synpred10_BUGS882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COLON_in_synpred10_BUGS882( FOLLOW_COLON_in_synpred10_BUGS882_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start prog
 * /home/shriram/bugsparser/Parser/BUGS.g:63:1: prog : ( MODEL OPENBRACE statements CLOSEBRACE )* ;
 */
void
BUGSParser::prog()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:63:6: ( ( MODEL OPENBRACE statements CLOSEBRACE )* )
        // /home/shriram/bugsparser/Parser/BUGS.g:63:8: ( MODEL OPENBRACE statements CLOSEBRACE )*
        {
            // /home/shriram/bugsparser/Parser/BUGS.g:63:8: ( MODEL OPENBRACE statements CLOSEBRACE )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case MODEL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:63:9: MODEL OPENBRACE statements CLOSEBRACE
            	    {
            	         this->matchToken(MODEL, &FOLLOW_MODEL_in_prog313);
            	        if  (this->hasException())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(OPENBRACE, &FOLLOW_OPENBRACE_in_prog315);
            	        if  (this->hasException())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_statements_in_prog317);
            	        statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(CLOSEBRACE, &FOLLOW_CLOSEBRACE_in_prog319);
            	        if  (this->hasException())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prog */

/**
 * $ANTLR start statements
 * /home/shriram/bugsparser/Parser/BUGS.g:65:1: statements : ( ( uvNode TILDE )=> stochasticNodeExpr | ( mvNode TILDE )=> stochasticNodeExpr | ( uvNode LEFTPOINTER )=> logicalNodeExpr | ( mvNode LEFTPOINTER )=> logicalNodeExpr | ( linkFunction LEFTPOINTER )=> logicalNodeExpr | ( startFor statements endFor ) )+ ;
 */
void
BUGSParser::statements()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:65:12: ( ( ( uvNode TILDE )=> stochasticNodeExpr | ( mvNode TILDE )=> stochasticNodeExpr | ( uvNode LEFTPOINTER )=> logicalNodeExpr | ( mvNode LEFTPOINTER )=> logicalNodeExpr | ( linkFunction LEFTPOINTER )=> logicalNodeExpr | ( startFor statements endFor ) )+ )
        // /home/shriram/bugsparser/Parser/BUGS.g:65:15: ( ( uvNode TILDE )=> stochasticNodeExpr | ( mvNode TILDE )=> stochasticNodeExpr | ( uvNode LEFTPOINTER )=> logicalNodeExpr | ( mvNode LEFTPOINTER )=> logicalNodeExpr | ( linkFunction LEFTPOINTER )=> logicalNodeExpr | ( startFor statements endFor ) )+
        {
            // /home/shriram/bugsparser/Parser/BUGS.g:65:15: ( ( uvNode TILDE )=> stochasticNodeExpr | ( mvNode TILDE )=> stochasticNodeExpr | ( uvNode LEFTPOINTER )=> logicalNodeExpr | ( mvNode LEFTPOINTER )=> logicalNodeExpr | ( linkFunction LEFTPOINTER )=> logicalNodeExpr | ( startFor statements endFor ) )+
            {
                int cnt2=0;

                for (;;)
                {
                    int alt2=7;
            	switch ( this->LA(1) )
            	{
            	case NODENAME:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_2 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_BUGS>() )))
            			    {
            			        alt2=1;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred2_BUGS>() )))
            			    {
            			        alt2=2;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case LOGOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_3 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case LOGITOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_4 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case CLOGLOGOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_5 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case PROBITOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_6 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case FORSTART:
            		{
            			alt2=6;
            		}
            	    break;

            	}

            	switch (alt2)
            	{
            	    case 1:
            	        // /home/shriram/bugsparser/Parser/BUGS.g:65:16: ( uvNode TILDE )=> stochasticNodeExpr
            	        {
            	            this->followPush(FOLLOW_stochasticNodeExpr_in_statements340);
            	            stochasticNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 2:
            	        // /home/shriram/bugsparser/Parser/BUGS.g:66:4: ( mvNode TILDE )=> stochasticNodeExpr
            	        {
            	            this->followPush(FOLLOW_stochasticNodeExpr_in_statements354);
            	            stochasticNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 3:
            	        // /home/shriram/bugsparser/Parser/BUGS.g:67:4: ( uvNode LEFTPOINTER )=> logicalNodeExpr
            	        {
            	            this->followPush(FOLLOW_logicalNodeExpr_in_statements367);
            	            logicalNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 4:
            	        // /home/shriram/bugsparser/Parser/BUGS.g:68:4: ( mvNode LEFTPOINTER )=> logicalNodeExpr
            	        {
            	            this->followPush(FOLLOW_logicalNodeExpr_in_statements381);
            	            logicalNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 5:
            	        // /home/shriram/bugsparser/Parser/BUGS.g:69:4: ( linkFunction LEFTPOINTER )=> logicalNodeExpr
            	        {
            	            this->followPush(FOLLOW_logicalNodeExpr_in_statements395);
            	            logicalNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 6:
            	        // /home/shriram/bugsparser/Parser/BUGS.g:70:4: ( startFor statements endFor )
            	        {
            	            // /home/shriram/bugsparser/Parser/BUGS.g:70:4: ( startFor statements endFor )
            	            // /home/shriram/bugsparser/Parser/BUGS.g:70:5: startFor statements endFor
            	            {
            	                this->followPush(FOLLOW_startFor_in_statements402);
            	                startFor();

            	                this->followPop();
            	                if  (this->hasException())
            	                {
            	                    goto rulestatementsEx;
            	                }
            	                if (this->hasFailed())
            	                {
            	                    return ;
            	                }


            	                this->followPush(FOLLOW_statements_in_statements404);
            	                statements();

            	                this->followPop();
            	                if  (this->hasException())
            	                {
            	                    goto rulestatementsEx;
            	                }
            	                if (this->hasFailed())
            	                {
            	                    return ;
            	                }


            	                this->followPush(FOLLOW_endFor_in_statements406);
            	                endFor();

            	                this->followPop();
            	                if  (this->hasException())
            	                {
            	                    goto rulestatementsEx;
            	                }
            	                if (this->hasFailed())
            	                {
            	                    return ;
            	                }


            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt2 >= 1 )
            		{
            		    goto loop2;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< BUGSParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulestatementsEx;
            	}
            	cnt2++;
                }
                loop2: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatementsEx; /* Prevent compiler warnings */
    rulestatementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statements */

/**
 * $ANTLR start stochasticNodeExpr
 * /home/shriram/bugsparser/Parser/BUGS.g:74:1: stochasticNodeExpr : ( ( uvNode )=> uvStochasticNodeExpr ( censor | truncation )? | mvStochasticNodeExpr );
 */
void
BUGSParser::stochasticNodeExpr()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:75:2: ( ( uvNode )=> uvStochasticNodeExpr ( censor | truncation )? | mvStochasticNodeExpr )

            ANTLR_UINT32 alt4;

            alt4=2;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		{
            		    int LA4_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred6_BUGS>() )))
            		    {
            		        alt4=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt4=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 4 );
            		        ex->set_state( 1 );


            		        goto rulestochasticNodeExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 4 );
                ex->set_state( 0 );


                goto rulestochasticNodeExprEx;

            }

            switch (alt4)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:75:4: ( uvNode )=> uvStochasticNodeExpr ( censor | truncation )?
        	    {
        	        this->followPush(FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr430);
        	        uvStochasticNodeExpr();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestochasticNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // /home/shriram/bugsparser/Parser/BUGS.g:75:37: ( censor | truncation )?
        	        {
        	            int alt3=3;
        	            switch ( this->LA(1) )
        	            {
        	                case CENSORBEGINWITHC:
        	                case CENSORBEGINWITHI:
        	                	{
        	                		alt3=1;
        	                	}
        	                    break;
        	                case TRUNCATIONBEGIN:
        	                	{
        	                		alt3=2;
        	                	}
        	                    break;
        	            }

        	            switch (alt3)
        	            {
        	        	case 1:
        	        	    // /home/shriram/bugsparser/Parser/BUGS.g:75:38: censor
        	        	    {
        	        	        this->followPush(FOLLOW_censor_in_stochasticNodeExpr433);
        	        	        censor();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestochasticNodeExprEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/shriram/bugsparser/Parser/BUGS.g:75:47: truncation
        	        	    {
        	        	        this->followPush(FOLLOW_truncation_in_stochasticNodeExpr437);
        	        	        truncation();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestochasticNodeExprEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:76:4: mvStochasticNodeExpr
        	    {
        	        this->followPush(FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr444);
        	        mvStochasticNodeExpr();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestochasticNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestochasticNodeExprEx; /* Prevent compiler warnings */
    rulestochasticNodeExprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stochasticNodeExpr */

/**
 * $ANTLR start uvStochasticNodeExpr
 * /home/shriram/bugsparser/Parser/BUGS.g:79:1: uvStochasticNodeExpr : uvNode TILDE uvDistribution ;
 */
void
BUGSParser::uvStochasticNodeExpr()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:80:2: ( uvNode TILDE uvDistribution )
        // /home/shriram/bugsparser/Parser/BUGS.g:80:3: uvNode TILDE uvDistribution
        {
            this->followPush(FOLLOW_uvNode_in_uvStochasticNodeExpr455);
            uvNode();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(TILDE, &FOLLOW_TILDE_in_uvStochasticNodeExpr457);
            if  (this->hasException())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_uvDistribution_in_uvStochasticNodeExpr459);
            uvDistribution();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuvStochasticNodeExprEx; /* Prevent compiler warnings */
    ruleuvStochasticNodeExprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end uvStochasticNodeExpr */

/**
 * $ANTLR start mvStochasticNodeExpr
 * /home/shriram/bugsparser/Parser/BUGS.g:82:1: mvStochasticNodeExpr : mvNode TILDE mvDistribution ;
 */
void
BUGSParser::mvStochasticNodeExpr()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:83:2: ( mvNode TILDE mvDistribution )
        // /home/shriram/bugsparser/Parser/BUGS.g:83:3: mvNode TILDE mvDistribution
        {
            this->followPush(FOLLOW_mvNode_in_mvStochasticNodeExpr469);
            mvNode();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(TILDE, &FOLLOW_TILDE_in_mvStochasticNodeExpr471);
            if  (this->hasException())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_mvDistribution_in_mvStochasticNodeExpr473);
            mvDistribution();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemvStochasticNodeExprEx; /* Prevent compiler warnings */
    rulemvStochasticNodeExprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mvStochasticNodeExpr */

/**
 * $ANTLR start censor
 * /home/shriram/bugsparser/Parser/BUGS.g:86:1: censor : ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET ;
 */
void
BUGSParser::censor()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:87:3: ( ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET )
        // /home/shriram/bugsparser/Parser/BUGS.g:87:5: ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET
        {
            if ( ((this->LA(1) >= CENSORBEGINWITHC) && (this->LA(1) <= CENSORBEGINWITHI)) )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< BUGSParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulecensorEx;
            }


            // /home/shriram/bugsparser/Parser/BUGS.g:87:41: ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower )
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                case NODENAME:
                	{
                		{
                		    int LA5_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred7_BUGS>() )))
                		    {
                		        alt5=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt5=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 5 );
                		        ex->set_state( 1 );


                		        goto rulecensorEx;

                		    }
                		}
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		{
                		    int LA5_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred7_BUGS>() )))
                		    {
                		        alt5=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt5=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 5 );
                		        ex->set_state( 2 );


                		        goto rulecensorEx;

                		    }
                		}
                	}
                    break;
                case COMMA:
                	{
                		alt5=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 5 );
                    ex->set_state( 0 );


                    goto rulecensorEx;

                }

                switch (alt5)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:87:43: ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper
            	    {
            	        this->followPush(FOLLOW_lowerWithOptionalUpper_in_censor501);
            	        lowerWithOptionalUpper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecensorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:87:94: upperWithOptionalLower
            	    {
            	        this->followPush(FOLLOW_upperWithOptionalLower_in_censor506);
            	        upperWithOptionalLower();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecensorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_censor511);
            if  (this->hasException())
            {
                goto rulecensorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecensorEx; /* Prevent compiler warnings */
    rulecensorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end censor */

/**
 * $ANTLR start truncation
 * /home/shriram/bugsparser/Parser/BUGS.g:89:1: truncation : TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET ;
 */
void
BUGSParser::truncation()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:90:2: ( TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET )
        // /home/shriram/bugsparser/Parser/BUGS.g:90:4: TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET
        {
             this->matchToken(TRUNCATIONBEGIN, &FOLLOW_TRUNCATIONBEGIN_in_truncation523);
            if  (this->hasException())
            {
                goto ruletruncationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // /home/shriram/bugsparser/Parser/BUGS.g:90:20: ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower )
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case NODENAME:
                	{
                		{
                		    int LA6_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred8_BUGS>() )))
                		    {
                		        alt6=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt6=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 6 );
                		        ex->set_state( 1 );


                		        goto ruletruncationEx;

                		    }
                		}
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		{
                		    int LA6_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred8_BUGS>() )))
                		    {
                		        alt6=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt6=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 6 );
                		        ex->set_state( 2 );


                		        goto ruletruncationEx;

                		    }
                		}
                	}
                    break;
                case COMMA:
                	{
                		alt6=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 6 );
                    ex->set_state( 0 );


                    goto ruletruncationEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:90:23: ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper
            	    {
            	        this->followPush(FOLLOW_lowerWithOptionalUpper_in_truncation536);
            	        lowerWithOptionalUpper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletruncationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:90:74: upperWithOptionalLower
            	    {
            	        this->followPush(FOLLOW_upperWithOptionalLower_in_truncation540);
            	        upperWithOptionalLower();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletruncationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_truncation545);
            if  (this->hasException())
            {
                goto ruletruncationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletruncationEx; /* Prevent compiler warnings */
    ruletruncationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end truncation */

/**
 * $ANTLR start lowerWithOptionalUpper
 * /home/shriram/bugsparser/Parser/BUGS.g:93:1: lowerWithOptionalUpper : ( uvNode | CONSTANTVALUE ) COMMA ( uvNode | CONSTANTVALUE )? ;
 */
void
BUGSParser::lowerWithOptionalUpper()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:94:2: ( ( uvNode | CONSTANTVALUE ) COMMA ( uvNode | CONSTANTVALUE )? )
        // /home/shriram/bugsparser/Parser/BUGS.g:94:5: ( uvNode | CONSTANTVALUE ) COMMA ( uvNode | CONSTANTVALUE )?
        {
            // /home/shriram/bugsparser/Parser/BUGS.g:94:5: ( uvNode | CONSTANTVALUE )
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case NODENAME:
                	{
                		alt7=1;
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		alt7=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 7 );
                    ex->set_state( 0 );


                    goto rulelowerWithOptionalUpperEx;

                }

                switch (alt7)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:94:6: uvNode
            	    {
            	        this->followPush(FOLLOW_uvNode_in_lowerWithOptionalUpper560);
            	        uvNode();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:94:13: CONSTANTVALUE
            	    {
            	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper562);
            	        if  (this->hasException())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(COMMA, &FOLLOW_COMMA_in_lowerWithOptionalUpper565);
            if  (this->hasException())
            {
                goto rulelowerWithOptionalUpperEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // /home/shriram/bugsparser/Parser/BUGS.g:94:34: ( uvNode | CONSTANTVALUE )?
            {
                int alt8=3;
                switch ( this->LA(1) )
                {
                    case NODENAME:
                    	{
                    		alt8=1;
                    	}
                        break;
                    case CONSTANTVALUE:
                    	{
                    		alt8=2;
                    	}
                        break;
                }

                switch (alt8)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:94:35: uvNode
            	    {
            	        this->followPush(FOLLOW_uvNode_in_lowerWithOptionalUpper568);
            	        uvNode();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:94:42: CONSTANTVALUE
            	    {
            	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper570);
            	        if  (this->hasException())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulelowerWithOptionalUpperEx; /* Prevent compiler warnings */
    rulelowerWithOptionalUpperEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lowerWithOptionalUpper */

/**
 * $ANTLR start upperWithOptionalLower
 * /home/shriram/bugsparser/Parser/BUGS.g:97:1: upperWithOptionalLower : ( uvNode | CONSTANTVALUE )? COMMA ( uvNode | CONSTANTVALUE ) ;
 */
void
BUGSParser::upperWithOptionalLower()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:98:2: ( ( uvNode | CONSTANTVALUE )? COMMA ( uvNode | CONSTANTVALUE ) )
        // /home/shriram/bugsparser/Parser/BUGS.g:98:5: ( uvNode | CONSTANTVALUE )? COMMA ( uvNode | CONSTANTVALUE )
        {
            // /home/shriram/bugsparser/Parser/BUGS.g:98:5: ( uvNode | CONSTANTVALUE )?
            {
                int alt9=3;
                switch ( this->LA(1) )
                {
                    case NODENAME:
                    	{
                    		alt9=1;
                    	}
                        break;
                    case CONSTANTVALUE:
                    	{
                    		alt9=2;
                    	}
                        break;
                }

                switch (alt9)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:98:6: uvNode
            	    {
            	        this->followPush(FOLLOW_uvNode_in_upperWithOptionalLower587);
            	        uvNode();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:98:13: CONSTANTVALUE
            	    {
            	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower589);
            	        if  (this->hasException())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(COMMA, &FOLLOW_COMMA_in_upperWithOptionalLower593);
            if  (this->hasException())
            {
                goto ruleupperWithOptionalLowerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // /home/shriram/bugsparser/Parser/BUGS.g:98:35: ( uvNode | CONSTANTVALUE )
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                case NODENAME:
                	{
                		alt10=1;
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		alt10=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 10 );
                    ex->set_state( 0 );


                    goto ruleupperWithOptionalLowerEx;

                }

                switch (alt10)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:98:36: uvNode
            	    {
            	        this->followPush(FOLLOW_uvNode_in_upperWithOptionalLower596);
            	        uvNode();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:98:43: CONSTANTVALUE
            	    {
            	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower598);
            	        if  (this->hasException())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupperWithOptionalLowerEx; /* Prevent compiler warnings */
    ruleupperWithOptionalLowerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end upperWithOptionalLower */

/**
 * $ANTLR start logicalNodeExpr
 * /home/shriram/bugsparser/Parser/BUGS.g:101:1: logicalNodeExpr : ( ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER exprWithNodesFunctions | mvNode LEFTPOINTER exprWithNodesFunctions );
 */
void
BUGSParser::logicalNodeExpr()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:102:2: ( ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER exprWithNodesFunctions | mvNode LEFTPOINTER exprWithNodesFunctions )

            ANTLR_UINT32 alt12;

            alt12=2;

            {
                int LA12_0 = this->LA(1);
                if ( (LA12_0 == NODENAME))
                {
                    {
                        int LA12_1 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )))
                        {
                            alt12=1;
                        }
                        else if ( (true))
                        {
                            alt12=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 12 );
                            ex->set_state( 1 );


                            goto rulelogicalNodeExprEx;

                        }
                    }
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )) && (LA12_0 == LOGOPENBRACKET))
                {
                    alt12=1;
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )) && (LA12_0 == LOGITOPENBRACKET))
                {
                    alt12=1;
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )) && (LA12_0 == CLOGLOGOPENBRACKET))
                {
                    alt12=1;
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )) && (LA12_0 == PROBITOPENBRACKET))
                {
                    alt12=1;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 12 );
                    ex->set_state( 0 );


                    goto rulelogicalNodeExprEx;

                }
            }
            switch (alt12)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:102:4: ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER exprWithNodesFunctions
        	    {
        	        // /home/shriram/bugsparser/Parser/BUGS.g:102:31: ( uvNode | linkFunction )
        	        {
        	            int alt11=2;
        	            switch ( this->LA(1) )
        	            {
        	            case NODENAME:
        	            	{
        	            		alt11=1;
        	            	}
        	                break;
        	            case CLOGLOGOPENBRACKET:
        	            case LOGITOPENBRACKET:
        	            case LOGOPENBRACKET:
        	            case PROBITOPENBRACKET:
        	            	{
        	            		alt11=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 11 );
        	                ex->set_state( 0 );


        	                goto rulelogicalNodeExprEx;

        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // /home/shriram/bugsparser/Parser/BUGS.g:102:32: uvNode
        	        	    {
        	        	        this->followPush(FOLLOW_uvNode_in_logicalNodeExpr622);
        	        	        uvNode();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelogicalNodeExprEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/shriram/bugsparser/Parser/BUGS.g:102:41: linkFunction
        	        	    {
        	        	        this->followPush(FOLLOW_linkFunction_in_logicalNodeExpr626);
        	        	        linkFunction();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelogicalNodeExprEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_logicalNodeExpr629);
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr631);
        	        exprWithNodesFunctions();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:103:5: mvNode LEFTPOINTER exprWithNodesFunctions
        	    {
        	        this->followPush(FOLLOW_mvNode_in_logicalNodeExpr637);
        	        mvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_logicalNodeExpr639);
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr641);
        	        exprWithNodesFunctions();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelogicalNodeExprEx; /* Prevent compiler warnings */
    rulelogicalNodeExprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end logicalNodeExpr */

/**
 * $ANTLR start linkFunction
 * /home/shriram/bugsparser/Parser/BUGS.g:106:1: linkFunction : ( LOGOPENBRACKET uvNode CLOSEBRACKET | LOGITOPENBRACKET uvNode CLOSEBRACKET | CLOGLOGOPENBRACKET uvNode CLOSEBRACKET | PROBITOPENBRACKET uvNode CLOSEBRACKET );
 */
void
BUGSParser::linkFunction()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:107:2: ( LOGOPENBRACKET uvNode CLOSEBRACKET | LOGITOPENBRACKET uvNode CLOSEBRACKET | CLOGLOGOPENBRACKET uvNode CLOSEBRACKET | PROBITOPENBRACKET uvNode CLOSEBRACKET )

            ANTLR_UINT32 alt13;

            alt13=4;

            switch ( this->LA(1) )
            {
            case LOGOPENBRACKET:
            	{
            		alt13=1;
            	}
                break;
            case LOGITOPENBRACKET:
            	{
            		alt13=2;
            	}
                break;
            case CLOGLOGOPENBRACKET:
            	{
            		alt13=3;
            	}
                break;
            case PROBITOPENBRACKET:
            	{
            		alt13=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 13 );
                ex->set_state( 0 );


                goto rulelinkFunctionEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:107:4: LOGOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         this->matchToken(LOGOPENBRACKET, &FOLLOW_LOGOPENBRACKET_in_linkFunction653);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_uvNode_in_linkFunction655);
        	        uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction657);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:108:4: LOGITOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         this->matchToken(LOGITOPENBRACKET, &FOLLOW_LOGITOPENBRACKET_in_linkFunction663);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_uvNode_in_linkFunction665);
        	        uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction667);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:109:4: CLOGLOGOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         this->matchToken(CLOGLOGOPENBRACKET, &FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction672);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_uvNode_in_linkFunction674);
        	        uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction676);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:110:4: PROBITOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         this->matchToken(PROBITOPENBRACKET, &FOLLOW_PROBITOPENBRACKET_in_linkFunction681);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_uvNode_in_linkFunction683);
        	        uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction685);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelinkFunctionEx; /* Prevent compiler warnings */
    rulelinkFunctionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end linkFunction */

/**
 * $ANTLR start exprWithNodesFunctions
 * /home/shriram/bugsparser/Parser/BUGS.g:113:1: exprWithNodesFunctions : ( unaryExpression | OPENBRACKET MINUS unaryExpression CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions ) ( ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions )? ;
 */
void
BUGSParser::exprWithNodesFunctions()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:114:2: ( ( unaryExpression | OPENBRACKET MINUS unaryExpression CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions ) ( ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions )? )
        // /home/shriram/bugsparser/Parser/BUGS.g:114:4: ( unaryExpression | OPENBRACKET MINUS unaryExpression CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions ) ( ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions )?
        {
            // /home/shriram/bugsparser/Parser/BUGS.g:114:4: ( unaryExpression | OPENBRACKET MINUS unaryExpression CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions )
            {
                int alt14=5;
                switch ( this->LA(1) )
                {
                case CONSTANTINT:
                case CONSTANTVALUE:
                case NODENAME:
                	{
                		alt14=1;
                	}
                    break;
                case OPENBRACKET:
                	{
                		switch ( this->LA(2) )
                		{
                		case MINUS:
                			{
                				alt14=2;
                			}
                		    break;
                		case CONSTANTINT:
                		case CONSTANTVALUE:
                		case NODENAME:
                		case OPENBRACKET:
                			{
                				alt14=1;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 14 );
                		    ex->set_state( 2 );


                		    goto ruleexprWithNodesFunctionsEx;

                		}

                	}
                    break;
                case MINUS:
                	{
                		alt14=3;
                	}
                    break;
                case ABSOPENBRACKET:
                	{
                		alt14=4;
                	}
                    break;
                case INVERSEOPENBRACKET:
                	{
                		alt14=5;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 14 );
                    ex->set_state( 0 );


                    goto ruleexprWithNodesFunctionsEx;

                }

                switch (alt14)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:114:5: unaryExpression
            	    {
            	        this->followPush(FOLLOW_unaryExpression_in_exprWithNodesFunctions698);
            	        unaryExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:114:23: OPENBRACKET MINUS unaryExpression CLOSEBRACKET
            	    {
            	         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_exprWithNodesFunctions702);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(MINUS, &FOLLOW_MINUS_in_exprWithNodesFunctions704);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_unaryExpression_in_exprWithNodesFunctions706);
            	        unaryExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions709);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:114:73: MINUS unaryExpression
            	    {
            	         this->matchToken(MINUS, &FOLLOW_MINUS_in_exprWithNodesFunctions713);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_unaryExpression_in_exprWithNodesFunctions715);
            	        unaryExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:114:97: scalarFunctions
            	    {
            	        this->followPush(FOLLOW_scalarFunctions_in_exprWithNodesFunctions719);
            	        scalarFunctions();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 5:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:114:115: vectorFunctions
            	    {
            	        this->followPush(FOLLOW_vectorFunctions_in_exprWithNodesFunctions723);
            	        vectorFunctions();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // /home/shriram/bugsparser/Parser/BUGS.g:114:133: ( ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions )?
            {
                int alt15=2;
                switch ( this->LA(1) )
                {
                    case DIV:
                    case MINUS:
                    case MULT:
                    case PLUS:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:114:134: ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions
            	    {
            	        if ( this->LA(1) == DIV || this->LA(1) == MINUS || this->LA(1) == MULT || this->LA(1) == PLUS )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	             this->set_failedflag(false); 

            	        }
            	        else
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            new ANTLR_Exception< BUGSParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto ruleexprWithNodesFunctionsEx;
            	        }


            	        this->followPush(FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions738);
            	        exprWithNodesFunctions();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexprWithNodesFunctionsEx; /* Prevent compiler warnings */
    ruleexprWithNodesFunctionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exprWithNodesFunctions */

/**
 * $ANTLR start uvNode
 * /home/shriram/bugsparser/Parser/BUGS.g:117:1: uvNode : NODENAME ( OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET )? ;
 */
void
BUGSParser::uvNode()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:118:2: ( NODENAME ( OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET )? )
        // /home/shriram/bugsparser/Parser/BUGS.g:118:4: NODENAME ( OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET )?
        {
             this->matchToken(NODENAME, &FOLLOW_NODENAME_in_uvNode752);
            if  (this->hasException())
            {
                goto ruleuvNodeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // /home/shriram/bugsparser/Parser/BUGS.g:118:13: ( OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET )?
            {
                int alt17=2;
                switch ( this->LA(1) )
                {
                    case OPENSQUAREBRACKET:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case CONSTANTINT:
                    		    case CONSTANTVALUE:
                    		    case NODENAME:
                    		    case OPENBRACKET:
                    		    	{
                    		    		alt17=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:118:14: OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET
            	    {
            	         this->matchToken(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_uvNode755);
            	        if  (this->hasException())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_uvNode757);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // /home/shriram/bugsparser/Parser/BUGS.g:118:43: ( COMMA expression )*

            	        for (;;)
            	        {
            	            int alt16=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt16=1;
            	            	}
            	                break;

            	            }

            	            switch (alt16)
            	            {
            	        	case 1:
            	        	    // /home/shriram/bugsparser/Parser/BUGS.g:118:44: COMMA expression
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_uvNode760);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleuvNodeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_uvNode762);
            	        	        expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleuvNodeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop16;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop16: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_uvNode767);
            	        if  (this->hasException())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuvNodeEx; /* Prevent compiler warnings */
    ruleuvNodeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end uvNode */

/**
 * $ANTLR start mvNode
 * /home/shriram/bugsparser/Parser/BUGS.g:120:1: mvNode : NODENAME OPENSQUAREBRACKET multiIndices CLOSESQUAREBRACKET ;
 */
void
BUGSParser::mvNode()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:121:2: ( NODENAME OPENSQUAREBRACKET multiIndices CLOSESQUAREBRACKET )
        // /home/shriram/bugsparser/Parser/BUGS.g:121:4: NODENAME OPENSQUAREBRACKET multiIndices CLOSESQUAREBRACKET
        {
             this->matchToken(NODENAME, &FOLLOW_NODENAME_in_mvNode780);
            if  (this->hasException())
            {
                goto rulemvNodeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_mvNode782);
            if  (this->hasException())
            {
                goto rulemvNodeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_multiIndices_in_mvNode784);
            multiIndices();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemvNodeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_mvNode786);
            if  (this->hasException())
            {
                goto rulemvNodeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemvNodeEx; /* Prevent compiler warnings */
    rulemvNodeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mvNode */

/**
 * $ANTLR start expression
 * /home/shriram/bugsparser/Parser/BUGS.g:124:1: expression : unaryExpression ( ( PLUS | MINUS | MULT | DIV ) expression )? ;
 */
void
BUGSParser::expression()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:125:2: ( unaryExpression ( ( PLUS | MINUS | MULT | DIV ) expression )? )
        // /home/shriram/bugsparser/Parser/BUGS.g:125:4: unaryExpression ( ( PLUS | MINUS | MULT | DIV ) expression )?
        {
            this->followPush(FOLLOW_unaryExpression_in_expression798);
            unaryExpression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // /home/shriram/bugsparser/Parser/BUGS.g:125:20: ( ( PLUS | MINUS | MULT | DIV ) expression )?
            {
                int alt18=2;
                switch ( this->LA(1) )
                {
                    case DIV:
                    case MINUS:
                    case MULT:
                    case PLUS:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:125:21: ( PLUS | MINUS | MULT | DIV ) expression
            	    {
            	        if ( this->LA(1) == DIV || this->LA(1) == MINUS || this->LA(1) == MULT || this->LA(1) == PLUS )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	             this->set_failedflag(false); 

            	        }
            	        else
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            new ANTLR_Exception< BUGSParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto ruleexpressionEx;
            	        }


            	        this->followPush(FOLLOW_expression_in_expression811);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression */

/**
 * $ANTLR start unaryExpression
 * /home/shriram/bugsparser/Parser/BUGS.g:128:1: unaryExpression : ( CONSTANTINT | CONSTANTVALUE | uvNode | OPENBRACKET expression CLOSEBRACKET );
 */
void
BUGSParser::unaryExpression()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:129:2: ( CONSTANTINT | CONSTANTVALUE | uvNode | OPENBRACKET expression CLOSEBRACKET )

            ANTLR_UINT32 alt19;

            alt19=4;

            switch ( this->LA(1) )
            {
            case CONSTANTINT:
            	{
            		alt19=1;
            	}
                break;
            case CONSTANTVALUE:
            	{
            		alt19=2;
            	}
                break;
            case NODENAME:
            	{
            		alt19=3;
            	}
                break;
            case OPENBRACKET:
            	{
            		alt19=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 19 );
                ex->set_state( 0 );


                goto ruleunaryExpressionEx;

            }

            switch (alt19)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:129:4: CONSTANTINT
        	    {
        	         this->matchToken(CONSTANTINT, &FOLLOW_CONSTANTINT_in_unaryExpression824);
        	        if  (this->hasException())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:130:4: CONSTANTVALUE
        	    {
        	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_unaryExpression831);
        	        if  (this->hasException())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:131:4: uvNode
        	    {
        	        this->followPush(FOLLOW_uvNode_in_unaryExpression836);
        	        uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:132:4: OPENBRACKET expression CLOSEBRACKET
        	    {
        	         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_unaryExpression842);
        	        if  (this->hasException())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_unaryExpression844);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_unaryExpression846);
        	        if  (this->hasException())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleunaryExpressionEx; /* Prevent compiler warnings */
    ruleunaryExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unaryExpression */

/**
 * $ANTLR start multiIndices
 * /home/shriram/bugsparser/Parser/BUGS.g:135:1: multiIndices : multiDimExpression ( COMMA multiDimExpression )* ;
 */
void
BUGSParser::multiIndices()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:136:2: ( multiDimExpression ( COMMA multiDimExpression )* )
        // /home/shriram/bugsparser/Parser/BUGS.g:136:4: multiDimExpression ( COMMA multiDimExpression )*
        {
            this->followPush(FOLLOW_multiDimExpression_in_multiIndices858);
            multiDimExpression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiIndicesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // /home/shriram/bugsparser/Parser/BUGS.g:136:23: ( COMMA multiDimExpression )*

            for (;;)
            {
                int alt20=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt20=1;
                	}
                    break;

                }

                switch (alt20)
                {
            	case 1:
            	    // /home/shriram/bugsparser/Parser/BUGS.g:136:24: COMMA multiDimExpression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_multiIndices861);
            	        if  (this->hasException())
            	        {
            	            goto rulemultiIndicesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_multiDimExpression_in_multiIndices863);
            	        multiDimExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiIndicesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiIndicesEx; /* Prevent compiler warnings */
    rulemultiIndicesEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiIndices */

/**
 * $ANTLR start multiDimExpression
 * /home/shriram/bugsparser/Parser/BUGS.g:139:1: multiDimExpression : ( ( OPENBRACKET expression COLON )=> OPENBRACKET expression COLON expression CLOSEBRACKET | expression ( COLON expression )? );
 */
void
BUGSParser::multiDimExpression()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:140:2: ( ( OPENBRACKET expression COLON )=> OPENBRACKET expression COLON expression CLOSEBRACKET | expression ( COLON expression )? )

            ANTLR_UINT32 alt22;

            alt22=2;

            switch ( this->LA(1) )
            {
            case OPENBRACKET:
            	{
            		{
            		    int LA22_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred10_BUGS>() )))
            		    {
            		        alt22=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt22=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 22 );
            		        ex->set_state( 1 );


            		        goto rulemultiDimExpressionEx;

            		    }
            		}
            	}
                break;
            case CONSTANTINT:
            case CONSTANTVALUE:
            case NODENAME:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 22 );
                ex->set_state( 0 );


                goto rulemultiDimExpressionEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:140:4: ( OPENBRACKET expression COLON )=> OPENBRACKET expression COLON expression CLOSEBRACKET
        	    {
        	         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_multiDimExpression887);
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_multiDimExpression889);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(COLON, &FOLLOW_COLON_in_multiDimExpression891);
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_multiDimExpression893);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_multiDimExpression895);
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:141:4: expression ( COLON expression )?
        	    {
        	        this->followPush(FOLLOW_expression_in_multiDimExpression900);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // /home/shriram/bugsparser/Parser/BUGS.g:141:15: ( COLON expression )?
        	        {
        	            int alt21=2;
        	            switch ( this->LA(1) )
        	            {
        	                case COLON:
        	                	{
        	                		alt21=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt21)
        	            {
        	        	case 1:
        	        	    // /home/shriram/bugsparser/Parser/BUGS.g:141:16: COLON expression
        	        	    {
        	        	         this->matchToken(COLON, &FOLLOW_COLON_in_multiDimExpression903);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemultiDimExpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_in_multiDimExpression905);
        	        	        expression();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemultiDimExpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulemultiDimExpressionEx; /* Prevent compiler warnings */
    rulemultiDimExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiDimExpression */

/**
 * $ANTLR start startFor
 * /home/shriram/bugsparser/Parser/BUGS.g:144:1: startFor : FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE ;
 */
void
BUGSParser::startFor()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:145:2: ( FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE )
        // /home/shriram/bugsparser/Parser/BUGS.g:145:4: FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE
        {
             this->matchToken(FORSTART, &FOLLOW_FORSTART_in_startFor919);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_startFor921);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_loopVariable_in_startFor923);
            loopVariable();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(IN, &FOLLOW_IN_in_startFor925);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_loopBegin_in_startFor927);
            loopBegin();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(COLON, &FOLLOW_COLON_in_startFor929);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_loopEnd_in_startFor931);
            loopEnd();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_startFor933);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(OPENBRACE, &FOLLOW_OPENBRACE_in_startFor935);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestartForEx; /* Prevent compiler warnings */
    rulestartForEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end startFor */

/**
 * $ANTLR start endFor
 * /home/shriram/bugsparser/Parser/BUGS.g:148:1: endFor : CLOSEBRACE ;
 */
void
BUGSParser::endFor()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:149:2: ( CLOSEBRACE )
        // /home/shriram/bugsparser/Parser/BUGS.g:149:4: CLOSEBRACE
        {
             this->matchToken(CLOSEBRACE, &FOLLOW_CLOSEBRACE_in_endFor948);
            if  (this->hasException())
            {
                goto ruleendForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleendForEx; /* Prevent compiler warnings */
    ruleendForEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end endFor */

/**
 * $ANTLR start loopVariable
 * /home/shriram/bugsparser/Parser/BUGS.g:152:1: loopVariable : NODENAME ;
 */
void
BUGSParser::loopVariable()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:153:2: ( NODENAME )
        // /home/shriram/bugsparser/Parser/BUGS.g:153:4: NODENAME
        {
             this->matchToken(NODENAME, &FOLLOW_NODENAME_in_loopVariable960);
            if  (this->hasException())
            {
                goto ruleloopVariableEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleloopVariableEx; /* Prevent compiler warnings */
    ruleloopVariableEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end loopVariable */

/**
 * $ANTLR start loopBegin
 * /home/shriram/bugsparser/Parser/BUGS.g:156:1: loopBegin : ( uvNode | CONSTANTINT );
 */
void
BUGSParser::loopBegin()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:157:2: ( uvNode | CONSTANTINT )

            ANTLR_UINT32 alt23;

            alt23=2;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		alt23=1;
            	}
                break;
            case CONSTANTINT:
            	{
            		alt23=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 23 );
                ex->set_state( 0 );


                goto ruleloopBeginEx;

            }

            switch (alt23)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:157:4: uvNode
        	    {
        	        this->followPush(FOLLOW_uvNode_in_loopBegin972);
        	        uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleloopBeginEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:158:4: CONSTANTINT
        	    {
        	         this->matchToken(CONSTANTINT, &FOLLOW_CONSTANTINT_in_loopBegin978);
        	        if  (this->hasException())
        	        {
        	            goto ruleloopBeginEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleloopBeginEx; /* Prevent compiler warnings */
    ruleloopBeginEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end loopBegin */

/**
 * $ANTLR start loopEnd
 * /home/shriram/bugsparser/Parser/BUGS.g:161:1: loopEnd : ( uvNode | CONSTANTINT );
 */
void
BUGSParser::loopEnd()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:162:2: ( uvNode | CONSTANTINT )

            ANTLR_UINT32 alt24;

            alt24=2;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		alt24=1;
            	}
                break;
            case CONSTANTINT:
            	{
            		alt24=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 24 );
                ex->set_state( 0 );


                goto ruleloopEndEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:162:4: uvNode
        	    {
        	        this->followPush(FOLLOW_uvNode_in_loopEnd990);
        	        uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleloopEndEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:163:4: CONSTANTINT
        	    {
        	         this->matchToken(CONSTANTINT, &FOLLOW_CONSTANTINT_in_loopEnd996);
        	        if  (this->hasException())
        	        {
        	            goto ruleloopEndEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleloopEndEx; /* Prevent compiler warnings */
    ruleloopEndEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end loopEnd */

/**
 * $ANTLR start scalarFunctions
 * /home/shriram/bugsparser/Parser/BUGS.g:180:1: scalarFunctions : ABSOPENBRACKET exprWithNodesFunctions CLOSEBRACKET ;
 */
void
BUGSParser::scalarFunctions()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:181:2: ( ABSOPENBRACKET exprWithNodesFunctions CLOSEBRACKET )
        // /home/shriram/bugsparser/Parser/BUGS.g:181:4: ABSOPENBRACKET exprWithNodesFunctions CLOSEBRACKET
        {
             this->matchToken(ABSOPENBRACKET, &FOLLOW_ABSOPENBRACKET_in_scalarFunctions1152);
            if  (this->hasException())
            {
                goto rulescalarFunctionsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_exprWithNodesFunctions_in_scalarFunctions1154);
            exprWithNodesFunctions();

            this->followPop();
            if  (this->hasException())
            {
                goto rulescalarFunctionsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_scalarFunctions1156);
            if  (this->hasException())
            {
                goto rulescalarFunctionsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulescalarFunctionsEx; /* Prevent compiler warnings */
    rulescalarFunctionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end scalarFunctions */

/**
 * $ANTLR start vectorFunctions
 * /home/shriram/bugsparser/Parser/BUGS.g:184:1: vectorFunctions : INVERSEOPENBRACKET mvNode CLOSEBRACKET ;
 */
void
BUGSParser::vectorFunctions()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:185:2: ( INVERSEOPENBRACKET mvNode CLOSEBRACKET )
        // /home/shriram/bugsparser/Parser/BUGS.g:185:4: INVERSEOPENBRACKET mvNode CLOSEBRACKET
        {
             this->matchToken(INVERSEOPENBRACKET, &FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1168);
            if  (this->hasException())
            {
                goto rulevectorFunctionsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_mvNode_in_vectorFunctions1170);
            mvNode();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevectorFunctionsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_vectorFunctions1172);
            if  (this->hasException())
            {
                goto rulevectorFunctionsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevectorFunctionsEx; /* Prevent compiler warnings */
    rulevectorFunctionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end vectorFunctions */

/**
 * $ANTLR start uvDistribution
 * /home/shriram/bugsparser/Parser/BUGS.g:188:1: uvDistribution : ( discreteUnivariate | continuousUnivariate );
 */
void
BUGSParser::uvDistribution()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:189:2: ( discreteUnivariate | continuousUnivariate )

            ANTLR_UINT32 alt25;

            alt25=2;

            switch ( this->LA(1) )
            {
            case BERNOULLIOPENBRACKET:
            	{
            		alt25=1;
            	}
                break;
            case BETAOPENBRACKET:
            	{
            		alt25=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 25 );
                ex->set_state( 0 );


                goto ruleuvDistributionEx;

            }

            switch (alt25)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:189:4: discreteUnivariate
        	    {
        	        this->followPush(FOLLOW_discreteUnivariate_in_uvDistribution1185);
        	        discreteUnivariate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleuvDistributionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:190:4: continuousUnivariate
        	    {
        	        this->followPush(FOLLOW_continuousUnivariate_in_uvDistribution1191);
        	        continuousUnivariate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleuvDistributionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleuvDistributionEx; /* Prevent compiler warnings */
    ruleuvDistributionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end uvDistribution */

/**
 * $ANTLR start mvDistribution
 * /home/shriram/bugsparser/Parser/BUGS.g:193:1: mvDistribution : ( discreteMultivariate | continuousMultivariate );
 */
void
BUGSParser::mvDistribution()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:194:2: ( discreteMultivariate | continuousMultivariate )

            ANTLR_UINT32 alt26;

            alt26=2;

            switch ( this->LA(1) )
            {
            case MUTLTINOMIALOPENBRACKET:
            	{
            		alt26=1;
            	}
                break;
            case DIRICHLETOPENBRACKET:
            	{
            		alt26=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 26 );
                ex->set_state( 0 );


                goto rulemvDistributionEx;

            }

            switch (alt26)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:194:4: discreteMultivariate
        	    {
        	        this->followPush(FOLLOW_discreteMultivariate_in_mvDistribution1203);
        	        discreteMultivariate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemvDistributionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:195:4: continuousMultivariate
        	    {
        	        this->followPush(FOLLOW_continuousMultivariate_in_mvDistribution1209);
        	        continuousMultivariate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemvDistributionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulemvDistributionEx; /* Prevent compiler warnings */
    rulemvDistributionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mvDistribution */

/**
 * $ANTLR start discreteUnivariate
 * /home/shriram/bugsparser/Parser/BUGS.g:198:1: discreteUnivariate : bernoulli ;
 */
void
BUGSParser::discreteUnivariate()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:199:2: ( bernoulli )
        // /home/shriram/bugsparser/Parser/BUGS.g:199:4: bernoulli
        {
            this->followPush(FOLLOW_bernoulli_in_discreteUnivariate1221);
            bernoulli();

            this->followPop();
            if  (this->hasException())
            {
                goto rulediscreteUnivariateEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulediscreteUnivariateEx; /* Prevent compiler warnings */
    rulediscreteUnivariateEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end discreteUnivariate */

/**
 * $ANTLR start continuousUnivariate
 * /home/shriram/bugsparser/Parser/BUGS.g:202:1: continuousUnivariate : beta ;
 */
void
BUGSParser::continuousUnivariate()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:203:2: ( beta )
        // /home/shriram/bugsparser/Parser/BUGS.g:203:4: beta
        {
            this->followPush(FOLLOW_beta_in_continuousUnivariate1234);
            beta();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecontinuousUnivariateEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontinuousUnivariateEx; /* Prevent compiler warnings */
    rulecontinuousUnivariateEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end continuousUnivariate */

/**
 * $ANTLR start discreteMultivariate
 * /home/shriram/bugsparser/Parser/BUGS.g:206:1: discreteMultivariate : multinomial ;
 */
void
BUGSParser::discreteMultivariate()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:207:2: ( multinomial )
        // /home/shriram/bugsparser/Parser/BUGS.g:207:4: multinomial
        {
            this->followPush(FOLLOW_multinomial_in_discreteMultivariate1247);
            multinomial();

            this->followPop();
            if  (this->hasException())
            {
                goto rulediscreteMultivariateEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulediscreteMultivariateEx; /* Prevent compiler warnings */
    rulediscreteMultivariateEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end discreteMultivariate */

/**
 * $ANTLR start continuousMultivariate
 * /home/shriram/bugsparser/Parser/BUGS.g:210:1: continuousMultivariate : dirichlet ;
 */
void
BUGSParser::continuousMultivariate()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:211:2: ( dirichlet )
        // /home/shriram/bugsparser/Parser/BUGS.g:211:4: dirichlet
        {
            this->followPush(FOLLOW_dirichlet_in_continuousMultivariate1259);
            dirichlet();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecontinuousMultivariateEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontinuousMultivariateEx; /* Prevent compiler warnings */
    rulecontinuousMultivariateEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end continuousMultivariate */

/**
 * $ANTLR start distributionParameter
 * /home/shriram/bugsparser/Parser/BUGS.g:214:1: distributionParameter : ( uvNode | CONSTANTINT | CONSTANTVALUE );
 */
void
BUGSParser::distributionParameter()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  /home/shriram/bugsparser/Parser/BUGS.g:215:2: ( uvNode | CONSTANTINT | CONSTANTVALUE )

            ANTLR_UINT32 alt27;

            alt27=3;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		alt27=1;
            	}
                break;
            case CONSTANTINT:
            	{
            		alt27=2;
            	}
                break;
            case CONSTANTVALUE:
            	{
            		alt27=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 27 );
                ex->set_state( 0 );


                goto ruledistributionParameterEx;

            }

            switch (alt27)
            {
        	case 1:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:215:4: uvNode
        	    {
        	        this->followPush(FOLLOW_uvNode_in_distributionParameter1272);
        	        uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledistributionParameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:215:13: CONSTANTINT
        	    {
        	         this->matchToken(CONSTANTINT, &FOLLOW_CONSTANTINT_in_distributionParameter1276);
        	        if  (this->hasException())
        	        {
        	            goto ruledistributionParameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/shriram/bugsparser/Parser/BUGS.g:215:27: CONSTANTVALUE
        	    {
        	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_distributionParameter1280);
        	        if  (this->hasException())
        	        {
        	            goto ruledistributionParameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledistributionParameterEx; /* Prevent compiler warnings */
    ruledistributionParameterEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end distributionParameter */

/**
 * $ANTLR start bernoulli
 * /home/shriram/bugsparser/Parser/BUGS.g:218:1: bernoulli : BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET ;
 */
void
BUGSParser::bernoulli()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:219:2: ( BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET )
        // /home/shriram/bugsparser/Parser/BUGS.g:219:4: BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET
        {
             this->matchToken(BERNOULLIOPENBRACKET, &FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1293);
            if  (this->hasException())
            {
                goto rulebernoulliEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_distributionParameter_in_bernoulli1295);
            distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebernoulliEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_bernoulli1297);
            if  (this->hasException())
            {
                goto rulebernoulliEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebernoulliEx; /* Prevent compiler warnings */
    rulebernoulliEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bernoulli */

/**
 * $ANTLR start beta
 * /home/shriram/bugsparser/Parser/BUGS.g:222:1: beta : BETAOPENBRACKET distributionParameter COMMA distributionParameter CLOSEBRACKET ;
 */
void
BUGSParser::beta()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:223:2: ( BETAOPENBRACKET distributionParameter COMMA distributionParameter CLOSEBRACKET )
        // /home/shriram/bugsparser/Parser/BUGS.g:223:4: BETAOPENBRACKET distributionParameter COMMA distributionParameter CLOSEBRACKET
        {
             this->matchToken(BETAOPENBRACKET, &FOLLOW_BETAOPENBRACKET_in_beta1309);
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_distributionParameter_in_beta1311);
            distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(COMMA, &FOLLOW_COMMA_in_beta1313);
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_distributionParameter_in_beta1315);
            distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_beta1317);
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebetaEx; /* Prevent compiler warnings */
    rulebetaEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end beta */

/**
 * $ANTLR start multinomial
 * /home/shriram/bugsparser/Parser/BUGS.g:226:1: multinomial : MUTLTINOMIALOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA distributionParameter CLOSEBRACKET ;
 */
void
BUGSParser::multinomial()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:227:2: ( MUTLTINOMIALOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA distributionParameter CLOSEBRACKET )
        // /home/shriram/bugsparser/Parser/BUGS.g:227:4: MUTLTINOMIALOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA distributionParameter CLOSEBRACKET
        {
             this->matchToken(MUTLTINOMIALOPENBRACKET, &FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1329);
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_distributionParameter_in_multinomial1331);
            distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_multinomial1333);
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_multinomial1335);
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(COMMA, &FOLLOW_COMMA_in_multinomial1337);
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_distributionParameter_in_multinomial1341);
            distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_multinomial1343);
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultinomialEx; /* Prevent compiler warnings */
    rulemultinomialEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multinomial */

/**
 * $ANTLR start dirichlet
 * /home/shriram/bugsparser/Parser/BUGS.g:231:1: dirichlet : DIRICHLETOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA ;
 */
void
BUGSParser::dirichlet()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /home/shriram/bugsparser/Parser/BUGS.g:232:2: ( DIRICHLETOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA )
        // /home/shriram/bugsparser/Parser/BUGS.g:232:4: DIRICHLETOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA
        {
             this->matchToken(DIRICHLETOPENBRACKET, &FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1355);
            if  (this->hasException())
            {
                goto ruledirichletEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_distributionParameter_in_dirichlet1357);
            distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledirichletEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_dirichlet1359);
            if  (this->hasException())
            {
                goto ruledirichletEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1361);
            if  (this->hasException())
            {
                goto ruledirichletEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(COMMA, &FOLLOW_COMMA_in_dirichlet1363);
            if  (this->hasException())
            {
                goto ruledirichletEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledirichletEx; /* Prevent compiler warnings */
    ruledirichletEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dirichlet */

// $ANTLR start synpred1_BUGS
void BUGSParser::msynpred1_BUGS_fragment(  )
{
    // /home/shriram/bugsparser/Parser/BUGS.g:65:16: ( uvNode TILDE )
    // /home/shriram/bugsparser/Parser/BUGS.g:65:17: uvNode TILDE
    {
        this->followPush(FOLLOW_uvNode_in_synpred1_BUGS333);
        uvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(TILDE, &FOLLOW_TILDE_in_synpred1_BUGS335);
        if  (this->hasException())
        {
            goto rulesynpred1_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_BUGSEx; /* Prevent compiler warnings */
rulesynpred1_BUGSEx: ;

}
// $ANTLR end synpred1_BUGS

// $ANTLR start synpred2_BUGS
void BUGSParser::msynpred2_BUGS_fragment(  )
{
    // /home/shriram/bugsparser/Parser/BUGS.g:66:4: ( mvNode TILDE )
    // /home/shriram/bugsparser/Parser/BUGS.g:66:5: mvNode TILDE
    {
        this->followPush(FOLLOW_mvNode_in_synpred2_BUGS347);
        mvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(TILDE, &FOLLOW_TILDE_in_synpred2_BUGS349);
        if  (this->hasException())
        {
            goto rulesynpred2_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_BUGSEx; /* Prevent compiler warnings */
rulesynpred2_BUGSEx: ;

}
// $ANTLR end synpred2_BUGS

// $ANTLR start synpred3_BUGS
void BUGSParser::msynpred3_BUGS_fragment(  )
{
    // /home/shriram/bugsparser/Parser/BUGS.g:67:4: ( uvNode LEFTPOINTER )
    // /home/shriram/bugsparser/Parser/BUGS.g:67:5: uvNode LEFTPOINTER
    {
        this->followPush(FOLLOW_uvNode_in_synpred3_BUGS360);
        uvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred3_BUGS362);
        if  (this->hasException())
        {
            goto rulesynpred3_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred3_BUGSEx; /* Prevent compiler warnings */
rulesynpred3_BUGSEx: ;

}
// $ANTLR end synpred3_BUGS

// $ANTLR start synpred4_BUGS
void BUGSParser::msynpred4_BUGS_fragment(  )
{
    // /home/shriram/bugsparser/Parser/BUGS.g:68:4: ( mvNode LEFTPOINTER )
    // /home/shriram/bugsparser/Parser/BUGS.g:68:5: mvNode LEFTPOINTER
    {
        this->followPush(FOLLOW_mvNode_in_synpred4_BUGS374);
        mvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred4_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred4_BUGS376);
        if  (this->hasException())
        {
            goto rulesynpred4_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred4_BUGSEx; /* Prevent compiler warnings */
rulesynpred4_BUGSEx: ;

}
// $ANTLR end synpred4_BUGS

// $ANTLR start synpred5_BUGS
void BUGSParser::msynpred5_BUGS_fragment(  )
{
    // /home/shriram/bugsparser/Parser/BUGS.g:69:4: ( linkFunction LEFTPOINTER )
    // /home/shriram/bugsparser/Parser/BUGS.g:69:5: linkFunction LEFTPOINTER
    {
        this->followPush(FOLLOW_linkFunction_in_synpred5_BUGS388);
        linkFunction();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred5_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred5_BUGS390);
        if  (this->hasException())
        {
            goto rulesynpred5_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred5_BUGSEx; /* Prevent compiler warnings */
rulesynpred5_BUGSEx: ;

}
// $ANTLR end synpred5_BUGS

// $ANTLR start synpred6_BUGS
void BUGSParser::msynpred6_BUGS_fragment(  )
{
    // /home/shriram/bugsparser/Parser/BUGS.g:75:4: ( uvNode )
    // /home/shriram/bugsparser/Parser/BUGS.g:75:5: uvNode
    {
        this->followPush(FOLLOW_uvNode_in_synpred6_BUGS425);
        uvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred6_BUGSEx; /* Prevent compiler warnings */
rulesynpred6_BUGSEx: ;

}
// $ANTLR end synpred6_BUGS

// $ANTLR start synpred7_BUGS
void BUGSParser::msynpred7_BUGS_fragment(  )
{
    {
        //  /home/shriram/bugsparser/Parser/BUGS.g:87:43: ( uvNode | CONSTANTVALUE )

        ANTLR_UINT32 alt28;

        alt28=2;

        switch ( this->LA(1) )
        {
        case NODENAME:
        	{
        		alt28=1;
        	}
            break;
        case CONSTANTVALUE:
        	{
        		alt28=2;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 28 );
            ex->set_state( 0 );


            goto rulesynpred7_BUGSEx;

        }

        switch (alt28)
        {
    	case 1:
    	    // /home/shriram/bugsparser/Parser/BUGS.g:87:44: uvNode
    	    {
    	        this->followPush(FOLLOW_uvNode_in_synpred7_BUGS495);
    	        uvNode();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred7_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /home/shriram/bugsparser/Parser/BUGS.g:87:51: CONSTANTVALUE
    	    {
    	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_synpred7_BUGS497);
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred7_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred7_BUGSEx; /* Prevent compiler warnings */
rulesynpred7_BUGSEx: ;

}
// $ANTLR end synpred7_BUGS

// $ANTLR start synpred8_BUGS
void BUGSParser::msynpred8_BUGS_fragment(  )
{
    {
        //  /home/shriram/bugsparser/Parser/BUGS.g:90:23: ( uvNode | CONSTANTVALUE )

        ANTLR_UINT32 alt29;

        alt29=2;

        switch ( this->LA(1) )
        {
        case NODENAME:
        	{
        		alt29=1;
        	}
            break;
        case CONSTANTVALUE:
        	{
        		alt29=2;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 29 );
            ex->set_state( 0 );


            goto rulesynpred8_BUGSEx;

        }

        switch (alt29)
        {
    	case 1:
    	    // /home/shriram/bugsparser/Parser/BUGS.g:90:24: uvNode
    	    {
    	        this->followPush(FOLLOW_uvNode_in_synpred8_BUGS529);
    	        uvNode();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred8_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /home/shriram/bugsparser/Parser/BUGS.g:90:31: CONSTANTVALUE
    	    {
    	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_synpred8_BUGS531);
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred8_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred8_BUGSEx; /* Prevent compiler warnings */
rulesynpred8_BUGSEx: ;

}
// $ANTLR end synpred8_BUGS

// $ANTLR start synpred9_BUGS
void BUGSParser::msynpred9_BUGS_fragment(  )
{
    {
        //  /home/shriram/bugsparser/Parser/BUGS.g:102:4: ( uvNode | linkFunction )

        ANTLR_UINT32 alt30;

        alt30=2;

        switch ( this->LA(1) )
        {
        case NODENAME:
        	{
        		alt30=1;
        	}
            break;
        case CLOGLOGOPENBRACKET:
        case LOGITOPENBRACKET:
        case LOGOPENBRACKET:
        case PROBITOPENBRACKET:
        	{
        		alt30=2;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 30 );
            ex->set_state( 0 );


            goto rulesynpred9_BUGSEx;

        }

        switch (alt30)
        {
    	case 1:
    	    // /home/shriram/bugsparser/Parser/BUGS.g:102:5: uvNode
    	    {
    	        this->followPush(FOLLOW_uvNode_in_synpred9_BUGS612);
    	        uvNode();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred9_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /home/shriram/bugsparser/Parser/BUGS.g:102:14: linkFunction
    	    {
    	        this->followPush(FOLLOW_linkFunction_in_synpred9_BUGS616);
    	        linkFunction();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred9_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred9_BUGSEx; /* Prevent compiler warnings */
rulesynpred9_BUGSEx: ;

}
// $ANTLR end synpred9_BUGS

// $ANTLR start synpred10_BUGS
void BUGSParser::msynpred10_BUGS_fragment(  )
{
    // /home/shriram/bugsparser/Parser/BUGS.g:140:4: ( OPENBRACKET expression COLON )
    // /home/shriram/bugsparser/Parser/BUGS.g:140:5: OPENBRACKET expression COLON
    {
         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_synpred10_BUGS878);
        if  (this->hasException())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_expression_in_synpred10_BUGS880);
        expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(COLON, &FOLLOW_COLON_in_synpred10_BUGS882);
        if  (this->hasException())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred10_BUGSEx; /* Prevent compiler warnings */
rulesynpred10_BUGSEx: ;

}
// $ANTLR end synpred10_BUGS
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred5_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred1_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred9_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred7_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred7_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred2_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred8_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred8_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred3_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred10_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred6_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred4_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
