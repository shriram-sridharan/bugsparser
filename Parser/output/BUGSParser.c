/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /u/s/h/shrirams/bugsparser/Parser/BUGS.g
 *     -                            On : 2013-01-04 16:08:04
 *     -                for the parser : BUGSParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "BUGSParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pBUGSParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pBUGSParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pBUGSParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pBUGSParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   BUGSParserTokenNames[34+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ABSOPENBRACKET",
        (pANTLR3_UINT8) "BERNOULLIOPENBRACKET",
        (pANTLR3_UINT8) "BETAOPENBRACKET",
        (pANTLR3_UINT8) "CENSORBEGINWITHC",
        (pANTLR3_UINT8) "CENSORBEGINWITHI",
        (pANTLR3_UINT8) "CLOGLOGOPENBRACKET",
        (pANTLR3_UINT8) "CLOSEBRACE",
        (pANTLR3_UINT8) "CLOSEBRACKET",
        (pANTLR3_UINT8) "CLOSESQUAREBRACKET",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "CONSTANTINT",
        (pANTLR3_UINT8) "CONSTANTVALUE",
        (pANTLR3_UINT8) "DIRICHLETOPENBRACKET",
        (pANTLR3_UINT8) "DIV",
        (pANTLR3_UINT8) "FORSTART",
        (pANTLR3_UINT8) "IN",
        (pANTLR3_UINT8) "INVERSEOPENBRACKET",
        (pANTLR3_UINT8) "LEFTPOINTER",
        (pANTLR3_UINT8) "LOGITOPENBRACKET",
        (pANTLR3_UINT8) "LOGOPENBRACKET",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "MODEL",
        (pANTLR3_UINT8) "MULT",
        (pANTLR3_UINT8) "MUTLTINOMIALOPENBRACKET",
        (pANTLR3_UINT8) "NODENAME",
        (pANTLR3_UINT8) "OPENBRACE",
        (pANTLR3_UINT8) "OPENBRACKET",
        (pANTLR3_UINT8) "OPENSQUAREBRACKET",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "PROBITOPENBRACKET",
        (pANTLR3_UINT8) "TILDE",
        (pANTLR3_UINT8) "TRUNCATIONBEGIN",
        (pANTLR3_UINT8) "WHITESPACE"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	prog    (pBUGSParser ctx);
static 
 void
	statements    (pBUGSParser ctx);
static 
 void
	stochasticNodeExpr    (pBUGSParser ctx);
static 
 void
	uvStochasticNodeExpr    (pBUGSParser ctx);
static 
 void
	mvStochasticNodeExpr    (pBUGSParser ctx);
static 
 void
	censor    (pBUGSParser ctx);
static 
 void
	truncation    (pBUGSParser ctx);
static 
 void
	lowerWithOptionalUpper    (pBUGSParser ctx);
static 
 void
	upperWithOptionalLower    (pBUGSParser ctx);
static 
 void
	logicalNodeExpr    (pBUGSParser ctx);
static 
 void
	linkFunction    (pBUGSParser ctx);
static 
 void
	exprWithNodesFunctions    (pBUGSParser ctx);
static 
 void
	uvNode    (pBUGSParser ctx);
static 
 void
	mvNode    (pBUGSParser ctx);
static 
 void
	expression    (pBUGSParser ctx);
static 
 void
	unaryExpression    (pBUGSParser ctx);
static 
 void
	multiIndices    (pBUGSParser ctx);
static 
 void
	multiDimExpression    (pBUGSParser ctx);
static 
 void
	startFor    (pBUGSParser ctx);
static 
 void
	endFor    (pBUGSParser ctx);
static 
 void
	loopVariable    (pBUGSParser ctx);
static 
 void
	loopBegin    (pBUGSParser ctx);
static 
 void
	loopEnd    (pBUGSParser ctx);
static 
 void
	scalarFunctions    (pBUGSParser ctx);
static 
 void
	vectorFunctions    (pBUGSParser ctx);
static 
 void
	uvDistribution    (pBUGSParser ctx);
static 
 void
	mvDistribution    (pBUGSParser ctx);
static 
 void
	discreteUnivariate    (pBUGSParser ctx);
static 
 void
	continuousUnivariate    (pBUGSParser ctx);
static 
 void
	discreteMultivariate    (pBUGSParser ctx);
static 
 void
	continuousMultivariate    (pBUGSParser ctx);
static 
 void
	distributionParameter    (pBUGSParser ctx);
static 
 void
	bernoulli    (pBUGSParser ctx);
static 
 void
	beta    (pBUGSParser ctx);
static 
 void
	multinomial    (pBUGSParser ctx);
static 
 void
	dirichlet    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred1_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred2_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred3_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred4_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred5_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred6_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred7_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred8_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred9_BUGS    (pBUGSParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred10_BUGS    (pBUGSParser ctx);
static void	BUGSParserFree(pBUGSParser ctx);
static void     BUGSParserReset (pBUGSParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/u/s/h/shrirams/bugsparser/Parser/BUGS.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new BUGSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pBUGSParser
BUGSParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return BUGSParserNewSSD(instream, NULL);
}

/** \brief Create a new BUGSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pBUGSParser
BUGSParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pBUGSParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pBUGSParser) ANTLR3_CALLOC(1, sizeof(BUGSParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in BUGSParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our BUGSParser interface
     */
    ctx->prog	= prog;
    ctx->statements	= statements;
    ctx->stochasticNodeExpr	= stochasticNodeExpr;
    ctx->uvStochasticNodeExpr	= uvStochasticNodeExpr;
    ctx->mvStochasticNodeExpr	= mvStochasticNodeExpr;
    ctx->censor	= censor;
    ctx->truncation	= truncation;
    ctx->lowerWithOptionalUpper	= lowerWithOptionalUpper;
    ctx->upperWithOptionalLower	= upperWithOptionalLower;
    ctx->logicalNodeExpr	= logicalNodeExpr;
    ctx->linkFunction	= linkFunction;
    ctx->exprWithNodesFunctions	= exprWithNodesFunctions;
    ctx->uvNode	= uvNode;
    ctx->mvNode	= mvNode;
    ctx->expression	= expression;
    ctx->unaryExpression	= unaryExpression;
    ctx->multiIndices	= multiIndices;
    ctx->multiDimExpression	= multiDimExpression;
    ctx->startFor	= startFor;
    ctx->endFor	= endFor;
    ctx->loopVariable	= loopVariable;
    ctx->loopBegin	= loopBegin;
    ctx->loopEnd	= loopEnd;
    ctx->scalarFunctions	= scalarFunctions;
    ctx->vectorFunctions	= vectorFunctions;
    ctx->uvDistribution	= uvDistribution;
    ctx->mvDistribution	= mvDistribution;
    ctx->discreteUnivariate	= discreteUnivariate;
    ctx->continuousUnivariate	= continuousUnivariate;
    ctx->discreteMultivariate	= discreteMultivariate;
    ctx->continuousMultivariate	= continuousMultivariate;
    ctx->distributionParameter	= distributionParameter;
    ctx->bernoulli	= bernoulli;
    ctx->beta	= beta;
    ctx->multinomial	= multinomial;
    ctx->dirichlet	= dirichlet;
    ctx->synpred1_BUGS	= synpred1_BUGS;
    ctx->synpred2_BUGS	= synpred2_BUGS;
    ctx->synpred3_BUGS	= synpred3_BUGS;
    ctx->synpred4_BUGS	= synpred4_BUGS;
    ctx->synpred5_BUGS	= synpred5_BUGS;
    ctx->synpred6_BUGS	= synpred6_BUGS;
    ctx->synpred7_BUGS	= synpred7_BUGS;
    ctx->synpred8_BUGS	= synpred8_BUGS;
    ctx->synpred9_BUGS	= synpred9_BUGS;
    ctx->synpred10_BUGS	= synpred10_BUGS;
    ctx->free			= BUGSParserFree;
    ctx->reset			= BUGSParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = BUGSParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
BUGSParserReset (pBUGSParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 BUGSParserFree(pBUGSParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return BUGSParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MODEL_in_prog419  */
static	ANTLR3_BITWORD FOLLOW_MODEL_in_prog419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_MODEL_in_prog419	= { FOLLOW_MODEL_in_prog419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENBRACE_in_prog421  */
static	ANTLR3_BITWORD FOLLOW_OPENBRACE_in_prog421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000421880200) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENBRACE_in_prog421	= { FOLLOW_OPENBRACE_in_prog421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statements_in_prog423  */
static	ANTLR3_BITWORD FOLLOW_statements_in_prog423_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_statements_in_prog423	= { FOLLOW_statements_in_prog423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACE_in_prog425  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACE_in_prog425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACE_in_prog425	= { FOLLOW_CLOSEBRACE_in_prog425_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stochasticNodeExpr_in_statements446  */
static	ANTLR3_BITWORD FOLLOW_stochasticNodeExpr_in_statements446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000421880202) };
static  ANTLR3_BITSET_LIST FOLLOW_stochasticNodeExpr_in_statements446	= { FOLLOW_stochasticNodeExpr_in_statements446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stochasticNodeExpr_in_statements460  */
static	ANTLR3_BITWORD FOLLOW_stochasticNodeExpr_in_statements460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000421880202) };
static  ANTLR3_BITSET_LIST FOLLOW_stochasticNodeExpr_in_statements460	= { FOLLOW_stochasticNodeExpr_in_statements460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicalNodeExpr_in_statements473  */
static	ANTLR3_BITWORD FOLLOW_logicalNodeExpr_in_statements473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000421880202) };
static  ANTLR3_BITSET_LIST FOLLOW_logicalNodeExpr_in_statements473	= { FOLLOW_logicalNodeExpr_in_statements473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicalNodeExpr_in_statements487  */
static	ANTLR3_BITWORD FOLLOW_logicalNodeExpr_in_statements487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000421880202) };
static  ANTLR3_BITSET_LIST FOLLOW_logicalNodeExpr_in_statements487	= { FOLLOW_logicalNodeExpr_in_statements487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logicalNodeExpr_in_statements501  */
static	ANTLR3_BITWORD FOLLOW_logicalNodeExpr_in_statements501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000421880202) };
static  ANTLR3_BITSET_LIST FOLLOW_logicalNodeExpr_in_statements501	= { FOLLOW_logicalNodeExpr_in_statements501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_startFor_in_statements508  */
static	ANTLR3_BITWORD FOLLOW_startFor_in_statements508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000421880200) };
static  ANTLR3_BITSET_LIST FOLLOW_startFor_in_statements508	= { FOLLOW_startFor_in_statements508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statements_in_statements510  */
static	ANTLR3_BITWORD FOLLOW_statements_in_statements510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_statements_in_statements510	= { FOLLOW_statements_in_statements510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_endFor_in_statements512  */
static	ANTLR3_BITWORD FOLLOW_endFor_in_statements512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000421880202) };
static  ANTLR3_BITSET_LIST FOLLOW_endFor_in_statements512	= { FOLLOW_endFor_in_statements512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr536  */
static	ANTLR3_BITWORD FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr536_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr536	= { FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr536_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_censor_in_stochasticNodeExpr539  */
static	ANTLR3_BITWORD FOLLOW_censor_in_stochasticNodeExpr539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_censor_in_stochasticNodeExpr539	= { FOLLOW_censor_in_stochasticNodeExpr539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truncation_in_stochasticNodeExpr543  */
static	ANTLR3_BITWORD FOLLOW_truncation_in_stochasticNodeExpr543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truncation_in_stochasticNodeExpr543	= { FOLLOW_truncation_in_stochasticNodeExpr543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr550  */
static	ANTLR3_BITWORD FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr550	= { FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_uvStochasticNodeExpr561  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_uvStochasticNodeExpr561_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_uvStochasticNodeExpr561	= { FOLLOW_uvNode_in_uvStochasticNodeExpr561_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TILDE_in_uvStochasticNodeExpr563  */
static	ANTLR3_BITWORD FOLLOW_TILDE_in_uvStochasticNodeExpr563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000060) };
static  ANTLR3_BITSET_LIST FOLLOW_TILDE_in_uvStochasticNodeExpr563	= { FOLLOW_TILDE_in_uvStochasticNodeExpr563_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvDistribution_in_uvStochasticNodeExpr565  */
static	ANTLR3_BITWORD FOLLOW_uvDistribution_in_uvStochasticNodeExpr565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvDistribution_in_uvStochasticNodeExpr565	= { FOLLOW_uvDistribution_in_uvStochasticNodeExpr565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mvNode_in_mvStochasticNodeExpr575  */
static	ANTLR3_BITWORD FOLLOW_mvNode_in_mvStochasticNodeExpr575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_mvNode_in_mvStochasticNodeExpr575	= { FOLLOW_mvNode_in_mvStochasticNodeExpr575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TILDE_in_mvStochasticNodeExpr577  */
static	ANTLR3_BITWORD FOLLOW_TILDE_in_mvStochasticNodeExpr577_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010020000) };
static  ANTLR3_BITSET_LIST FOLLOW_TILDE_in_mvStochasticNodeExpr577	= { FOLLOW_TILDE_in_mvStochasticNodeExpr577_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mvDistribution_in_mvStochasticNodeExpr579  */
static	ANTLR3_BITWORD FOLLOW_mvDistribution_in_mvStochasticNodeExpr579_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_mvDistribution_in_mvStochasticNodeExpr579	= { FOLLOW_mvDistribution_in_mvStochasticNodeExpr579_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_censor592  */
static	ANTLR3_BITWORD FOLLOW_set_in_censor592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020014000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_censor592	= { FOLLOW_set_in_censor592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lowerWithOptionalUpper_in_censor607  */
static	ANTLR3_BITWORD FOLLOW_lowerWithOptionalUpper_in_censor607_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_lowerWithOptionalUpper_in_censor607	= { FOLLOW_lowerWithOptionalUpper_in_censor607_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_upperWithOptionalLower_in_censor612  */
static	ANTLR3_BITWORD FOLLOW_upperWithOptionalLower_in_censor612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_upperWithOptionalLower_in_censor612	= { FOLLOW_upperWithOptionalLower_in_censor612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_censor617  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_censor617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_censor617	= { FOLLOW_CLOSEBRACKET_in_censor617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUNCATIONBEGIN_in_truncation629  */
static	ANTLR3_BITWORD FOLLOW_TRUNCATIONBEGIN_in_truncation629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020014000) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUNCATIONBEGIN_in_truncation629	= { FOLLOW_TRUNCATIONBEGIN_in_truncation629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lowerWithOptionalUpper_in_truncation642  */
static	ANTLR3_BITWORD FOLLOW_lowerWithOptionalUpper_in_truncation642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_lowerWithOptionalUpper_in_truncation642	= { FOLLOW_lowerWithOptionalUpper_in_truncation642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_upperWithOptionalLower_in_truncation646  */
static	ANTLR3_BITWORD FOLLOW_upperWithOptionalLower_in_truncation646_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_upperWithOptionalLower_in_truncation646	= { FOLLOW_upperWithOptionalLower_in_truncation646_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_truncation651  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_truncation651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_truncation651	= { FOLLOW_CLOSEBRACKET_in_truncation651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_lowerWithOptionalUpper666  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_lowerWithOptionalUpper666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_lowerWithOptionalUpper666	= { FOLLOW_uvNode_in_lowerWithOptionalUpper666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper668  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper668_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper668	= { FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper668_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_lowerWithOptionalUpper671  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_lowerWithOptionalUpper671_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020010002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_lowerWithOptionalUpper671	= { FOLLOW_COMMA_in_lowerWithOptionalUpper671_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_lowerWithOptionalUpper674  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_lowerWithOptionalUpper674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_lowerWithOptionalUpper674	= { FOLLOW_uvNode_in_lowerWithOptionalUpper674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper676  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper676	= { FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_upperWithOptionalLower693  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_upperWithOptionalLower693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_upperWithOptionalLower693	= { FOLLOW_uvNode_in_upperWithOptionalLower693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower695  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower695	= { FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower695_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_upperWithOptionalLower699  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_upperWithOptionalLower699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020010000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_upperWithOptionalLower699	= { FOLLOW_COMMA_in_upperWithOptionalLower699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_upperWithOptionalLower702  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_upperWithOptionalLower702_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_upperWithOptionalLower702	= { FOLLOW_uvNode_in_upperWithOptionalLower702_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower704  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower704	= { FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_logicalNodeExpr728  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_logicalNodeExpr728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_logicalNodeExpr728	= { FOLLOW_uvNode_in_logicalNodeExpr728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_linkFunction_in_logicalNodeExpr732  */
static	ANTLR3_BITWORD FOLLOW_linkFunction_in_logicalNodeExpr732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_linkFunction_in_logicalNodeExpr732	= { FOLLOW_linkFunction_in_logicalNodeExpr732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFTPOINTER_in_logicalNodeExpr735  */
static	ANTLR3_BITWORD FOLLOW_LEFTPOINTER_in_logicalNodeExpr735_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A2218010) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFTPOINTER_in_logicalNodeExpr735	= { FOLLOW_LEFTPOINTER_in_logicalNodeExpr735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr737  */
static	ANTLR3_BITWORD FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr737	= { FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mvNode_in_logicalNodeExpr743  */
static	ANTLR3_BITWORD FOLLOW_mvNode_in_logicalNodeExpr743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_mvNode_in_logicalNodeExpr743	= { FOLLOW_mvNode_in_logicalNodeExpr743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFTPOINTER_in_logicalNodeExpr745  */
static	ANTLR3_BITWORD FOLLOW_LEFTPOINTER_in_logicalNodeExpr745_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A2218010) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFTPOINTER_in_logicalNodeExpr745	= { FOLLOW_LEFTPOINTER_in_logicalNodeExpr745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr747  */
static	ANTLR3_BITWORD FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr747	= { FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOGOPENBRACKET_in_linkFunction759  */
static	ANTLR3_BITWORD FOLLOW_LOGOPENBRACKET_in_linkFunction759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LOGOPENBRACKET_in_linkFunction759	= { FOLLOW_LOGOPENBRACKET_in_linkFunction759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_linkFunction761  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_linkFunction761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_linkFunction761	= { FOLLOW_uvNode_in_linkFunction761_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_linkFunction763  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_linkFunction763	= { FOLLOW_CLOSEBRACKET_in_linkFunction763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOGITOPENBRACKET_in_linkFunction769  */
static	ANTLR3_BITWORD FOLLOW_LOGITOPENBRACKET_in_linkFunction769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LOGITOPENBRACKET_in_linkFunction769	= { FOLLOW_LOGITOPENBRACKET_in_linkFunction769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_linkFunction771  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_linkFunction771_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_linkFunction771	= { FOLLOW_uvNode_in_linkFunction771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_linkFunction773  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction773_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_linkFunction773	= { FOLLOW_CLOSEBRACKET_in_linkFunction773_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction778  */
static	ANTLR3_BITWORD FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction778_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction778	= { FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction778_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_linkFunction780  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_linkFunction780_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_linkFunction780	= { FOLLOW_uvNode_in_linkFunction780_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_linkFunction782  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_linkFunction782	= { FOLLOW_CLOSEBRACKET_in_linkFunction782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROBITOPENBRACKET_in_linkFunction787  */
static	ANTLR3_BITWORD FOLLOW_PROBITOPENBRACKET_in_linkFunction787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PROBITOPENBRACKET_in_linkFunction787	= { FOLLOW_PROBITOPENBRACKET_in_linkFunction787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_linkFunction789  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_linkFunction789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_linkFunction789	= { FOLLOW_uvNode_in_linkFunction789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_linkFunction791  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_linkFunction791	= { FOLLOW_CLOSEBRACKET_in_linkFunction791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpression_in_exprWithNodesFunctions804  */
static	ANTLR3_BITWORD FOLLOW_unaryExpression_in_exprWithNodesFunctions804_bits[]	= { ANTLR3_UINT64_LIT(0x000000020A040002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpression_in_exprWithNodesFunctions804	= { FOLLOW_unaryExpression_in_exprWithNodesFunctions804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENBRACKET_in_exprWithNodesFunctions808  */
static	ANTLR3_BITWORD FOLLOW_OPENBRACKET_in_exprWithNodesFunctions808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENBRACKET_in_exprWithNodesFunctions808	= { FOLLOW_OPENBRACKET_in_exprWithNodesFunctions808_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_exprWithNodesFunctions810  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_exprWithNodesFunctions810_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_exprWithNodesFunctions810	= { FOLLOW_MINUS_in_exprWithNodesFunctions810_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpression_in_exprWithNodesFunctions812  */
static	ANTLR3_BITWORD FOLLOW_unaryExpression_in_exprWithNodesFunctions812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpression_in_exprWithNodesFunctions812	= { FOLLOW_unaryExpression_in_exprWithNodesFunctions812_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions815  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions815_bits[]	= { ANTLR3_UINT64_LIT(0x000000020A040002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions815	= { FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_exprWithNodesFunctions819  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_exprWithNodesFunctions819_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_exprWithNodesFunctions819	= { FOLLOW_MINUS_in_exprWithNodesFunctions819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpression_in_exprWithNodesFunctions821  */
static	ANTLR3_BITWORD FOLLOW_unaryExpression_in_exprWithNodesFunctions821_bits[]	= { ANTLR3_UINT64_LIT(0x000000020A040002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpression_in_exprWithNodesFunctions821	= { FOLLOW_unaryExpression_in_exprWithNodesFunctions821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_scalarFunctions_in_exprWithNodesFunctions825  */
static	ANTLR3_BITWORD FOLLOW_scalarFunctions_in_exprWithNodesFunctions825_bits[]	= { ANTLR3_UINT64_LIT(0x000000020A040002) };
static  ANTLR3_BITSET_LIST FOLLOW_scalarFunctions_in_exprWithNodesFunctions825	= { FOLLOW_scalarFunctions_in_exprWithNodesFunctions825_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_vectorFunctions_in_exprWithNodesFunctions829  */
static	ANTLR3_BITWORD FOLLOW_vectorFunctions_in_exprWithNodesFunctions829_bits[]	= { ANTLR3_UINT64_LIT(0x000000020A040002) };
static  ANTLR3_BITSET_LIST FOLLOW_vectorFunctions_in_exprWithNodesFunctions829	= { FOLLOW_vectorFunctions_in_exprWithNodesFunctions829_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_exprWithNodesFunctions834  */
static	ANTLR3_BITWORD FOLLOW_set_in_exprWithNodesFunctions834_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A2218010) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_exprWithNodesFunctions834	= { FOLLOW_set_in_exprWithNodesFunctions834_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions844  */
static	ANTLR3_BITWORD FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions844	= { FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NODENAME_in_uvNode858  */
static	ANTLR3_BITWORD FOLLOW_NODENAME_in_uvNode858_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NODENAME_in_uvNode858	= { FOLLOW_NODENAME_in_uvNode858_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENSQUAREBRACKET_in_uvNode861  */
static	ANTLR3_BITWORD FOLLOW_OPENSQUAREBRACKET_in_uvNode861_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENSQUAREBRACKET_in_uvNode861	= { FOLLOW_OPENSQUAREBRACKET_in_uvNode861_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_uvNode863  */
static	ANTLR3_BITWORD FOLLOW_expression_in_uvNode863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000005000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_uvNode863	= { FOLLOW_expression_in_uvNode863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_uvNode866  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_uvNode866_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_uvNode866	= { FOLLOW_COMMA_in_uvNode866_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_uvNode868  */
static	ANTLR3_BITWORD FOLLOW_expression_in_uvNode868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000005000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_uvNode868	= { FOLLOW_expression_in_uvNode868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSESQUAREBRACKET_in_uvNode873  */
static	ANTLR3_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_uvNode873_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSESQUAREBRACKET_in_uvNode873	= { FOLLOW_CLOSESQUAREBRACKET_in_uvNode873_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NODENAME_in_mvNode886  */
static	ANTLR3_BITWORD FOLLOW_NODENAME_in_mvNode886_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NODENAME_in_mvNode886	= { FOLLOW_NODENAME_in_mvNode886_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENSQUAREBRACKET_in_mvNode888  */
static	ANTLR3_BITWORD FOLLOW_OPENSQUAREBRACKET_in_mvNode888_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENSQUAREBRACKET_in_mvNode888	= { FOLLOW_OPENSQUAREBRACKET_in_mvNode888_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiIndices_in_mvNode890  */
static	ANTLR3_BITWORD FOLLOW_multiIndices_in_mvNode890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_multiIndices_in_mvNode890	= { FOLLOW_multiIndices_in_mvNode890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSESQUAREBRACKET_in_mvNode892  */
static	ANTLR3_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_mvNode892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSESQUAREBRACKET_in_mvNode892	= { FOLLOW_CLOSESQUAREBRACKET_in_mvNode892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unaryExpression_in_expression904  */
static	ANTLR3_BITWORD FOLLOW_unaryExpression_in_expression904_bits[]	= { ANTLR3_UINT64_LIT(0x000000020A040002) };
static  ANTLR3_BITSET_LIST FOLLOW_unaryExpression_in_expression904	= { FOLLOW_unaryExpression_in_expression904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression907  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression907_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression907	= { FOLLOW_set_in_expression907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression917  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression917	= { FOLLOW_expression_in_expression917_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTINT_in_unaryExpression930  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTINT_in_unaryExpression930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTINT_in_unaryExpression930	= { FOLLOW_CONSTANTINT_in_unaryExpression930_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTVALUE_in_unaryExpression937  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTVALUE_in_unaryExpression937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTVALUE_in_unaryExpression937	= { FOLLOW_CONSTANTVALUE_in_unaryExpression937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_unaryExpression942  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_unaryExpression942_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_unaryExpression942	= { FOLLOW_uvNode_in_unaryExpression942_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENBRACKET_in_unaryExpression948  */
static	ANTLR3_BITWORD FOLLOW_OPENBRACKET_in_unaryExpression948_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENBRACKET_in_unaryExpression948	= { FOLLOW_OPENBRACKET_in_unaryExpression948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_unaryExpression950  */
static	ANTLR3_BITWORD FOLLOW_expression_in_unaryExpression950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_unaryExpression950	= { FOLLOW_expression_in_unaryExpression950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_unaryExpression952  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_unaryExpression952_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_unaryExpression952	= { FOLLOW_CLOSEBRACKET_in_unaryExpression952_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiDimExpression_in_multiIndices964  */
static	ANTLR3_BITWORD FOLLOW_multiDimExpression_in_multiIndices964_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiDimExpression_in_multiIndices964	= { FOLLOW_multiDimExpression_in_multiIndices964_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_multiIndices967  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_multiIndices967_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_multiIndices967	= { FOLLOW_COMMA_in_multiIndices967_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiDimExpression_in_multiIndices969  */
static	ANTLR3_BITWORD FOLLOW_multiDimExpression_in_multiIndices969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiDimExpression_in_multiIndices969	= { FOLLOW_multiDimExpression_in_multiIndices969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENBRACKET_in_multiDimExpression993  */
static	ANTLR3_BITWORD FOLLOW_OPENBRACKET_in_multiDimExpression993_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENBRACKET_in_multiDimExpression993	= { FOLLOW_OPENBRACKET_in_multiDimExpression993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_multiDimExpression995  */
static	ANTLR3_BITWORD FOLLOW_expression_in_multiDimExpression995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_multiDimExpression995	= { FOLLOW_expression_in_multiDimExpression995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_multiDimExpression997  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_multiDimExpression997_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_multiDimExpression997	= { FOLLOW_COLON_in_multiDimExpression997_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_multiDimExpression999  */
static	ANTLR3_BITWORD FOLLOW_expression_in_multiDimExpression999_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_multiDimExpression999	= { FOLLOW_expression_in_multiDimExpression999_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_multiDimExpression1001  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_multiDimExpression1001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_multiDimExpression1001	= { FOLLOW_CLOSEBRACKET_in_multiDimExpression1001_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_multiDimExpression1006  */
static	ANTLR3_BITWORD FOLLOW_expression_in_multiDimExpression1006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_multiDimExpression1006	= { FOLLOW_expression_in_multiDimExpression1006_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_multiDimExpression1009  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_multiDimExpression1009_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_multiDimExpression1009	= { FOLLOW_COLON_in_multiDimExpression1009_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_multiDimExpression1011  */
static	ANTLR3_BITWORD FOLLOW_expression_in_multiDimExpression1011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_multiDimExpression1011	= { FOLLOW_expression_in_multiDimExpression1011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORSTART_in_startFor1025  */
static	ANTLR3_BITWORD FOLLOW_FORSTART_in_startFor1025_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FORSTART_in_startFor1025	= { FOLLOW_FORSTART_in_startFor1025_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENBRACKET_in_startFor1027  */
static	ANTLR3_BITWORD FOLLOW_OPENBRACKET_in_startFor1027_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENBRACKET_in_startFor1027	= { FOLLOW_OPENBRACKET_in_startFor1027_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loopVariable_in_startFor1029  */
static	ANTLR3_BITWORD FOLLOW_loopVariable_in_startFor1029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_loopVariable_in_startFor1029	= { FOLLOW_loopVariable_in_startFor1029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IN_in_startFor1031  */
static	ANTLR3_BITWORD FOLLOW_IN_in_startFor1031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020008000) };
static  ANTLR3_BITSET_LIST FOLLOW_IN_in_startFor1031	= { FOLLOW_IN_in_startFor1031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loopBegin_in_startFor1033  */
static	ANTLR3_BITWORD FOLLOW_loopBegin_in_startFor1033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_loopBegin_in_startFor1033	= { FOLLOW_loopBegin_in_startFor1033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_startFor1035  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_startFor1035_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020008000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_startFor1035	= { FOLLOW_COLON_in_startFor1035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_loopEnd_in_startFor1037  */
static	ANTLR3_BITWORD FOLLOW_loopEnd_in_startFor1037_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_loopEnd_in_startFor1037	= { FOLLOW_loopEnd_in_startFor1037_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_startFor1039  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_startFor1039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_startFor1039	= { FOLLOW_CLOSEBRACKET_in_startFor1039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENBRACE_in_startFor1041  */
static	ANTLR3_BITWORD FOLLOW_OPENBRACE_in_startFor1041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENBRACE_in_startFor1041	= { FOLLOW_OPENBRACE_in_startFor1041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACE_in_endFor1054  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACE_in_endFor1054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACE_in_endFor1054	= { FOLLOW_CLOSEBRACE_in_endFor1054_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NODENAME_in_loopVariable1066  */
static	ANTLR3_BITWORD FOLLOW_NODENAME_in_loopVariable1066_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NODENAME_in_loopVariable1066	= { FOLLOW_NODENAME_in_loopVariable1066_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_loopBegin1078  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_loopBegin1078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_loopBegin1078	= { FOLLOW_uvNode_in_loopBegin1078_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTINT_in_loopBegin1084  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTINT_in_loopBegin1084_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTINT_in_loopBegin1084	= { FOLLOW_CONSTANTINT_in_loopBegin1084_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_loopEnd1096  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_loopEnd1096_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_loopEnd1096	= { FOLLOW_uvNode_in_loopEnd1096_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTINT_in_loopEnd1102  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTINT_in_loopEnd1102_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTINT_in_loopEnd1102	= { FOLLOW_CONSTANTINT_in_loopEnd1102_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ABSOPENBRACKET_in_scalarFunctions1114  */
static	ANTLR3_BITWORD FOLLOW_ABSOPENBRACKET_in_scalarFunctions1114_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A2218010) };
static  ANTLR3_BITSET_LIST FOLLOW_ABSOPENBRACKET_in_scalarFunctions1114	= { FOLLOW_ABSOPENBRACKET_in_scalarFunctions1114_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exprWithNodesFunctions_in_scalarFunctions1116  */
static	ANTLR3_BITWORD FOLLOW_exprWithNodesFunctions_in_scalarFunctions1116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_exprWithNodesFunctions_in_scalarFunctions1116	= { FOLLOW_exprWithNodesFunctions_in_scalarFunctions1116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_scalarFunctions1118  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_scalarFunctions1118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_scalarFunctions1118	= { FOLLOW_CLOSEBRACKET_in_scalarFunctions1118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1130  */
static	ANTLR3_BITWORD FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1130	= { FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mvNode_in_vectorFunctions1132  */
static	ANTLR3_BITWORD FOLLOW_mvNode_in_vectorFunctions1132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_mvNode_in_vectorFunctions1132	= { FOLLOW_mvNode_in_vectorFunctions1132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_vectorFunctions1134  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_vectorFunctions1134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_vectorFunctions1134	= { FOLLOW_CLOSEBRACKET_in_vectorFunctions1134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_discreteUnivariate_in_uvDistribution1147  */
static	ANTLR3_BITWORD FOLLOW_discreteUnivariate_in_uvDistribution1147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_discreteUnivariate_in_uvDistribution1147	= { FOLLOW_discreteUnivariate_in_uvDistribution1147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_continuousUnivariate_in_uvDistribution1153  */
static	ANTLR3_BITWORD FOLLOW_continuousUnivariate_in_uvDistribution1153_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_continuousUnivariate_in_uvDistribution1153	= { FOLLOW_continuousUnivariate_in_uvDistribution1153_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_discreteMultivariate_in_mvDistribution1165  */
static	ANTLR3_BITWORD FOLLOW_discreteMultivariate_in_mvDistribution1165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_discreteMultivariate_in_mvDistribution1165	= { FOLLOW_discreteMultivariate_in_mvDistribution1165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_continuousMultivariate_in_mvDistribution1171  */
static	ANTLR3_BITWORD FOLLOW_continuousMultivariate_in_mvDistribution1171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_continuousMultivariate_in_mvDistribution1171	= { FOLLOW_continuousMultivariate_in_mvDistribution1171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bernoulli_in_discreteUnivariate1183  */
static	ANTLR3_BITWORD FOLLOW_bernoulli_in_discreteUnivariate1183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bernoulli_in_discreteUnivariate1183	= { FOLLOW_bernoulli_in_discreteUnivariate1183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_beta_in_continuousUnivariate1196  */
static	ANTLR3_BITWORD FOLLOW_beta_in_continuousUnivariate1196_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_beta_in_continuousUnivariate1196	= { FOLLOW_beta_in_continuousUnivariate1196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multinomial_in_discreteMultivariate1209  */
static	ANTLR3_BITWORD FOLLOW_multinomial_in_discreteMultivariate1209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multinomial_in_discreteMultivariate1209	= { FOLLOW_multinomial_in_discreteMultivariate1209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dirichlet_in_continuousMultivariate1221  */
static	ANTLR3_BITWORD FOLLOW_dirichlet_in_continuousMultivariate1221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dirichlet_in_continuousMultivariate1221	= { FOLLOW_dirichlet_in_continuousMultivariate1221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_distributionParameter1234  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_distributionParameter1234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_distributionParameter1234	= { FOLLOW_uvNode_in_distributionParameter1234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTINT_in_distributionParameter1238  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTINT_in_distributionParameter1238_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTINT_in_distributionParameter1238	= { FOLLOW_CONSTANTINT_in_distributionParameter1238_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTVALUE_in_distributionParameter1242  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTVALUE_in_distributionParameter1242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTVALUE_in_distributionParameter1242	= { FOLLOW_CONSTANTVALUE_in_distributionParameter1242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1255  */
static	ANTLR3_BITWORD FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020018000) };
static  ANTLR3_BITSET_LIST FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1255	= { FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_distributionParameter_in_bernoulli1257  */
static	ANTLR3_BITWORD FOLLOW_distributionParameter_in_bernoulli1257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_distributionParameter_in_bernoulli1257	= { FOLLOW_distributionParameter_in_bernoulli1257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_bernoulli1259  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_bernoulli1259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_bernoulli1259	= { FOLLOW_CLOSEBRACKET_in_bernoulli1259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BETAOPENBRACKET_in_beta1271  */
static	ANTLR3_BITWORD FOLLOW_BETAOPENBRACKET_in_beta1271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020018000) };
static  ANTLR3_BITSET_LIST FOLLOW_BETAOPENBRACKET_in_beta1271	= { FOLLOW_BETAOPENBRACKET_in_beta1271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_distributionParameter_in_beta1273  */
static	ANTLR3_BITWORD FOLLOW_distributionParameter_in_beta1273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_distributionParameter_in_beta1273	= { FOLLOW_distributionParameter_in_beta1273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_beta1275  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_beta1275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020018000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_beta1275	= { FOLLOW_COMMA_in_beta1275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_distributionParameter_in_beta1277  */
static	ANTLR3_BITWORD FOLLOW_distributionParameter_in_beta1277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_distributionParameter_in_beta1277	= { FOLLOW_distributionParameter_in_beta1277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_beta1279  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_beta1279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_beta1279	= { FOLLOW_CLOSEBRACKET_in_beta1279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1291  */
static	ANTLR3_BITWORD FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020018000) };
static  ANTLR3_BITSET_LIST FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1291	= { FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_distributionParameter_in_multinomial1293  */
static	ANTLR3_BITWORD FOLLOW_distributionParameter_in_multinomial1293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_distributionParameter_in_multinomial1293	= { FOLLOW_distributionParameter_in_multinomial1293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENSQUAREBRACKET_in_multinomial1295  */
static	ANTLR3_BITWORD FOLLOW_OPENSQUAREBRACKET_in_multinomial1295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENSQUAREBRACKET_in_multinomial1295	= { FOLLOW_OPENSQUAREBRACKET_in_multinomial1295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSESQUAREBRACKET_in_multinomial1297  */
static	ANTLR3_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_multinomial1297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSESQUAREBRACKET_in_multinomial1297	= { FOLLOW_CLOSESQUAREBRACKET_in_multinomial1297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_multinomial1299  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_multinomial1299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020018000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_multinomial1299	= { FOLLOW_COMMA_in_multinomial1299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_distributionParameter_in_multinomial1303  */
static	ANTLR3_BITWORD FOLLOW_distributionParameter_in_multinomial1303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_distributionParameter_in_multinomial1303	= { FOLLOW_distributionParameter_in_multinomial1303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSEBRACKET_in_multinomial1305  */
static	ANTLR3_BITWORD FOLLOW_CLOSEBRACKET_in_multinomial1305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSEBRACKET_in_multinomial1305	= { FOLLOW_CLOSEBRACKET_in_multinomial1305_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1317  */
static	ANTLR3_BITWORD FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1317_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020018000) };
static  ANTLR3_BITSET_LIST FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1317	= { FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1317_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_distributionParameter_in_dirichlet1319  */
static	ANTLR3_BITWORD FOLLOW_distributionParameter_in_dirichlet1319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_distributionParameter_in_dirichlet1319	= { FOLLOW_distributionParameter_in_dirichlet1319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENSQUAREBRACKET_in_dirichlet1321  */
static	ANTLR3_BITWORD FOLLOW_OPENSQUAREBRACKET_in_dirichlet1321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENSQUAREBRACKET_in_dirichlet1321	= { FOLLOW_OPENSQUAREBRACKET_in_dirichlet1321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1323  */
static	ANTLR3_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1323	= { FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_dirichlet1325  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_dirichlet1325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_dirichlet1325	= { FOLLOW_COMMA_in_dirichlet1325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_synpred1_BUGS439  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_synpred1_BUGS439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_synpred1_BUGS439	= { FOLLOW_uvNode_in_synpred1_BUGS439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TILDE_in_synpred1_BUGS441  */
static	ANTLR3_BITWORD FOLLOW_TILDE_in_synpred1_BUGS441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TILDE_in_synpred1_BUGS441	= { FOLLOW_TILDE_in_synpred1_BUGS441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mvNode_in_synpred2_BUGS453  */
static	ANTLR3_BITWORD FOLLOW_mvNode_in_synpred2_BUGS453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_mvNode_in_synpred2_BUGS453	= { FOLLOW_mvNode_in_synpred2_BUGS453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TILDE_in_synpred2_BUGS455  */
static	ANTLR3_BITWORD FOLLOW_TILDE_in_synpred2_BUGS455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TILDE_in_synpred2_BUGS455	= { FOLLOW_TILDE_in_synpred2_BUGS455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_synpred3_BUGS466  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_synpred3_BUGS466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_synpred3_BUGS466	= { FOLLOW_uvNode_in_synpred3_BUGS466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFTPOINTER_in_synpred3_BUGS468  */
static	ANTLR3_BITWORD FOLLOW_LEFTPOINTER_in_synpred3_BUGS468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFTPOINTER_in_synpred3_BUGS468	= { FOLLOW_LEFTPOINTER_in_synpred3_BUGS468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mvNode_in_synpred4_BUGS480  */
static	ANTLR3_BITWORD FOLLOW_mvNode_in_synpred4_BUGS480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_mvNode_in_synpred4_BUGS480	= { FOLLOW_mvNode_in_synpred4_BUGS480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFTPOINTER_in_synpred4_BUGS482  */
static	ANTLR3_BITWORD FOLLOW_LEFTPOINTER_in_synpred4_BUGS482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFTPOINTER_in_synpred4_BUGS482	= { FOLLOW_LEFTPOINTER_in_synpred4_BUGS482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_linkFunction_in_synpred5_BUGS494  */
static	ANTLR3_BITWORD FOLLOW_linkFunction_in_synpred5_BUGS494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_linkFunction_in_synpred5_BUGS494	= { FOLLOW_linkFunction_in_synpred5_BUGS494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFTPOINTER_in_synpred5_BUGS496  */
static	ANTLR3_BITWORD FOLLOW_LEFTPOINTER_in_synpred5_BUGS496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFTPOINTER_in_synpred5_BUGS496	= { FOLLOW_LEFTPOINTER_in_synpred5_BUGS496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_synpred6_BUGS531  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_synpred6_BUGS531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_synpred6_BUGS531	= { FOLLOW_uvNode_in_synpred6_BUGS531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_synpred7_BUGS601  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_synpred7_BUGS601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_synpred7_BUGS601	= { FOLLOW_uvNode_in_synpred7_BUGS601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTVALUE_in_synpred7_BUGS603  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTVALUE_in_synpred7_BUGS603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTVALUE_in_synpred7_BUGS603	= { FOLLOW_CONSTANTVALUE_in_synpred7_BUGS603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_synpred8_BUGS635  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_synpred8_BUGS635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_synpred8_BUGS635	= { FOLLOW_uvNode_in_synpred8_BUGS635_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTANTVALUE_in_synpred8_BUGS637  */
static	ANTLR3_BITWORD FOLLOW_CONSTANTVALUE_in_synpred8_BUGS637_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTANTVALUE_in_synpred8_BUGS637	= { FOLLOW_CONSTANTVALUE_in_synpred8_BUGS637_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uvNode_in_synpred9_BUGS718  */
static	ANTLR3_BITWORD FOLLOW_uvNode_in_synpred9_BUGS718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uvNode_in_synpred9_BUGS718	= { FOLLOW_uvNode_in_synpred9_BUGS718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_linkFunction_in_synpred9_BUGS722  */
static	ANTLR3_BITWORD FOLLOW_linkFunction_in_synpred9_BUGS722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_linkFunction_in_synpred9_BUGS722	= { FOLLOW_linkFunction_in_synpred9_BUGS722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPENBRACKET_in_synpred10_BUGS984  */
static	ANTLR3_BITWORD FOLLOW_OPENBRACKET_in_synpred10_BUGS984_bits[]	= { ANTLR3_UINT64_LIT(0x00000000A0018000) };
static  ANTLR3_BITSET_LIST FOLLOW_OPENBRACKET_in_synpred10_BUGS984	= { FOLLOW_OPENBRACKET_in_synpred10_BUGS984_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_synpred10_BUGS986  */
static	ANTLR3_BITWORD FOLLOW_expression_in_synpred10_BUGS986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_synpred10_BUGS986	= { FOLLOW_expression_in_synpred10_BUGS986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_synpred10_BUGS988  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_synpred10_BUGS988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_synpred10_BUGS988	= { FOLLOW_COLON_in_synpred10_BUGS988_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start prog
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:58:1: prog : ( MODEL OPENBRACE statements CLOSEBRACE )* ;
 */
static void
prog(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:58:6: ( ( MODEL OPENBRACE statements CLOSEBRACE )* )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:58:8: ( MODEL OPENBRACE statements CLOSEBRACE )*
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:58:8: ( MODEL OPENBRACE statements CLOSEBRACE )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) )
                {
                case MODEL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:58:9: MODEL OPENBRACE statements CLOSEBRACE
            	    {
            	         MATCHT(MODEL, &FOLLOW_MODEL_in_prog419);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(OPENBRACE, &FOLLOW_OPENBRACE_in_prog421);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_statements_in_prog423);
            	        statements(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(CLOSEBRACE, &FOLLOW_CLOSEBRACE_in_prog425);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end prog */

/**
 * $ANTLR start statements
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:60:1: statements : ( ( uvNode TILDE )=> stochasticNodeExpr | ( mvNode TILDE )=> stochasticNodeExpr | ( uvNode LEFTPOINTER )=> logicalNodeExpr | ( mvNode LEFTPOINTER )=> logicalNodeExpr | ( linkFunction LEFTPOINTER )=> logicalNodeExpr | ( startFor statements endFor ) )+ ;
 */
static void
statements(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:60:12: ( ( ( uvNode TILDE )=> stochasticNodeExpr | ( mvNode TILDE )=> stochasticNodeExpr | ( uvNode LEFTPOINTER )=> logicalNodeExpr | ( mvNode LEFTPOINTER )=> logicalNodeExpr | ( linkFunction LEFTPOINTER )=> logicalNodeExpr | ( startFor statements endFor ) )+ )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:60:15: ( ( uvNode TILDE )=> stochasticNodeExpr | ( mvNode TILDE )=> stochasticNodeExpr | ( uvNode LEFTPOINTER )=> logicalNodeExpr | ( mvNode LEFTPOINTER )=> logicalNodeExpr | ( linkFunction LEFTPOINTER )=> logicalNodeExpr | ( startFor statements endFor ) )+
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:60:15: ( ( uvNode TILDE )=> stochasticNodeExpr | ( mvNode TILDE )=> stochasticNodeExpr | ( uvNode LEFTPOINTER )=> logicalNodeExpr | ( mvNode LEFTPOINTER )=> logicalNodeExpr | ( linkFunction LEFTPOINTER )=> logicalNodeExpr | ( startFor statements endFor ) )+
            {
                int cnt2=0;

                for (;;)
                {
                    int alt2=7;
            	switch ( LA(1) )
            	{
            	case NODENAME:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_2 = LA(2);
            			    if ( (synpred1_BUGS(ctx)))
            			    {
            			        alt2=1;
            			    }
            			    else if ( (synpred2_BUGS(ctx)))
            			    {
            			        alt2=2;
            			    }
            			    else if ( (synpred3_BUGS(ctx)))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (synpred4_BUGS(ctx)))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (synpred5_BUGS(ctx)))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case LOGOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_3 = LA(2);
            			    if ( (synpred3_BUGS(ctx)))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (synpred4_BUGS(ctx)))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (synpred5_BUGS(ctx)))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case LOGITOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_4 = LA(2);
            			    if ( (synpred3_BUGS(ctx)))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (synpred4_BUGS(ctx)))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (synpred5_BUGS(ctx)))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case CLOGLOGOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_5 = LA(2);
            			    if ( (synpred3_BUGS(ctx)))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (synpred4_BUGS(ctx)))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (synpred5_BUGS(ctx)))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case PROBITOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA2_6 = LA(2);
            			    if ( (synpred3_BUGS(ctx)))
            			    {
            			        alt2=3;
            			    }
            			    else if ( (synpred4_BUGS(ctx)))
            			    {
            			        alt2=4;
            			    }
            			    else if ( (synpred5_BUGS(ctx)))
            			    {
            			        alt2=5;
            			    }

            			}
            		}
            	    break;
            	case FORSTART:
            		{
            			alt2=6;
            		}
            	    break;

            	}

            	switch (alt2)
            	{
            	    case 1:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:60:16: ( uvNode TILDE )=> stochasticNodeExpr
            	        {
            	            FOLLOWPUSH(FOLLOW_stochasticNodeExpr_in_statements446);
            	            stochasticNodeExpr(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 2:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:61:4: ( mvNode TILDE )=> stochasticNodeExpr
            	        {
            	            FOLLOWPUSH(FOLLOW_stochasticNodeExpr_in_statements460);
            	            stochasticNodeExpr(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 3:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:62:4: ( uvNode LEFTPOINTER )=> logicalNodeExpr
            	        {
            	            FOLLOWPUSH(FOLLOW_logicalNodeExpr_in_statements473);
            	            logicalNodeExpr(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 4:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:63:4: ( mvNode LEFTPOINTER )=> logicalNodeExpr
            	        {
            	            FOLLOWPUSH(FOLLOW_logicalNodeExpr_in_statements487);
            	            logicalNodeExpr(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 5:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:64:4: ( linkFunction LEFTPOINTER )=> logicalNodeExpr
            	        {
            	            FOLLOWPUSH(FOLLOW_logicalNodeExpr_in_statements501);
            	            logicalNodeExpr(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 6:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:65:4: ( startFor statements endFor )
            	        {
            	            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:65:4: ( startFor statements endFor )
            	            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:65:5: startFor statements endFor
            	            {
            	                FOLLOWPUSH(FOLLOW_startFor_in_statements508);
            	                startFor(ctx);

            	                FOLLOWPOP();
            	                if  (HASEXCEPTION())
            	                {
            	                    goto rulestatementsEx;
            	                }
            	                if (HASFAILED())
            	                {
            	                    return ;
            	                }


            	                FOLLOWPUSH(FOLLOW_statements_in_statements510);
            	                statements(ctx);

            	                FOLLOWPOP();
            	                if  (HASEXCEPTION())
            	                {
            	                    goto rulestatementsEx;
            	                }
            	                if (HASFAILED())
            	                {
            	                    return ;
            	                }


            	                FOLLOWPUSH(FOLLOW_endFor_in_statements512);
            	                endFor(ctx);

            	                FOLLOWPOP();
            	                if  (HASEXCEPTION())
            	                {
            	                    goto rulestatementsEx;
            	                }
            	                if (HASFAILED())
            	                {
            	                    return ;
            	                }


            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt2 >= 1 )
            		{
            		    goto loop2;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulestatementsEx;
            	}
            	cnt2++;
                }
                loop2: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestatementsEx; /* Prevent compiler warnings */
    rulestatementsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end statements */

/**
 * $ANTLR start stochasticNodeExpr
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:69:1: stochasticNodeExpr : ( ( uvNode )=> uvStochasticNodeExpr ( censor | truncation )? | mvStochasticNodeExpr );
 */
static void
stochasticNodeExpr(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:70:2: ( ( uvNode )=> uvStochasticNodeExpr ( censor | truncation )? | mvStochasticNodeExpr )

            ANTLR3_UINT32 alt4;

            alt4=2;

            switch ( LA(1) )
            {
            case NODENAME:
            	{
            		{
            		    int LA4_1 = LA(2);
            		    if ( (synpred6_BUGS(ctx)))
            		    {
            		        alt4=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt4=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 4;
            		        EXCEPTION->state        = 1;


            		        goto rulestochasticNodeExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto rulestochasticNodeExprEx;

            }

            switch (alt4)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:70:4: ( uvNode )=> uvStochasticNodeExpr ( censor | truncation )?
        	    {
        	        FOLLOWPUSH(FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr536);
        	        uvStochasticNodeExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestochasticNodeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:70:37: ( censor | truncation )?
        	        {
        	            int alt3=3;
        	            switch ( LA(1) )
        	            {
        	                case CENSORBEGINWITHC:
        	                case CENSORBEGINWITHI:
        	                	{
        	                		alt3=1;
        	                	}
        	                    break;
        	                case TRUNCATIONBEGIN:
        	                	{
        	                		alt3=2;
        	                	}
        	                    break;
        	            }

        	            switch (alt3)
        	            {
        	        	case 1:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:70:38: censor
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_censor_in_stochasticNodeExpr539);
        	        	        censor(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulestochasticNodeExprEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:70:47: truncation
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truncation_in_stochasticNodeExpr543);
        	        	        truncation(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulestochasticNodeExprEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:71:4: mvStochasticNodeExpr
        	    {
        	        FOLLOWPUSH(FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr550);
        	        mvStochasticNodeExpr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestochasticNodeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestochasticNodeExprEx; /* Prevent compiler warnings */
    rulestochasticNodeExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end stochasticNodeExpr */

/**
 * $ANTLR start uvStochasticNodeExpr
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:74:1: uvStochasticNodeExpr : uvNode TILDE uvDistribution ;
 */
static void
uvStochasticNodeExpr(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:75:2: ( uvNode TILDE uvDistribution )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:75:3: uvNode TILDE uvDistribution
        {
            FOLLOWPUSH(FOLLOW_uvNode_in_uvStochasticNodeExpr561);
            uvNode(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(TILDE, &FOLLOW_TILDE_in_uvStochasticNodeExpr563);
            if  (HASEXCEPTION())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_uvDistribution_in_uvStochasticNodeExpr565);
            uvDistribution(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleuvStochasticNodeExprEx; /* Prevent compiler warnings */
    ruleuvStochasticNodeExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end uvStochasticNodeExpr */

/**
 * $ANTLR start mvStochasticNodeExpr
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:77:1: mvStochasticNodeExpr : mvNode TILDE mvDistribution ;
 */
static void
mvStochasticNodeExpr(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:78:2: ( mvNode TILDE mvDistribution )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:78:3: mvNode TILDE mvDistribution
        {
            FOLLOWPUSH(FOLLOW_mvNode_in_mvStochasticNodeExpr575);
            mvNode(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(TILDE, &FOLLOW_TILDE_in_mvStochasticNodeExpr577);
            if  (HASEXCEPTION())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_mvDistribution_in_mvStochasticNodeExpr579);
            mvDistribution(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemvStochasticNodeExprEx; /* Prevent compiler warnings */
    rulemvStochasticNodeExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end mvStochasticNodeExpr */

/**
 * $ANTLR start censor
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:81:1: censor : ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET ;
 */
static void
censor(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:82:3: ( ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:82:5: ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET
        {
            if ( ((LA(1) >= CENSORBEGINWITHC) && (LA(1) <= CENSORBEGINWITHI)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulecensorEx;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:82:41: ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower )
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case NODENAME:
                	{
                		{
                		    int LA5_1 = LA(2);
                		    if ( (synpred7_BUGS(ctx)))
                		    {
                		        alt5=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt5=2;
                		    }
                		    else
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }


                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 5;
                		        EXCEPTION->state        = 1;


                		        goto rulecensorEx;

                		    }
                		}
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		{
                		    int LA5_2 = LA(2);
                		    if ( (synpred7_BUGS(ctx)))
                		    {
                		        alt5=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt5=2;
                		    }
                		    else
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }


                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 5;
                		        EXCEPTION->state        = 2;


                		        goto rulecensorEx;

                		    }
                		}
                	}
                    break;
                case COMMA:
                	{
                		alt5=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 5;
                    EXCEPTION->state        = 0;


                    goto rulecensorEx;

                }

                switch (alt5)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:82:43: ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper
            	    {
            	        FOLLOWPUSH(FOLLOW_lowerWithOptionalUpper_in_censor607);
            	        lowerWithOptionalUpper(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecensorEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:82:94: upperWithOptionalLower
            	    {
            	        FOLLOWPUSH(FOLLOW_upperWithOptionalLower_in_censor612);
            	        upperWithOptionalLower(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecensorEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_censor617);
            if  (HASEXCEPTION())
            {
                goto rulecensorEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecensorEx; /* Prevent compiler warnings */
    rulecensorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end censor */

/**
 * $ANTLR start truncation
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:84:1: truncation : TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET ;
 */
static void
truncation(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:2: ( TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:4: TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower ) CLOSEBRACKET
        {
             MATCHT(TRUNCATIONBEGIN, &FOLLOW_TRUNCATIONBEGIN_in_truncation629);
            if  (HASEXCEPTION())
            {
                goto ruletruncationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:20: ( ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper | upperWithOptionalLower )
            {
                int alt6=2;
                switch ( LA(1) )
                {
                case NODENAME:
                	{
                		{
                		    int LA6_1 = LA(2);
                		    if ( (synpred8_BUGS(ctx)))
                		    {
                		        alt6=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt6=2;
                		    }
                		    else
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }


                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 6;
                		        EXCEPTION->state        = 1;


                		        goto ruletruncationEx;

                		    }
                		}
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		{
                		    int LA6_2 = LA(2);
                		    if ( (synpred8_BUGS(ctx)))
                		    {
                		        alt6=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt6=2;
                		    }
                		    else
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }


                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 6;
                		        EXCEPTION->state        = 2;


                		        goto ruletruncationEx;

                		    }
                		}
                	}
                    break;
                case COMMA:
                	{
                		alt6=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 6;
                    EXCEPTION->state        = 0;


                    goto ruletruncationEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:23: ( uvNode | CONSTANTVALUE )=> lowerWithOptionalUpper
            	    {
            	        FOLLOWPUSH(FOLLOW_lowerWithOptionalUpper_in_truncation642);
            	        lowerWithOptionalUpper(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletruncationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:74: upperWithOptionalLower
            	    {
            	        FOLLOWPUSH(FOLLOW_upperWithOptionalLower_in_truncation646);
            	        upperWithOptionalLower(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletruncationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_truncation651);
            if  (HASEXCEPTION())
            {
                goto ruletruncationEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletruncationEx; /* Prevent compiler warnings */
    ruletruncationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end truncation */

/**
 * $ANTLR start lowerWithOptionalUpper
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:88:1: lowerWithOptionalUpper : ( uvNode | CONSTANTVALUE ) COMMA ( uvNode | CONSTANTVALUE )? ;
 */
static void
lowerWithOptionalUpper(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:2: ( ( uvNode | CONSTANTVALUE ) COMMA ( uvNode | CONSTANTVALUE )? )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:5: ( uvNode | CONSTANTVALUE ) COMMA ( uvNode | CONSTANTVALUE )?
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:5: ( uvNode | CONSTANTVALUE )
            {
                int alt7=2;
                switch ( LA(1) )
                {
                case NODENAME:
                	{
                		alt7=1;
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		alt7=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 7;
                    EXCEPTION->state        = 0;


                    goto rulelowerWithOptionalUpperEx;

                }

                switch (alt7)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:6: uvNode
            	    {
            	        FOLLOWPUSH(FOLLOW_uvNode_in_lowerWithOptionalUpper666);
            	        uvNode(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:13: CONSTANTVALUE
            	    {
            	         MATCHT(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper668);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(COMMA, &FOLLOW_COMMA_in_lowerWithOptionalUpper671);
            if  (HASEXCEPTION())
            {
                goto rulelowerWithOptionalUpperEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:34: ( uvNode | CONSTANTVALUE )?
            {
                int alt8=3;
                switch ( LA(1) )
                {
                    case NODENAME:
                    	{
                    		alt8=1;
                    	}
                        break;
                    case CONSTANTVALUE:
                    	{
                    		alt8=2;
                    	}
                        break;
                }

                switch (alt8)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:35: uvNode
            	    {
            	        FOLLOWPUSH(FOLLOW_uvNode_in_lowerWithOptionalUpper674);
            	        uvNode(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:42: CONSTANTVALUE
            	    {
            	         MATCHT(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_lowerWithOptionalUpper676);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulelowerWithOptionalUpperEx; /* Prevent compiler warnings */
    rulelowerWithOptionalUpperEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end lowerWithOptionalUpper */

/**
 * $ANTLR start upperWithOptionalLower
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:92:1: upperWithOptionalLower : ( uvNode | CONSTANTVALUE )? COMMA ( uvNode | CONSTANTVALUE ) ;
 */
static void
upperWithOptionalLower(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:2: ( ( uvNode | CONSTANTVALUE )? COMMA ( uvNode | CONSTANTVALUE ) )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:5: ( uvNode | CONSTANTVALUE )? COMMA ( uvNode | CONSTANTVALUE )
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:5: ( uvNode | CONSTANTVALUE )?
            {
                int alt9=3;
                switch ( LA(1) )
                {
                    case NODENAME:
                    	{
                    		alt9=1;
                    	}
                        break;
                    case CONSTANTVALUE:
                    	{
                    		alt9=2;
                    	}
                        break;
                }

                switch (alt9)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:6: uvNode
            	    {
            	        FOLLOWPUSH(FOLLOW_uvNode_in_upperWithOptionalLower693);
            	        uvNode(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:13: CONSTANTVALUE
            	    {
            	         MATCHT(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower695);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(COMMA, &FOLLOW_COMMA_in_upperWithOptionalLower699);
            if  (HASEXCEPTION())
            {
                goto ruleupperWithOptionalLowerEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:35: ( uvNode | CONSTANTVALUE )
            {
                int alt10=2;
                switch ( LA(1) )
                {
                case NODENAME:
                	{
                		alt10=1;
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		alt10=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 10;
                    EXCEPTION->state        = 0;


                    goto ruleupperWithOptionalLowerEx;

                }

                switch (alt10)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:36: uvNode
            	    {
            	        FOLLOWPUSH(FOLLOW_uvNode_in_upperWithOptionalLower702);
            	        uvNode(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:43: CONSTANTVALUE
            	    {
            	         MATCHT(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_upperWithOptionalLower704);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleupperWithOptionalLowerEx; /* Prevent compiler warnings */
    ruleupperWithOptionalLowerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end upperWithOptionalLower */

/**
 * $ANTLR start logicalNodeExpr
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:96:1: logicalNodeExpr : ( ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER exprWithNodesFunctions | mvNode LEFTPOINTER exprWithNodesFunctions );
 */
static void
logicalNodeExpr(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:97:2: ( ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER exprWithNodesFunctions | mvNode LEFTPOINTER exprWithNodesFunctions )

            ANTLR3_UINT32 alt12;

            alt12=2;

            {
                int LA12_0 = LA(1);
                if ( (LA12_0 == NODENAME))
                {
                    {
                        int LA12_1 = LA(2);
                        if ( (synpred9_BUGS(ctx)))
                        {
                            alt12=1;
                        }
                        else if ( (ANTLR3_TRUE))
                        {
                            alt12=2;
                        }
                        else
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }


                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 12;
                            EXCEPTION->state        = 1;


                            goto rulelogicalNodeExprEx;

                        }
                    }
                }
                else if ( (synpred9_BUGS(ctx)) && (LA12_0 == LOGOPENBRACKET))
                {
                    alt12=1;
                }
                else if ( (synpred9_BUGS(ctx)) && (LA12_0 == LOGITOPENBRACKET))
                {
                    alt12=1;
                }
                else if ( (synpred9_BUGS(ctx)) && (LA12_0 == CLOGLOGOPENBRACKET))
                {
                    alt12=1;
                }
                else if ( (synpred9_BUGS(ctx)) && (LA12_0 == PROBITOPENBRACKET))
                {
                    alt12=1;
                }
                else
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }


                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 12;
                    EXCEPTION->state        = 0;


                    goto rulelogicalNodeExprEx;

                }
            }
            switch (alt12)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:97:4: ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER exprWithNodesFunctions
        	    {
        	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:97:31: ( uvNode | linkFunction )
        	        {
        	            int alt11=2;
        	            switch ( LA(1) )
        	            {
        	            case NODENAME:
        	            	{
        	            		alt11=1;
        	            	}
        	                break;
        	            case CLOGLOGOPENBRACKET:
        	            case LOGITOPENBRACKET:
        	            case LOGOPENBRACKET:
        	            case PROBITOPENBRACKET:
        	            	{
        	            		alt11=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 11;
        	                EXCEPTION->state        = 0;


        	                goto rulelogicalNodeExprEx;

        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:97:32: uvNode
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_uvNode_in_logicalNodeExpr728);
        	        	        uvNode(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulelogicalNodeExprEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:97:41: linkFunction
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_linkFunction_in_logicalNodeExpr732);
        	        	        linkFunction(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulelogicalNodeExprEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_logicalNodeExpr735);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr737);
        	        exprWithNodesFunctions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:98:5: mvNode LEFTPOINTER exprWithNodesFunctions
        	    {
        	        FOLLOWPUSH(FOLLOW_mvNode_in_logicalNodeExpr743);
        	        mvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_logicalNodeExpr745);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr747);
        	        exprWithNodesFunctions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulelogicalNodeExprEx; /* Prevent compiler warnings */
    rulelogicalNodeExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end logicalNodeExpr */

/**
 * $ANTLR start linkFunction
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:101:1: linkFunction : ( LOGOPENBRACKET uvNode CLOSEBRACKET | LOGITOPENBRACKET uvNode CLOSEBRACKET | CLOGLOGOPENBRACKET uvNode CLOSEBRACKET | PROBITOPENBRACKET uvNode CLOSEBRACKET );
 */
static void
linkFunction(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:102:2: ( LOGOPENBRACKET uvNode CLOSEBRACKET | LOGITOPENBRACKET uvNode CLOSEBRACKET | CLOGLOGOPENBRACKET uvNode CLOSEBRACKET | PROBITOPENBRACKET uvNode CLOSEBRACKET )

            ANTLR3_UINT32 alt13;

            alt13=4;

            switch ( LA(1) )
            {
            case LOGOPENBRACKET:
            	{
            		alt13=1;
            	}
                break;
            case LOGITOPENBRACKET:
            	{
            		alt13=2;
            	}
                break;
            case CLOGLOGOPENBRACKET:
            	{
            		alt13=3;
            	}
                break;
            case PROBITOPENBRACKET:
            	{
            		alt13=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto rulelinkFunctionEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:102:4: LOGOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         MATCHT(LOGOPENBRACKET, &FOLLOW_LOGOPENBRACKET_in_linkFunction759);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_uvNode_in_linkFunction761);
        	        uvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction763);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:103:4: LOGITOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         MATCHT(LOGITOPENBRACKET, &FOLLOW_LOGITOPENBRACKET_in_linkFunction769);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_uvNode_in_linkFunction771);
        	        uvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction773);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:104:4: CLOGLOGOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         MATCHT(CLOGLOGOPENBRACKET, &FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction778);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_uvNode_in_linkFunction780);
        	        uvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction782);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:105:4: PROBITOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         MATCHT(PROBITOPENBRACKET, &FOLLOW_PROBITOPENBRACKET_in_linkFunction787);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_uvNode_in_linkFunction789);
        	        uvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction791);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulelinkFunctionEx; /* Prevent compiler warnings */
    rulelinkFunctionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end linkFunction */

/**
 * $ANTLR start exprWithNodesFunctions
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:108:1: exprWithNodesFunctions : ( unaryExpression | OPENBRACKET MINUS unaryExpression CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions ) ( ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions )? ;
 */
static void
exprWithNodesFunctions(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:2: ( ( unaryExpression | OPENBRACKET MINUS unaryExpression CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions ) ( ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions )? )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:4: ( unaryExpression | OPENBRACKET MINUS unaryExpression CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions ) ( ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions )?
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:4: ( unaryExpression | OPENBRACKET MINUS unaryExpression CLOSEBRACKET | MINUS unaryExpression | scalarFunctions | vectorFunctions )
            {
                int alt14=5;
                switch ( LA(1) )
                {
                case CONSTANTINT:
                case CONSTANTVALUE:
                case NODENAME:
                	{
                		alt14=1;
                	}
                    break;
                case OPENBRACKET:
                	{
                		switch ( LA(2) )
                		{
                		case MINUS:
                			{
                				alt14=2;
                			}
                		    break;
                		case CONSTANTINT:
                		case CONSTANTVALUE:
                		case NODENAME:
                		case OPENBRACKET:
                			{
                				alt14=1;
                			}
                		    break;

                		default:
                		    if (BACKTRACKING>0)
                		    {
                		        FAILEDFLAG = ANTLR3_TRUE;
                		        return ;
                		    }

                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 14;
                		    EXCEPTION->state        = 2;


                		    goto ruleexprWithNodesFunctionsEx;

                		}

                	}
                    break;
                case MINUS:
                	{
                		alt14=3;
                	}
                    break;
                case ABSOPENBRACKET:
                	{
                		alt14=4;
                	}
                    break;
                case INVERSEOPENBRACKET:
                	{
                		alt14=5;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto ruleexprWithNodesFunctionsEx;

                }

                switch (alt14)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:5: unaryExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_unaryExpression_in_exprWithNodesFunctions804);
            	        unaryExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:23: OPENBRACKET MINUS unaryExpression CLOSEBRACKET
            	    {
            	         MATCHT(OPENBRACKET, &FOLLOW_OPENBRACKET_in_exprWithNodesFunctions808);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(MINUS, &FOLLOW_MINUS_in_exprWithNodesFunctions810);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_unaryExpression_in_exprWithNodesFunctions812);
            	        unaryExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	         MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions815);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:73: MINUS unaryExpression
            	    {
            	         MATCHT(MINUS, &FOLLOW_MINUS_in_exprWithNodesFunctions819);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_unaryExpression_in_exprWithNodesFunctions821);
            	        unaryExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:97: scalarFunctions
            	    {
            	        FOLLOWPUSH(FOLLOW_scalarFunctions_in_exprWithNodesFunctions825);
            	        scalarFunctions(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 5:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:115: vectorFunctions
            	    {
            	        FOLLOWPUSH(FOLLOW_vectorFunctions_in_exprWithNodesFunctions829);
            	        vectorFunctions(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:133: ( ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions )?
            {
                int alt15=2;
                switch ( LA(1) )
                {
                    case DIV:
                    case MINUS:
                    case MULT:
                    case PLUS:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:134: ( PLUS | MINUS | MULT | DIV ) exprWithNodesFunctions
            	    {
            	        if ( LA(1) == DIV || LA(1) == MINUS || LA(1) == MULT || LA(1) == PLUS )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleexprWithNodesFunctionsEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions844);
            	        exprWithNodesFunctions(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexprWithNodesFunctionsEx; /* Prevent compiler warnings */
    ruleexprWithNodesFunctionsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end exprWithNodesFunctions */

/**
 * $ANTLR start uvNode
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:112:1: uvNode : NODENAME ( OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET )? ;
 */
static void
uvNode(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:113:2: ( NODENAME ( OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET )? )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:113:4: NODENAME ( OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET )?
        {
             MATCHT(NODENAME, &FOLLOW_NODENAME_in_uvNode858);
            if  (HASEXCEPTION())
            {
                goto ruleuvNodeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:113:13: ( OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET )?
            {
                int alt17=2;
                switch ( LA(1) )
                {
                    case OPENSQUAREBRACKET:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case CONSTANTINT:
                    		    case CONSTANTVALUE:
                    		    case NODENAME:
                    		    case OPENBRACKET:
                    		    	{
                    		    		alt17=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:113:14: OPENSQUAREBRACKET expression ( COMMA expression )* CLOSESQUAREBRACKET
            	    {
            	         MATCHT(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_uvNode861);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_uvNode863);
            	        expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:113:43: ( COMMA expression )*

            	        for (;;)
            	        {
            	            int alt16=2;
            	            switch ( LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt16=1;
            	            	}
            	                break;

            	            }

            	            switch (alt16)
            	            {
            	        	case 1:
            	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:113:44: COMMA expression
            	        	    {
            	        	         MATCHT(COMMA, &FOLLOW_COMMA_in_uvNode866);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleuvNodeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_expression_in_uvNode868);
            	        	        expression(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleuvNodeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop16;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop16: ; /* Jump out to here if this rule does not match */


            	         MATCHT(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_uvNode873);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleuvNodeEx; /* Prevent compiler warnings */
    ruleuvNodeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end uvNode */

/**
 * $ANTLR start mvNode
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:115:1: mvNode : NODENAME OPENSQUAREBRACKET multiIndices CLOSESQUAREBRACKET ;
 */
static void
mvNode(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:116:2: ( NODENAME OPENSQUAREBRACKET multiIndices CLOSESQUAREBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:116:4: NODENAME OPENSQUAREBRACKET multiIndices CLOSESQUAREBRACKET
        {
             MATCHT(NODENAME, &FOLLOW_NODENAME_in_mvNode886);
            if  (HASEXCEPTION())
            {
                goto rulemvNodeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_mvNode888);
            if  (HASEXCEPTION())
            {
                goto rulemvNodeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_multiIndices_in_mvNode890);
            multiIndices(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemvNodeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_mvNode892);
            if  (HASEXCEPTION())
            {
                goto rulemvNodeEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemvNodeEx; /* Prevent compiler warnings */
    rulemvNodeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end mvNode */

/**
 * $ANTLR start expression
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:119:1: expression : unaryExpression ( ( PLUS | MINUS | MULT | DIV ) expression )? ;
 */
static void
expression(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:120:2: ( unaryExpression ( ( PLUS | MINUS | MULT | DIV ) expression )? )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:120:4: unaryExpression ( ( PLUS | MINUS | MULT | DIV ) expression )?
        {
            FOLLOWPUSH(FOLLOW_unaryExpression_in_expression904);
            unaryExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:120:20: ( ( PLUS | MINUS | MULT | DIV ) expression )?
            {
                int alt18=2;
                switch ( LA(1) )
                {
                    case DIV:
                    case MINUS:
                    case MULT:
                    case PLUS:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:120:21: ( PLUS | MINUS | MULT | DIV ) expression
            	    {
            	        if ( LA(1) == DIV || LA(1) == MINUS || LA(1) == MULT || LA(1) == PLUS )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleexpressionEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_expression_in_expression917);
            	        expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end expression */

/**
 * $ANTLR start unaryExpression
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:123:1: unaryExpression : ( CONSTANTINT | CONSTANTVALUE | uvNode | OPENBRACKET expression CLOSEBRACKET );
 */
static void
unaryExpression(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:124:2: ( CONSTANTINT | CONSTANTVALUE | uvNode | OPENBRACKET expression CLOSEBRACKET )

            ANTLR3_UINT32 alt19;

            alt19=4;

            switch ( LA(1) )
            {
            case CONSTANTINT:
            	{
            		alt19=1;
            	}
                break;
            case CONSTANTVALUE:
            	{
            		alt19=2;
            	}
                break;
            case NODENAME:
            	{
            		alt19=3;
            	}
                break;
            case OPENBRACKET:
            	{
            		alt19=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto ruleunaryExpressionEx;

            }

            switch (alt19)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:124:4: CONSTANTINT
        	    {
        	         MATCHT(CONSTANTINT, &FOLLOW_CONSTANTINT_in_unaryExpression930);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:125:4: CONSTANTVALUE
        	    {
        	         MATCHT(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_unaryExpression937);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:126:4: uvNode
        	    {
        	        FOLLOWPUSH(FOLLOW_uvNode_in_unaryExpression942);
        	        uvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:127:4: OPENBRACKET expression CLOSEBRACKET
        	    {
        	         MATCHT(OPENBRACKET, &FOLLOW_OPENBRACKET_in_unaryExpression948);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_unaryExpression950);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_unaryExpression952);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleunaryExpressionEx; /* Prevent compiler warnings */
    ruleunaryExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end unaryExpression */

/**
 * $ANTLR start multiIndices
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:130:1: multiIndices : multiDimExpression ( COMMA multiDimExpression )* ;
 */
static void
multiIndices(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:131:2: ( multiDimExpression ( COMMA multiDimExpression )* )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:131:4: multiDimExpression ( COMMA multiDimExpression )*
        {
            FOLLOWPUSH(FOLLOW_multiDimExpression_in_multiIndices964);
            multiDimExpression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemultiIndicesEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:131:23: ( COMMA multiDimExpression )*

            for (;;)
            {
                int alt20=2;
                switch ( LA(1) )
                {
                case COMMA:
                	{
                		alt20=1;
                	}
                    break;

                }

                switch (alt20)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:131:24: COMMA multiDimExpression
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_multiIndices967);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultiIndicesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_multiDimExpression_in_multiIndices969);
            	        multiDimExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultiIndicesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultiIndicesEx; /* Prevent compiler warnings */
    rulemultiIndicesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end multiIndices */

/**
 * $ANTLR start multiDimExpression
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:134:1: multiDimExpression : ( ( OPENBRACKET expression COLON )=> OPENBRACKET expression COLON expression CLOSEBRACKET | expression ( COLON expression )? );
 */
static void
multiDimExpression(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:135:2: ( ( OPENBRACKET expression COLON )=> OPENBRACKET expression COLON expression CLOSEBRACKET | expression ( COLON expression )? )

            ANTLR3_UINT32 alt22;

            alt22=2;

            switch ( LA(1) )
            {
            case OPENBRACKET:
            	{
            		{
            		    int LA22_1 = LA(2);
            		    if ( (synpred10_BUGS(ctx)))
            		    {
            		        alt22=1;
            		    }
            		    else if ( (ANTLR3_TRUE))
            		    {
            		        alt22=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 22;
            		        EXCEPTION->state        = 1;


            		        goto rulemultiDimExpressionEx;

            		    }
            		}
            	}
                break;
            case CONSTANTINT:
            case CONSTANTVALUE:
            case NODENAME:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulemultiDimExpressionEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:135:4: ( OPENBRACKET expression COLON )=> OPENBRACKET expression COLON expression CLOSEBRACKET
        	    {
        	         MATCHT(OPENBRACKET, &FOLLOW_OPENBRACKET_in_multiDimExpression993);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_multiDimExpression995);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(COLON, &FOLLOW_COLON_in_multiDimExpression997);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_multiDimExpression999);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	         MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_multiDimExpression1001);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:136:4: expression ( COLON expression )?
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_multiDimExpression1006);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:136:15: ( COLON expression )?
        	        {
        	            int alt21=2;
        	            switch ( LA(1) )
        	            {
        	                case COLON:
        	                	{
        	                		alt21=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt21)
        	            {
        	        	case 1:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:136:16: COLON expression
        	        	    {
        	        	         MATCHT(COLON, &FOLLOW_COLON_in_multiDimExpression1009);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemultiDimExpressionEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_expression_in_multiDimExpression1011);
        	        	        expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemultiDimExpressionEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemultiDimExpressionEx; /* Prevent compiler warnings */
    rulemultiDimExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end multiDimExpression */

/**
 * $ANTLR start startFor
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:139:1: startFor : FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE ;
 */
static void
startFor(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:140:2: ( FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:140:4: FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE
        {
             MATCHT(FORSTART, &FOLLOW_FORSTART_in_startFor1025);
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(OPENBRACKET, &FOLLOW_OPENBRACKET_in_startFor1027);
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_loopVariable_in_startFor1029);
            loopVariable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(IN, &FOLLOW_IN_in_startFor1031);
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_loopBegin_in_startFor1033);
            loopBegin(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COLON, &FOLLOW_COLON_in_startFor1035);
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_loopEnd_in_startFor1037);
            loopEnd(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_startFor1039);
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(OPENBRACE, &FOLLOW_OPENBRACE_in_startFor1041);
            if  (HASEXCEPTION())
            {
                goto rulestartForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestartForEx; /* Prevent compiler warnings */
    rulestartForEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end startFor */

/**
 * $ANTLR start endFor
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:143:1: endFor : CLOSEBRACE ;
 */
static void
endFor(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:144:2: ( CLOSEBRACE )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:144:4: CLOSEBRACE
        {
             MATCHT(CLOSEBRACE, &FOLLOW_CLOSEBRACE_in_endFor1054);
            if  (HASEXCEPTION())
            {
                goto ruleendForEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleendForEx; /* Prevent compiler warnings */
    ruleendForEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end endFor */

/**
 * $ANTLR start loopVariable
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:147:1: loopVariable : NODENAME ;
 */
static void
loopVariable(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:148:2: ( NODENAME )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:148:4: NODENAME
        {
             MATCHT(NODENAME, &FOLLOW_NODENAME_in_loopVariable1066);
            if  (HASEXCEPTION())
            {
                goto ruleloopVariableEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleloopVariableEx; /* Prevent compiler warnings */
    ruleloopVariableEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end loopVariable */

/**
 * $ANTLR start loopBegin
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:151:1: loopBegin : ( uvNode | CONSTANTINT );
 */
static void
loopBegin(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:152:2: ( uvNode | CONSTANTINT )

            ANTLR3_UINT32 alt23;

            alt23=2;

            switch ( LA(1) )
            {
            case NODENAME:
            	{
            		alt23=1;
            	}
                break;
            case CONSTANTINT:
            	{
            		alt23=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 0;


                goto ruleloopBeginEx;

            }

            switch (alt23)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:152:4: uvNode
        	    {
        	        FOLLOWPUSH(FOLLOW_uvNode_in_loopBegin1078);
        	        uvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleloopBeginEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:153:4: CONSTANTINT
        	    {
        	         MATCHT(CONSTANTINT, &FOLLOW_CONSTANTINT_in_loopBegin1084);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleloopBeginEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleloopBeginEx; /* Prevent compiler warnings */
    ruleloopBeginEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end loopBegin */

/**
 * $ANTLR start loopEnd
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:156:1: loopEnd : ( uvNode | CONSTANTINT );
 */
static void
loopEnd(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:157:2: ( uvNode | CONSTANTINT )

            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) )
            {
            case NODENAME:
            	{
            		alt24=1;
            	}
                break;
            case CONSTANTINT:
            	{
            		alt24=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruleloopEndEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:157:4: uvNode
        	    {
        	        FOLLOWPUSH(FOLLOW_uvNode_in_loopEnd1096);
        	        uvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleloopEndEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:158:4: CONSTANTINT
        	    {
        	         MATCHT(CONSTANTINT, &FOLLOW_CONSTANTINT_in_loopEnd1102);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleloopEndEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleloopEndEx; /* Prevent compiler warnings */
    ruleloopEndEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end loopEnd */

/**
 * $ANTLR start scalarFunctions
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:161:1: scalarFunctions : ABSOPENBRACKET exprWithNodesFunctions CLOSEBRACKET ;
 */
static void
scalarFunctions(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:162:2: ( ABSOPENBRACKET exprWithNodesFunctions CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:162:4: ABSOPENBRACKET exprWithNodesFunctions CLOSEBRACKET
        {
             MATCHT(ABSOPENBRACKET, &FOLLOW_ABSOPENBRACKET_in_scalarFunctions1114);
            if  (HASEXCEPTION())
            {
                goto rulescalarFunctionsEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_exprWithNodesFunctions_in_scalarFunctions1116);
            exprWithNodesFunctions(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulescalarFunctionsEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_scalarFunctions1118);
            if  (HASEXCEPTION())
            {
                goto rulescalarFunctionsEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulescalarFunctionsEx; /* Prevent compiler warnings */
    rulescalarFunctionsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end scalarFunctions */

/**
 * $ANTLR start vectorFunctions
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:165:1: vectorFunctions : INVERSEOPENBRACKET mvNode CLOSEBRACKET ;
 */
static void
vectorFunctions(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:166:2: ( INVERSEOPENBRACKET mvNode CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:166:4: INVERSEOPENBRACKET mvNode CLOSEBRACKET
        {
             MATCHT(INVERSEOPENBRACKET, &FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1130);
            if  (HASEXCEPTION())
            {
                goto rulevectorFunctionsEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_mvNode_in_vectorFunctions1132);
            mvNode(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevectorFunctionsEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_vectorFunctions1134);
            if  (HASEXCEPTION())
            {
                goto rulevectorFunctionsEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevectorFunctionsEx; /* Prevent compiler warnings */
    rulevectorFunctionsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end vectorFunctions */

/**
 * $ANTLR start uvDistribution
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:169:1: uvDistribution : ( discreteUnivariate | continuousUnivariate );
 */
static void
uvDistribution(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:170:2: ( discreteUnivariate | continuousUnivariate )

            ANTLR3_UINT32 alt25;

            alt25=2;

            switch ( LA(1) )
            {
            case BERNOULLIOPENBRACKET:
            	{
            		alt25=1;
            	}
                break;
            case BETAOPENBRACKET:
            	{
            		alt25=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 25;
                EXCEPTION->state        = 0;


                goto ruleuvDistributionEx;

            }

            switch (alt25)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:170:4: discreteUnivariate
        	    {
        	        FOLLOWPUSH(FOLLOW_discreteUnivariate_in_uvDistribution1147);
        	        discreteUnivariate(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuvDistributionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:171:4: continuousUnivariate
        	    {
        	        FOLLOWPUSH(FOLLOW_continuousUnivariate_in_uvDistribution1153);
        	        continuousUnivariate(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuvDistributionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleuvDistributionEx; /* Prevent compiler warnings */
    ruleuvDistributionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end uvDistribution */

/**
 * $ANTLR start mvDistribution
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:174:1: mvDistribution : ( discreteMultivariate | continuousMultivariate );
 */
static void
mvDistribution(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:175:2: ( discreteMultivariate | continuousMultivariate )

            ANTLR3_UINT32 alt26;

            alt26=2;

            switch ( LA(1) )
            {
            case MUTLTINOMIALOPENBRACKET:
            	{
            		alt26=1;
            	}
                break;
            case DIRICHLETOPENBRACKET:
            	{
            		alt26=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto rulemvDistributionEx;

            }

            switch (alt26)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:175:4: discreteMultivariate
        	    {
        	        FOLLOWPUSH(FOLLOW_discreteMultivariate_in_mvDistribution1165);
        	        discreteMultivariate(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemvDistributionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:176:4: continuousMultivariate
        	    {
        	        FOLLOWPUSH(FOLLOW_continuousMultivariate_in_mvDistribution1171);
        	        continuousMultivariate(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemvDistributionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemvDistributionEx; /* Prevent compiler warnings */
    rulemvDistributionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end mvDistribution */

/**
 * $ANTLR start discreteUnivariate
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:179:1: discreteUnivariate : bernoulli ;
 */
static void
discreteUnivariate(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:180:2: ( bernoulli )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:180:4: bernoulli
        {
            FOLLOWPUSH(FOLLOW_bernoulli_in_discreteUnivariate1183);
            bernoulli(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulediscreteUnivariateEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulediscreteUnivariateEx; /* Prevent compiler warnings */
    rulediscreteUnivariateEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end discreteUnivariate */

/**
 * $ANTLR start continuousUnivariate
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:183:1: continuousUnivariate : beta ;
 */
static void
continuousUnivariate(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:184:2: ( beta )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:184:4: beta
        {
            FOLLOWPUSH(FOLLOW_beta_in_continuousUnivariate1196);
            beta(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontinuousUnivariateEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecontinuousUnivariateEx; /* Prevent compiler warnings */
    rulecontinuousUnivariateEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end continuousUnivariate */

/**
 * $ANTLR start discreteMultivariate
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:187:1: discreteMultivariate : multinomial ;
 */
static void
discreteMultivariate(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:188:2: ( multinomial )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:188:4: multinomial
        {
            FOLLOWPUSH(FOLLOW_multinomial_in_discreteMultivariate1209);
            multinomial(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulediscreteMultivariateEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulediscreteMultivariateEx; /* Prevent compiler warnings */
    rulediscreteMultivariateEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end discreteMultivariate */

/**
 * $ANTLR start continuousMultivariate
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:191:1: continuousMultivariate : dirichlet ;
 */
static void
continuousMultivariate(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:192:2: ( dirichlet )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:192:4: dirichlet
        {
            FOLLOWPUSH(FOLLOW_dirichlet_in_continuousMultivariate1221);
            dirichlet(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontinuousMultivariateEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecontinuousMultivariateEx; /* Prevent compiler warnings */
    rulecontinuousMultivariateEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end continuousMultivariate */

/**
 * $ANTLR start distributionParameter
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:195:1: distributionParameter : ( uvNode | CONSTANTINT | CONSTANTVALUE );
 */
static void
distributionParameter(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:196:2: ( uvNode | CONSTANTINT | CONSTANTVALUE )

            ANTLR3_UINT32 alt27;

            alt27=3;

            switch ( LA(1) )
            {
            case NODENAME:
            	{
            		alt27=1;
            	}
                break;
            case CONSTANTINT:
            	{
            		alt27=2;
            	}
                break;
            case CONSTANTVALUE:
            	{
            		alt27=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruledistributionParameterEx;

            }

            switch (alt27)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:196:4: uvNode
        	    {
        	        FOLLOWPUSH(FOLLOW_uvNode_in_distributionParameter1234);
        	        uvNode(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledistributionParameterEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:196:13: CONSTANTINT
        	    {
        	         MATCHT(CONSTANTINT, &FOLLOW_CONSTANTINT_in_distributionParameter1238);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledistributionParameterEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:196:27: CONSTANTVALUE
        	    {
        	         MATCHT(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_distributionParameter1242);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledistributionParameterEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledistributionParameterEx; /* Prevent compiler warnings */
    ruledistributionParameterEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end distributionParameter */

/**
 * $ANTLR start bernoulli
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:199:1: bernoulli : BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET ;
 */
static void
bernoulli(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:200:2: ( BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:200:4: BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET
        {
             MATCHT(BERNOULLIOPENBRACKET, &FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1255);
            if  (HASEXCEPTION())
            {
                goto rulebernoulliEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_distributionParameter_in_bernoulli1257);
            distributionParameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebernoulliEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_bernoulli1259);
            if  (HASEXCEPTION())
            {
                goto rulebernoulliEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebernoulliEx; /* Prevent compiler warnings */
    rulebernoulliEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end bernoulli */

/**
 * $ANTLR start beta
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:203:1: beta : BETAOPENBRACKET distributionParameter COMMA distributionParameter CLOSEBRACKET ;
 */
static void
beta(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:204:2: ( BETAOPENBRACKET distributionParameter COMMA distributionParameter CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:204:4: BETAOPENBRACKET distributionParameter COMMA distributionParameter CLOSEBRACKET
        {
             MATCHT(BETAOPENBRACKET, &FOLLOW_BETAOPENBRACKET_in_beta1271);
            if  (HASEXCEPTION())
            {
                goto rulebetaEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_distributionParameter_in_beta1273);
            distributionParameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebetaEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COMMA, &FOLLOW_COMMA_in_beta1275);
            if  (HASEXCEPTION())
            {
                goto rulebetaEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_distributionParameter_in_beta1277);
            distributionParameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebetaEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_beta1279);
            if  (HASEXCEPTION())
            {
                goto rulebetaEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebetaEx; /* Prevent compiler warnings */
    rulebetaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end beta */

/**
 * $ANTLR start multinomial
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:207:1: multinomial : MUTLTINOMIALOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA distributionParameter CLOSEBRACKET ;
 */
static void
multinomial(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:208:2: ( MUTLTINOMIALOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA distributionParameter CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:208:4: MUTLTINOMIALOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA distributionParameter CLOSEBRACKET
        {
             MATCHT(MUTLTINOMIALOPENBRACKET, &FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1291);
            if  (HASEXCEPTION())
            {
                goto rulemultinomialEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_distributionParameter_in_multinomial1293);
            distributionParameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemultinomialEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_multinomial1295);
            if  (HASEXCEPTION())
            {
                goto rulemultinomialEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_multinomial1297);
            if  (HASEXCEPTION())
            {
                goto rulemultinomialEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COMMA, &FOLLOW_COMMA_in_multinomial1299);
            if  (HASEXCEPTION())
            {
                goto rulemultinomialEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_distributionParameter_in_multinomial1303);
            distributionParameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemultinomialEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_multinomial1305);
            if  (HASEXCEPTION())
            {
                goto rulemultinomialEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultinomialEx; /* Prevent compiler warnings */
    rulemultinomialEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end multinomial */

/**
 * $ANTLR start dirichlet
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:212:1: dirichlet : DIRICHLETOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA ;
 */
static void
dirichlet(pBUGSParser ctx)
{
    /* Initialize rule variables
     */

    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:213:2: ( DIRICHLETOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:213:4: DIRICHLETOPENBRACKET distributionParameter OPENSQUAREBRACKET CLOSESQUAREBRACKET COMMA
        {
             MATCHT(DIRICHLETOPENBRACKET, &FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1317);
            if  (HASEXCEPTION())
            {
                goto ruledirichletEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_distributionParameter_in_dirichlet1319);
            distributionParameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledirichletEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_dirichlet1321);
            if  (HASEXCEPTION())
            {
                goto ruledirichletEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_dirichlet1323);
            if  (HASEXCEPTION())
            {
                goto ruledirichletEx;
            }
            if (HASFAILED())
            {
                return ;
            }


             MATCHT(COMMA, &FOLLOW_COMMA_in_dirichlet1325);
            if  (HASEXCEPTION())
            {
                goto ruledirichletEx;
            }
            if (HASFAILED())
            {
                return ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledirichletEx; /* Prevent compiler warnings */
    ruledirichletEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end dirichlet */

// $ANTLR start synpred1_BUGS
static void synpred1_BUGS_fragment(pBUGSParser ctx )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:60:16: ( uvNode TILDE )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:60:17: uvNode TILDE
    {
        FOLLOWPUSH(FOLLOW_uvNode_in_synpred1_BUGS439);
        uvNode(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


         MATCHT(TILDE, &FOLLOW_TILDE_in_synpred1_BUGS441);
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_BUGSEx; /* Prevent compiler warnings */
rulesynpred1_BUGSEx: ;

}
// $ANTLR end synpred1_BUGS

// $ANTLR start synpred2_BUGS
static void synpred2_BUGS_fragment(pBUGSParser ctx )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:61:4: ( mvNode TILDE )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:61:5: mvNode TILDE
    {
        FOLLOWPUSH(FOLLOW_mvNode_in_synpred2_BUGS453);
        mvNode(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


         MATCHT(TILDE, &FOLLOW_TILDE_in_synpred2_BUGS455);
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_BUGSEx; /* Prevent compiler warnings */
rulesynpred2_BUGSEx: ;

}
// $ANTLR end synpred2_BUGS

// $ANTLR start synpred3_BUGS
static void synpred3_BUGS_fragment(pBUGSParser ctx )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:62:4: ( uvNode LEFTPOINTER )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:62:5: uvNode LEFTPOINTER
    {
        FOLLOWPUSH(FOLLOW_uvNode_in_synpred3_BUGS466);
        uvNode(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


         MATCHT(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred3_BUGS468);
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred3_BUGSEx; /* Prevent compiler warnings */
rulesynpred3_BUGSEx: ;

}
// $ANTLR end synpred3_BUGS

// $ANTLR start synpred4_BUGS
static void synpred4_BUGS_fragment(pBUGSParser ctx )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:63:4: ( mvNode LEFTPOINTER )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:63:5: mvNode LEFTPOINTER
    {
        FOLLOWPUSH(FOLLOW_mvNode_in_synpred4_BUGS480);
        mvNode(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


         MATCHT(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred4_BUGS482);
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred4_BUGSEx; /* Prevent compiler warnings */
rulesynpred4_BUGSEx: ;

}
// $ANTLR end synpred4_BUGS

// $ANTLR start synpred5_BUGS
static void synpred5_BUGS_fragment(pBUGSParser ctx )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:64:4: ( linkFunction LEFTPOINTER )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:64:5: linkFunction LEFTPOINTER
    {
        FOLLOWPUSH(FOLLOW_linkFunction_in_synpred5_BUGS494);
        linkFunction(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred5_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


         MATCHT(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred5_BUGS496);
        if  (HASEXCEPTION())
        {
            goto rulesynpred5_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred5_BUGSEx; /* Prevent compiler warnings */
rulesynpred5_BUGSEx: ;

}
// $ANTLR end synpred5_BUGS

// $ANTLR start synpred6_BUGS
static void synpred6_BUGS_fragment(pBUGSParser ctx )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:70:4: ( uvNode )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:70:5: uvNode
    {
        FOLLOWPUSH(FOLLOW_uvNode_in_synpred6_BUGS531);
        uvNode(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred6_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred6_BUGSEx; /* Prevent compiler warnings */
rulesynpred6_BUGSEx: ;

}
// $ANTLR end synpred6_BUGS

// $ANTLR start synpred7_BUGS
static void synpred7_BUGS_fragment(pBUGSParser ctx )
{
    {
        //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:82:43: ( uvNode | CONSTANTVALUE )

        ANTLR3_UINT32 alt28;

        alt28=2;

        switch ( LA(1) )
        {
        case NODENAME:
        	{
        		alt28=1;
        	}
            break;
        case CONSTANTVALUE:
        	{
        		alt28=2;
        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 28;
            EXCEPTION->state        = 0;


            goto rulesynpred7_BUGSEx;

        }

        switch (alt28)
        {
    	case 1:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:82:44: uvNode
    	    {
    	        FOLLOWPUSH(FOLLOW_uvNode_in_synpred7_BUGS601);
    	        uvNode(ctx);

    	        FOLLOWPOP();
    	        if  (HASEXCEPTION())
    	        {
    	            goto rulesynpred7_BUGSEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:82:51: CONSTANTVALUE
    	    {
    	         MATCHT(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_synpred7_BUGS603);
    	        if  (HASEXCEPTION())
    	        {
    	            goto rulesynpred7_BUGSEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred7_BUGSEx; /* Prevent compiler warnings */
rulesynpred7_BUGSEx: ;

}
// $ANTLR end synpred7_BUGS

// $ANTLR start synpred8_BUGS
static void synpred8_BUGS_fragment(pBUGSParser ctx )
{
    {
        //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:23: ( uvNode | CONSTANTVALUE )

        ANTLR3_UINT32 alt29;

        alt29=2;

        switch ( LA(1) )
        {
        case NODENAME:
        	{
        		alt29=1;
        	}
            break;
        case CONSTANTVALUE:
        	{
        		alt29=2;
        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 29;
            EXCEPTION->state        = 0;


            goto rulesynpred8_BUGSEx;

        }

        switch (alt29)
        {
    	case 1:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:24: uvNode
    	    {
    	        FOLLOWPUSH(FOLLOW_uvNode_in_synpred8_BUGS635);
    	        uvNode(ctx);

    	        FOLLOWPOP();
    	        if  (HASEXCEPTION())
    	        {
    	            goto rulesynpred8_BUGSEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:31: CONSTANTVALUE
    	    {
    	         MATCHT(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_synpred8_BUGS637);
    	        if  (HASEXCEPTION())
    	        {
    	            goto rulesynpred8_BUGSEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred8_BUGSEx; /* Prevent compiler warnings */
rulesynpred8_BUGSEx: ;

}
// $ANTLR end synpred8_BUGS

// $ANTLR start synpred9_BUGS
static void synpred9_BUGS_fragment(pBUGSParser ctx )
{
    {
        //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:97:4: ( uvNode | linkFunction )

        ANTLR3_UINT32 alt30;

        alt30=2;

        switch ( LA(1) )
        {
        case NODENAME:
        	{
        		alt30=1;
        	}
            break;
        case CLOGLOGOPENBRACKET:
        case LOGITOPENBRACKET:
        case LOGOPENBRACKET:
        case PROBITOPENBRACKET:
        	{
        		alt30=2;
        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 30;
            EXCEPTION->state        = 0;


            goto rulesynpred9_BUGSEx;

        }

        switch (alt30)
        {
    	case 1:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:97:5: uvNode
    	    {
    	        FOLLOWPUSH(FOLLOW_uvNode_in_synpred9_BUGS718);
    	        uvNode(ctx);

    	        FOLLOWPOP();
    	        if  (HASEXCEPTION())
    	        {
    	            goto rulesynpred9_BUGSEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:97:14: linkFunction
    	    {
    	        FOLLOWPUSH(FOLLOW_linkFunction_in_synpred9_BUGS722);
    	        linkFunction(ctx);

    	        FOLLOWPOP();
    	        if  (HASEXCEPTION())
    	        {
    	            goto rulesynpred9_BUGSEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred9_BUGSEx; /* Prevent compiler warnings */
rulesynpred9_BUGSEx: ;

}
// $ANTLR end synpred9_BUGS

// $ANTLR start synpred10_BUGS
static void synpred10_BUGS_fragment(pBUGSParser ctx )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:135:4: ( OPENBRACKET expression COLON )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:135:5: OPENBRACKET expression COLON
    {
         MATCHT(OPENBRACKET, &FOLLOW_OPENBRACKET_in_synpred10_BUGS984);
        if  (HASEXCEPTION())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        FOLLOWPUSH(FOLLOW_expression_in_synpred10_BUGS986);
        expression(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


         MATCHT(COLON, &FOLLOW_COLON_in_synpred10_BUGS988);
        if  (HASEXCEPTION())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred10_BUGSEx; /* Prevent compiler warnings */
rulesynpred10_BUGSEx: ;

}
// $ANTLR end synpred10_BUGS
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred5_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred5_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred1_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred9_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred9_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred7_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred7_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred2_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred2_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred8_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred8_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred3_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred3_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred10_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred10_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred6_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred6_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred4_BUGS(pBUGSParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred4_BUGS_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
