/** \file
 *  This C++ source file was generated by $ANTLR version 3.5-rc-2
 *
 *     -  From the grammar source file : /u/s/h/shrirams/bugsparser/Parser/BUGS.g
 *     -                            On : 2013-01-15 17:10:47
 *     -                for the parser : BUGSParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "BUGSParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace BUGS {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   BUGSParserTokenNames[37+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ABSOPENBRACKET",
        (ANTLR_UINT8*) "BERNOULLIOPENBRACKET",
        (ANTLR_UINT8*) "BETAOPENBRACKET",
        (ANTLR_UINT8*) "BINOMIALOPENBRACKET",
        (ANTLR_UINT8*) "CENSORBEGINWITHC",
        (ANTLR_UINT8*) "CENSORBEGINWITHI",
        (ANTLR_UINT8*) "CLOGLOGOPENBRACKET",
        (ANTLR_UINT8*) "CLOSEBRACE",
        (ANTLR_UINT8*) "CLOSEBRACKET",
        (ANTLR_UINT8*) "CLOSESQUAREBRACKET",
        (ANTLR_UINT8*) "COLON",
        (ANTLR_UINT8*) "COMMA",
        (ANTLR_UINT8*) "CONSTANTINT",
        (ANTLR_UINT8*) "CONSTANTVALUE",
        (ANTLR_UINT8*) "DIRICHLETOPENBRACKET",
        (ANTLR_UINT8*) "DIV",
        (ANTLR_UINT8*) "DOT",
        (ANTLR_UINT8*) "EQUALTO",
        (ANTLR_UINT8*) "FORSTART",
        (ANTLR_UINT8*) "IN",
        (ANTLR_UINT8*) "INVERSEOPENBRACKET",
        (ANTLR_UINT8*) "LEFTPOINTER",
        (ANTLR_UINT8*) "LOGITOPENBRACKET",
        (ANTLR_UINT8*) "LOGOPENBRACKET",
        (ANTLR_UINT8*) "MINUS",
        (ANTLR_UINT8*) "MODEL",
        (ANTLR_UINT8*) "MULT",
        (ANTLR_UINT8*) "MUTLTINOMIALOPENBRACKET",
        (ANTLR_UINT8*) "NODENAME",
        (ANTLR_UINT8*) "OPENBRACE",
        (ANTLR_UINT8*) "OPENBRACKET",
        (ANTLR_UINT8*) "OPENSQUAREBRACKET",
        (ANTLR_UINT8*) "PLUS",
        (ANTLR_UINT8*) "PROBITOPENBRACKET",
        (ANTLR_UINT8*) "TILDE",
        (ANTLR_UINT8*) "TRUNCATIONBEGIN",
        (ANTLR_UINT8*) "WHITESPACE"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/u/s/h/shrirams/bugsparser/Parser/BUGS.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* BUGSParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new BUGSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
BUGSParser::BUGSParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new BUGSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
BUGSParser::BUGSParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void BUGSParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( BUGSParserTokenNames );


}

void
BUGSParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
BUGSParser::~BUGSParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return BUGSParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MODEL_in_prog335_bits[]	= { ANTLR_UINT64_LIT(0x0000000200000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MODEL_in_prog335( FOLLOW_MODEL_in_prog335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACE_in_prog337_bits[]	= { ANTLR_UINT64_LIT(0x000000210C400400) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACE_in_prog337( FOLLOW_OPENBRACE_in_prog337_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_statements_in_prog339_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_statements_in_prog339( FOLLOW_statements_in_prog339_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACE_in_prog341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACE_in_prog341( FOLLOW_CLOSEBRACE_in_prog341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_stochasticNodeExpr_in_statements370_bits[]	= { ANTLR_UINT64_LIT(0x000000210C400402) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_stochasticNodeExpr_in_statements370( FOLLOW_stochasticNodeExpr_in_statements370_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_stochasticNodeExpr_in_statements387_bits[]	= { ANTLR_UINT64_LIT(0x000000210C400402) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_stochasticNodeExpr_in_statements387( FOLLOW_stochasticNodeExpr_in_statements387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_logicalNodeExpr_in_statements404_bits[]	= { ANTLR_UINT64_LIT(0x000000210C400402) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_logicalNodeExpr_in_statements404( FOLLOW_logicalNodeExpr_in_statements404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_logicalNodeExpr_in_statements421_bits[]	= { ANTLR_UINT64_LIT(0x000000210C400402) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_logicalNodeExpr_in_statements421( FOLLOW_logicalNodeExpr_in_statements421_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_logicalNodeExpr_in_statements439_bits[]	= { ANTLR_UINT64_LIT(0x000000210C400402) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_logicalNodeExpr_in_statements439( FOLLOW_logicalNodeExpr_in_statements439_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_startFor_in_statements449_bits[]	= { ANTLR_UINT64_LIT(0x000000210C400400) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_startFor_in_statements449( FOLLOW_startFor_in_statements449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_statements_in_statements453_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_statements_in_statements453( FOLLOW_statements_in_statements453_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_endFor_in_statements455_bits[]	= { ANTLR_UINT64_LIT(0x000000210C400402) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_endFor_in_statements455( FOLLOW_endFor_in_statements455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr485_bits[]	= { ANTLR_UINT64_LIT(0x0000008000000302) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr485( FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr485_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_censor_in_stochasticNodeExpr494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_censor_in_stochasticNodeExpr494( FOLLOW_censor_in_stochasticNodeExpr494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_truncation_in_stochasticNodeExpr502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_truncation_in_stochasticNodeExpr502( FOLLOW_truncation_in_stochasticNodeExpr502_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr514_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr514( FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr514_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_uvStochasticNodeExpr532_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_uvStochasticNodeExpr532( FOLLOW_uvNode_in_uvStochasticNodeExpr532_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TILDE_in_uvStochasticNodeExpr538_bits[]	= { ANTLR_UINT64_LIT(0x00000000000000E0) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TILDE_in_uvStochasticNodeExpr538( FOLLOW_TILDE_in_uvStochasticNodeExpr538_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvDistribution_in_uvStochasticNodeExpr542_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvDistribution_in_uvStochasticNodeExpr542( FOLLOW_uvDistribution_in_uvStochasticNodeExpr542_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_mvStochasticNodeExpr557_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_mvStochasticNodeExpr557( FOLLOW_mvNode_in_mvStochasticNodeExpr557_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TILDE_in_mvStochasticNodeExpr563_bits[]	= { ANTLR_UINT64_LIT(0x0000000080040000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TILDE_in_mvStochasticNodeExpr563( FOLLOW_TILDE_in_mvStochasticNodeExpr563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvDistribution_in_mvStochasticNodeExpr567_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvDistribution_in_mvStochasticNodeExpr567( FOLLOW_mvDistribution_in_mvStochasticNodeExpr567_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_set_in_censor586_bits[]	= { ANTLR_UINT64_LIT(0x0000000100038000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_set_in_censor586( FOLLOW_set_in_censor586_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_lowerWithOptionalUpper_in_censor609_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_lowerWithOptionalUpper_in_censor609( FOLLOW_lowerWithOptionalUpper_in_censor609_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_upperWithOptionalLower_in_censor623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_upperWithOptionalLower_in_censor623( FOLLOW_upperWithOptionalLower_in_censor623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_censor632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_censor632( FOLLOW_CLOSEBRACKET_in_censor632_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TRUNCATIONBEGIN_in_truncation647_bits[]	= { ANTLR_UINT64_LIT(0x0000000100038000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TRUNCATIONBEGIN_in_truncation647( FOLLOW_TRUNCATIONBEGIN_in_truncation647_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_lowerWithOptionalUpper_in_truncation664_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_lowerWithOptionalUpper_in_truncation664( FOLLOW_lowerWithOptionalUpper_in_truncation664_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_upperWithOptionalLower_in_truncation677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_upperWithOptionalLower_in_truncation677( FOLLOW_upperWithOptionalLower_in_truncation677_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_truncation686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_truncation686( FOLLOW_CLOSEBRACKET_in_truncation686_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_lowerWithOptionalUpper705_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_lowerWithOptionalUpper705( FOLLOW_distributionParameter_in_lowerWithOptionalUpper705_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_lowerWithOptionalUpper712_bits[]	= { ANTLR_UINT64_LIT(0x0000000100030002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_lowerWithOptionalUpper712( FOLLOW_COMMA_in_lowerWithOptionalUpper712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_lowerWithOptionalUpper721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_lowerWithOptionalUpper721( FOLLOW_distributionParameter_in_lowerWithOptionalUpper721_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_upperWithOptionalLower744_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_upperWithOptionalLower744( FOLLOW_distributionParameter_in_upperWithOptionalLower744_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_upperWithOptionalLower752_bits[]	= { ANTLR_UINT64_LIT(0x0000000100030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_upperWithOptionalLower752( FOLLOW_COMMA_in_upperWithOptionalLower752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_upperWithOptionalLower759_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_upperWithOptionalLower759( FOLLOW_distributionParameter_in_upperWithOptionalLower759_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_logicalNodeExpr790_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_logicalNodeExpr790( FOLLOW_uvNode_in_logicalNodeExpr790_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_linkFunction_in_logicalNodeExpr797_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_linkFunction_in_logicalNodeExpr797( FOLLOW_linkFunction_in_logicalNodeExpr797_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_logicalNodeExpr804_bits[]	= { ANTLR_UINT64_LIT(0x0000000501030010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_logicalNodeExpr804( FOLLOW_LEFTPOINTER_in_logicalNodeExpr804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr808_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr808( FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr808_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_logicalNodeExpr816_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_logicalNodeExpr816( FOLLOW_mvNode_in_logicalNodeExpr816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_logicalNodeExpr821_bits[]	= { ANTLR_UINT64_LIT(0x0000000501030010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_logicalNodeExpr821( FOLLOW_LEFTPOINTER_in_logicalNodeExpr821_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr827_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr827( FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr827_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LOGOPENBRACKET_in_linkFunction845_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LOGOPENBRACKET_in_linkFunction845( FOLLOW_LOGOPENBRACKET_in_linkFunction845_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_linkFunction847_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_linkFunction847( FOLLOW_uvNode_in_linkFunction847_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction849_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_linkFunction849( FOLLOW_CLOSEBRACKET_in_linkFunction849_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LOGITOPENBRACKET_in_linkFunction857_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LOGITOPENBRACKET_in_linkFunction857( FOLLOW_LOGITOPENBRACKET_in_linkFunction857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_linkFunction859_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_linkFunction859( FOLLOW_uvNode_in_linkFunction859_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_linkFunction861( FOLLOW_CLOSEBRACKET_in_linkFunction861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction868_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction868( FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction868_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_linkFunction870_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_linkFunction870( FOLLOW_uvNode_in_linkFunction870_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_linkFunction872( FOLLOW_CLOSEBRACKET_in_linkFunction872_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_PROBITOPENBRACKET_in_linkFunction879_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_PROBITOPENBRACKET_in_linkFunction879( FOLLOW_PROBITOPENBRACKET_in_linkFunction879_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_linkFunction881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_linkFunction881( FOLLOW_uvNode_in_linkFunction881_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_linkFunction883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_linkFunction883( FOLLOW_CLOSEBRACKET_in_linkFunction883_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_unaryExpression_in_exprWithNodesFunctions903_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_unaryExpression_in_exprWithNodesFunctions903( FOLLOW_unaryExpression_in_exprWithNodesFunctions903_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_exprWithNodesFunctions910_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_exprWithNodesFunctions910( FOLLOW_uvNode_in_exprWithNodesFunctions910_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_exprWithNodesFunctions917_bits[]	= { ANTLR_UINT64_LIT(0x0000000010000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_exprWithNodesFunctions917( FOLLOW_OPENBRACKET_in_exprWithNodesFunctions917_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MINUS_in_exprWithNodesFunctions919_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MINUS_in_exprWithNodesFunctions919( FOLLOW_MINUS_in_exprWithNodesFunctions919_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_unaryExpression_in_exprWithNodesFunctions923_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_unaryExpression_in_exprWithNodesFunctions923( FOLLOW_unaryExpression_in_exprWithNodesFunctions923_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions926_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions926( FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions926_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_scalarFunctions_in_exprWithNodesFunctions933_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_scalarFunctions_in_exprWithNodesFunctions933( FOLLOW_scalarFunctions_in_exprWithNodesFunctions933_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_vectorFunctions_in_exprWithNodesFunctions940_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_vectorFunctions_in_exprWithNodesFunctions940( FOLLOW_vectorFunctions_in_exprWithNodesFunctions940_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_exprWithNodesFunctions947_bits[]	= { ANTLR_UINT64_LIT(0x0000000501030010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_exprWithNodesFunctions947( FOLLOW_OPENBRACKET_in_exprWithNodesFunctions947_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions951_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions951( FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions951_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions953_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions953( FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions953_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_PLUS_in_exprWithNodesFunctions961_bits[]	= { ANTLR_UINT64_LIT(0x0000000501030010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_PLUS_in_exprWithNodesFunctions961( FOLLOW_PLUS_in_exprWithNodesFunctions961_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MINUS_in_exprWithNodesFunctions968_bits[]	= { ANTLR_UINT64_LIT(0x0000000501030010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MINUS_in_exprWithNodesFunctions968( FOLLOW_MINUS_in_exprWithNodesFunctions968_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MULT_in_exprWithNodesFunctions975_bits[]	= { ANTLR_UINT64_LIT(0x0000000501030010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MULT_in_exprWithNodesFunctions975( FOLLOW_MULT_in_exprWithNodesFunctions975_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_DIV_in_exprWithNodesFunctions981_bits[]	= { ANTLR_UINT64_LIT(0x0000000501030010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_DIV_in_exprWithNodesFunctions981( FOLLOW_DIV_in_exprWithNodesFunctions981_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions990( FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_uvNode1009_bits[]	= { ANTLR_UINT64_LIT(0x0000000800000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_NODENAME_in_uvNode1009( FOLLOW_NODENAME_in_uvNode1009_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENSQUAREBRACKET_in_uvNode1017_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENSQUAREBRACKET_in_uvNode1017( FOLLOW_OPENSQUAREBRACKET_in_uvNode1017_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_uvNode1021_bits[]	= { ANTLR_UINT64_LIT(0x000000000000A000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_uvNode1021( FOLLOW_expression_in_uvNode1021_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_uvNode1030_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_uvNode1030( FOLLOW_COMMA_in_uvNode1030_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_uvNode1034_bits[]	= { ANTLR_UINT64_LIT(0x000000000000A000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_uvNode1034( FOLLOW_expression_in_uvNode1034_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_uvNode1045_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSESQUAREBRACKET_in_uvNode1045( FOLLOW_CLOSESQUAREBRACKET_in_uvNode1045_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_mvNode1064_bits[]	= { ANTLR_UINT64_LIT(0x0000000800000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_NODENAME_in_mvNode1064( FOLLOW_NODENAME_in_mvNode1064_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENSQUAREBRACKET_in_mvNode1066_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENSQUAREBRACKET_in_mvNode1066( FOLLOW_OPENSQUAREBRACKET_in_mvNode1066_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_multiIndices_in_mvNode1070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_multiIndices_in_mvNode1070( FOLLOW_multiIndices_in_mvNode1070_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSESQUAREBRACKET_in_mvNode1072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSESQUAREBRACKET_in_mvNode1072( FOLLOW_CLOSESQUAREBRACKET_in_mvNode1072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_unaryExpression_in_expression1091_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_unaryExpression_in_expression1091( FOLLOW_unaryExpression_in_expression1091_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_expression1099_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_expression1099( FOLLOW_uvNode_in_expression1099_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_expression1106_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_expression1106( FOLLOW_OPENBRACKET_in_expression1106_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression1110_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_expression1110( FOLLOW_expression_in_expression1110_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_expression1112_bits[]	= { ANTLR_UINT64_LIT(0x0000001050080002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_expression1112( FOLLOW_CLOSEBRACKET_in_expression1112_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_PLUS_in_expression1119_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_PLUS_in_expression1119( FOLLOW_PLUS_in_expression1119_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression1123_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_expression1123( FOLLOW_expression_in_expression1123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MINUS_in_expression1129_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MINUS_in_expression1129( FOLLOW_MINUS_in_expression1129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression1133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_expression1133( FOLLOW_expression_in_expression1133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MULT_in_expression1139_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MULT_in_expression1139( FOLLOW_MULT_in_expression1139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression1143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_expression1143( FOLLOW_expression_in_expression1143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_DIV_in_expression1149_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_DIV_in_expression1149( FOLLOW_DIV_in_expression1149_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression1153_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_expression1153( FOLLOW_expression_in_expression1153_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTINT_in_unaryExpression1172_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTINT_in_unaryExpression1172( FOLLOW_CONSTANTINT_in_unaryExpression1172_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_unaryExpression1180_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_unaryExpression1180( FOLLOW_CONSTANTVALUE_in_unaryExpression1180_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_multiDimExpression_in_multiIndices1198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_multiDimExpression_in_multiIndices1198( FOLLOW_multiDimExpression_in_multiIndices1198_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multiIndices1205_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_multiIndices1205( FOLLOW_COMMA_in_multiIndices1205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_multiDimExpression_in_multiIndices1209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_multiDimExpression_in_multiIndices1209( FOLLOW_multiDimExpression_in_multiIndices1209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_multiDimExpression1238_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_multiDimExpression1238( FOLLOW_OPENBRACKET_in_multiDimExpression1238_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_multiDimExpression1242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_multiDimExpression1242( FOLLOW_expression_in_multiDimExpression1242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_multiDimExpression1244_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COLON_in_multiDimExpression1244( FOLLOW_COLON_in_multiDimExpression1244_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_multiDimExpression1248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_multiDimExpression1248( FOLLOW_expression_in_multiDimExpression1248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_multiDimExpression1250_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_multiDimExpression1250( FOLLOW_CLOSEBRACKET_in_multiDimExpression1250_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_multiDimExpression1260_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_multiDimExpression1260( FOLLOW_expression_in_multiDimExpression1260_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_multiDimExpression1266_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COLON_in_multiDimExpression1266( FOLLOW_COLON_in_multiDimExpression1266_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_multiDimExpression1270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_multiDimExpression1270( FOLLOW_expression_in_multiDimExpression1270_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_FORSTART_in_startFor1290_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_FORSTART_in_startFor1290( FOLLOW_FORSTART_in_startFor1290_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_startFor1292_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_startFor1292( FOLLOW_OPENBRACKET_in_startFor1292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_loopVariable_in_startFor1294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_loopVariable_in_startFor1294( FOLLOW_loopVariable_in_startFor1294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_IN_in_startFor1296_bits[]	= { ANTLR_UINT64_LIT(0x0000000100010000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_IN_in_startFor1296( FOLLOW_IN_in_startFor1296_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_loopBegin_in_startFor1298_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_loopBegin_in_startFor1298( FOLLOW_loopBegin_in_startFor1298_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_startFor1300_bits[]	= { ANTLR_UINT64_LIT(0x0000000100010000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COLON_in_startFor1300( FOLLOW_COLON_in_startFor1300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_loopEnd_in_startFor1302_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_loopEnd_in_startFor1302( FOLLOW_loopEnd_in_startFor1302_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_startFor1304_bits[]	= { ANTLR_UINT64_LIT(0x0000000200000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_startFor1304( FOLLOW_CLOSEBRACKET_in_startFor1304_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACE_in_startFor1306_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACE_in_startFor1306( FOLLOW_OPENBRACE_in_startFor1306_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACE_in_endFor1322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACE_in_endFor1322( FOLLOW_CLOSEBRACE_in_endFor1322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_NODENAME_in_loopVariable1334_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_NODENAME_in_loopVariable1334( FOLLOW_NODENAME_in_loopVariable1334_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_loopBegin1350_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_loopBegin1350( FOLLOW_uvNode_in_loopBegin1350_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTINT_in_loopBegin1357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTINT_in_loopBegin1357( FOLLOW_CONSTANTINT_in_loopBegin1357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_loopEnd1375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_loopEnd1375( FOLLOW_uvNode_in_loopEnd1375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTINT_in_loopEnd1383_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTINT_in_loopEnd1383( FOLLOW_CONSTANTINT_in_loopEnd1383_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_ABSOPENBRACKET_in_scalarFunctions1589_bits[]	= { ANTLR_UINT64_LIT(0x0000000501030010) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_ABSOPENBRACKET_in_scalarFunctions1589( FOLLOW_ABSOPENBRACKET_in_scalarFunctions1589_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_exprWithNodesFunctions_in_scalarFunctions1593_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_exprWithNodesFunctions_in_scalarFunctions1593( FOLLOW_exprWithNodesFunctions_in_scalarFunctions1593_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_scalarFunctions1595_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_scalarFunctions1595( FOLLOW_CLOSEBRACKET_in_scalarFunctions1595_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1612_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1612( FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1612_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_vectorFunctions1614_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_vectorFunctions1614( FOLLOW_mvNode_in_vectorFunctions1614_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_vectorFunctions1616_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_vectorFunctions1616( FOLLOW_CLOSEBRACKET_in_vectorFunctions1616_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_discreteUnivariate_in_uvDistribution1634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_discreteUnivariate_in_uvDistribution1634( FOLLOW_discreteUnivariate_in_uvDistribution1634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_continuousUnivariate_in_uvDistribution1641_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_continuousUnivariate_in_uvDistribution1641( FOLLOW_continuousUnivariate_in_uvDistribution1641_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_discreteMultivariate_in_mvDistribution1658_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_discreteMultivariate_in_mvDistribution1658( FOLLOW_discreteMultivariate_in_mvDistribution1658_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_continuousMultivariate_in_mvDistribution1665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_continuousMultivariate_in_mvDistribution1665( FOLLOW_continuousMultivariate_in_mvDistribution1665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_bernoulli_in_discreteUnivariate1682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_bernoulli_in_discreteUnivariate1682( FOLLOW_bernoulli_in_discreteUnivariate1682_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_binomial_in_discreteUnivariate1689_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_binomial_in_discreteUnivariate1689( FOLLOW_binomial_in_discreteUnivariate1689_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_beta_in_continuousUnivariate1706_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_beta_in_continuousUnivariate1706( FOLLOW_beta_in_continuousUnivariate1706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_multinomial_in_discreteMultivariate1723_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_multinomial_in_discreteMultivariate1723( FOLLOW_multinomial_in_discreteMultivariate1723_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_dirichlet_in_continuousMultivariate1740_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_dirichlet_in_continuousMultivariate1740( FOLLOW_dirichlet_in_continuousMultivariate1740_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_distributionParameter1758_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_distributionParameter1758( FOLLOW_uvNode_in_distributionParameter1758_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_unaryExpression_in_distributionParameter1765_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_unaryExpression_in_distributionParameter1765( FOLLOW_unaryExpression_in_distributionParameter1765_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1783_bits[]	= { ANTLR_UINT64_LIT(0x0000000100030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1783( FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1783_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_bernoulli1785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_bernoulli1785( FOLLOW_distributionParameter_in_bernoulli1785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_bernoulli1787_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_bernoulli1787( FOLLOW_CLOSEBRACKET_in_bernoulli1787_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_BINOMIALOPENBRACKET_in_binomial1804_bits[]	= { ANTLR_UINT64_LIT(0x0000000100030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_BINOMIALOPENBRACKET_in_binomial1804( FOLLOW_BINOMIALOPENBRACKET_in_binomial1804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_binomial1808_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_binomial1808( FOLLOW_distributionParameter_in_binomial1808_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_binomial1810_bits[]	= { ANTLR_UINT64_LIT(0x0000000100030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_binomial1810( FOLLOW_COMMA_in_binomial1810_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_binomial1814_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_binomial1814( FOLLOW_distributionParameter_in_binomial1814_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_binomial1816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_binomial1816( FOLLOW_CLOSEBRACKET_in_binomial1816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_BETAOPENBRACKET_in_beta1833_bits[]	= { ANTLR_UINT64_LIT(0x0000000100030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_BETAOPENBRACKET_in_beta1833( FOLLOW_BETAOPENBRACKET_in_beta1833_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_beta1837_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_beta1837( FOLLOW_distributionParameter_in_beta1837_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_beta1840_bits[]	= { ANTLR_UINT64_LIT(0x0000000100030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_beta1840( FOLLOW_COMMA_in_beta1840_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_beta1844_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_beta1844( FOLLOW_distributionParameter_in_beta1844_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_beta1846_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_beta1846( FOLLOW_CLOSEBRACKET_in_beta1846_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1863_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1863( FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1863_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_multinomial1867_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_multinomial1867( FOLLOW_mvNode_in_multinomial1867_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multinomial1869_bits[]	= { ANTLR_UINT64_LIT(0x0000000100030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COMMA_in_multinomial1869( FOLLOW_COMMA_in_multinomial1869_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_distributionParameter_in_multinomial1875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_distributionParameter_in_multinomial1875( FOLLOW_distributionParameter_in_multinomial1875_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_multinomial1877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_multinomial1877( FOLLOW_CLOSEBRACKET_in_multinomial1877_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1895_bits[]	= { ANTLR_UINT64_LIT(0x0000000100000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1895( FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1895_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_dirichlet1899_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_dirichlet1899( FOLLOW_mvNode_in_dirichlet1899_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CLOSEBRACKET_in_dirichlet1901_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CLOSEBRACKET_in_dirichlet1901( FOLLOW_CLOSEBRACKET_in_dirichlet1901_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred1_BUGS361_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred1_BUGS361( FOLLOW_uvNode_in_synpred1_BUGS361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TILDE_in_synpred1_BUGS363_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TILDE_in_synpred1_BUGS363( FOLLOW_TILDE_in_synpred1_BUGS363_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_synpred2_BUGS378_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_synpred2_BUGS378( FOLLOW_mvNode_in_synpred2_BUGS378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_TILDE_in_synpred2_BUGS380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_TILDE_in_synpred2_BUGS380( FOLLOW_TILDE_in_synpred2_BUGS380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred3_BUGS395_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred3_BUGS395( FOLLOW_uvNode_in_synpred3_BUGS395_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_synpred3_BUGS397_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_synpred3_BUGS397( FOLLOW_LEFTPOINTER_in_synpred3_BUGS397_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_mvNode_in_synpred4_BUGS412_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_mvNode_in_synpred4_BUGS412( FOLLOW_mvNode_in_synpred4_BUGS412_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_synpred4_BUGS414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_synpred4_BUGS414( FOLLOW_LEFTPOINTER_in_synpred4_BUGS414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_linkFunction_in_synpred5_BUGS429_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_linkFunction_in_synpred5_BUGS429( FOLLOW_linkFunction_in_synpred5_BUGS429_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_LEFTPOINTER_in_synpred5_BUGS431_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_LEFTPOINTER_in_synpred5_BUGS431( FOLLOW_LEFTPOINTER_in_synpred5_BUGS431_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred6_BUGS478_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred6_BUGS478( FOLLOW_uvNode_in_synpred6_BUGS478_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred7_BUGS598_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred7_BUGS598( FOLLOW_uvNode_in_synpred7_BUGS598_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_synpred7_BUGS600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_synpred7_BUGS600( FOLLOW_CONSTANTVALUE_in_synpred7_BUGS600_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred8_BUGS653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred8_BUGS653( FOLLOW_uvNode_in_synpred8_BUGS653_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_CONSTANTVALUE_in_synpred8_BUGS655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_CONSTANTVALUE_in_synpred8_BUGS655( FOLLOW_CONSTANTVALUE_in_synpred8_BUGS655_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_uvNode_in_synpred9_BUGS778_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_uvNode_in_synpred9_BUGS778( FOLLOW_uvNode_in_synpred9_BUGS778_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_linkFunction_in_synpred9_BUGS782_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_linkFunction_in_synpred9_BUGS782( FOLLOW_linkFunction_in_synpred9_BUGS782_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_OPENBRACKET_in_synpred10_BUGS1229_bits[]	= { ANTLR_UINT64_LIT(0x0000000500030000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_OPENBRACKET_in_synpred10_BUGS1229( FOLLOW_OPENBRACKET_in_synpred10_BUGS1229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred10_BUGS1231_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_expression_in_synpred10_BUGS1231( FOLLOW_expression_in_synpred10_BUGS1231_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: BUGSParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_synpred10_BUGS1233_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  BUGSParserImplTraits::BitsetListType FOLLOW_COLON_in_synpred10_BUGS1233( FOLLOW_COLON_in_synpred10_BUGS1233_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start prog
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:84:1: prog returns [Program program] : MODEL OPENBRACE statements CLOSEBRACE ;
 */
Program
BUGSParser::prog()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    Program program;


    list<IStatement* > statements1;
    typedef	list<IStatement* > RETURN_TYPE_statements1;

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:2: ( MODEL OPENBRACE statements CLOSEBRACE )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:85:4: MODEL OPENBRACE statements CLOSEBRACE
        {
             this->matchToken(MODEL, &FOLLOW_MODEL_in_prog335);
            if  (this->hasException())
            {
                goto ruleprogEx;
            }
            if (this->hasFailed())
            {
                return program;
            }


             this->matchToken(OPENBRACE, &FOLLOW_OPENBRACE_in_prog337);
            if  (this->hasException())
            {
                goto ruleprogEx;
            }
            if (this->hasFailed())
            {
                return program;
            }


            this->followPush(FOLLOW_statements_in_prog339);
            statements1=statements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprogEx;
            }
            if (this->hasFailed())
            {
                return program;
            }


             this->matchToken(CLOSEBRACE, &FOLLOW_CLOSEBRACE_in_prog341);
            if  (this->hasException())
            {
                goto ruleprogEx;
            }
            if (this->hasFailed())
            {
                return program;
            }


            if ( this->get_backtracking()==0 )
            {
                program
                .statements = statements1
                ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return program;
}
/* $ANTLR end prog */

/**
 * $ANTLR start statements
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:88:1: statements returns [list<IStatement* > stat] : ( ( uvNode TILDE )=>ste1= stochasticNodeExpr | ( mvNode TILDE )=>ste2= stochasticNodeExpr | ( uvNode LEFTPOINTER )=>lne1= logicalNodeExpr | ( mvNode LEFTPOINTER )=>lne2= logicalNodeExpr | ( linkFunction LEFTPOINTER )=>lne3= logicalNodeExpr |sf= startFor stats= statements endFor )+ ;
 */
list<IStatement* >
BUGSParser::statements()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    list<IStatement* > stat;


    StochasticNodeStatement* ste1;
    typedef	StochasticNodeStatement* RETURN_TYPE_ste1;

    StochasticNodeStatement* ste2;
    typedef	StochasticNodeStatement* RETURN_TYPE_ste2;

    LogicalNodeStatement* lne1;
    typedef	LogicalNodeStatement* RETURN_TYPE_lne1;

    LogicalNodeStatement* lne2;
    typedef	LogicalNodeStatement* RETURN_TYPE_lne2;

    LogicalNodeStatement* lne3;
    typedef	LogicalNodeStatement* RETURN_TYPE_lne3;

    BUGSParser_startFor_return sf;
    typedef	BUGSParser_startFor_return RETURN_TYPE_sf;

    list<IStatement* > stats;
    typedef	list<IStatement* > RETURN_TYPE_stats;

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:88:45: ( ( ( uvNode TILDE )=>ste1= stochasticNodeExpr | ( mvNode TILDE )=>ste2= stochasticNodeExpr | ( uvNode LEFTPOINTER )=>lne1= logicalNodeExpr | ( mvNode LEFTPOINTER )=>lne2= logicalNodeExpr | ( linkFunction LEFTPOINTER )=>lne3= logicalNodeExpr |sf= startFor stats= statements endFor )+ )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:2: ( ( uvNode TILDE )=>ste1= stochasticNodeExpr | ( mvNode TILDE )=>ste2= stochasticNodeExpr | ( uvNode LEFTPOINTER )=>lne1= logicalNodeExpr | ( mvNode LEFTPOINTER )=>lne2= logicalNodeExpr | ( linkFunction LEFTPOINTER )=>lne3= logicalNodeExpr |sf= startFor stats= statements endFor )+
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:2: ( ( uvNode TILDE )=>ste1= stochasticNodeExpr | ( mvNode TILDE )=>ste2= stochasticNodeExpr | ( uvNode LEFTPOINTER )=>lne1= logicalNodeExpr | ( mvNode LEFTPOINTER )=>lne2= logicalNodeExpr | ( linkFunction LEFTPOINTER )=>lne3= logicalNodeExpr |sf= startFor stats= statements endFor )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=7;
            	switch ( this->LA(1) )
            	{
            	case NODENAME:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA1_2 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_BUGS>() )))
            			    {
            			        alt1=1;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred2_BUGS>() )))
            			    {
            			        alt1=2;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt1=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt1=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt1=5;
            			    }

            			}
            		}
            	    break;
            	case LOGOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA1_3 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt1=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt1=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt1=5;
            			    }

            			}
            		}
            	    break;
            	case LOGITOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA1_4 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt1=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt1=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt1=5;
            			    }

            			}
            		}
            	    break;
            	case CLOGLOGOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA1_5 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt1=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt1=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt1=5;
            			    }

            			}
            		}
            	    break;
            	case PROBITOPENBRACKET:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA1_6 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_BUGS>() )))
            			    {
            			        alt1=3;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_BUGS>() )))
            			    {
            			        alt1=4;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_BUGS>() )))
            			    {
            			        alt1=5;
            			    }

            			}
            		}
            	    break;
            	case FORSTART:
            		{
            			alt1=6;
            		}
            	    break;

            	}

            	switch (alt1)
            	{
            	    case 1:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:3: ( uvNode TILDE )=>ste1= stochasticNodeExpr
            	        {
            	            this->followPush(FOLLOW_stochasticNodeExpr_in_statements370);
            	            ste1=stochasticNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return stat;
            	            }


            	            if ( this->get_backtracking()==0 )
            	            {
            	                stat
            	                .push_back(ste1
            	                );
            	            }


            	        }
            	        break;
            	    case 2:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:90:4: ( mvNode TILDE )=>ste2= stochasticNodeExpr
            	        {
            	            this->followPush(FOLLOW_stochasticNodeExpr_in_statements387);
            	            ste2=stochasticNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return stat;
            	            }


            	            if ( this->get_backtracking()==0 )
            	            {
            	                stat
            	                .push_back(ste2
            	                );
            	            }


            	        }
            	        break;
            	    case 3:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:91:4: ( uvNode LEFTPOINTER )=>lne1= logicalNodeExpr
            	        {
            	            this->followPush(FOLLOW_logicalNodeExpr_in_statements404);
            	            lne1=logicalNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return stat;
            	            }


            	            if ( this->get_backtracking()==0 )
            	            {
            	                stat
            	                .push_back(lne1
            	                );
            	            }


            	        }
            	        break;
            	    case 4:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:92:4: ( mvNode LEFTPOINTER )=>lne2= logicalNodeExpr
            	        {
            	            this->followPush(FOLLOW_logicalNodeExpr_in_statements421);
            	            lne2=logicalNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return stat;
            	            }


            	            if ( this->get_backtracking()==0 )
            	            {
            	                stat
            	                .push_back(lne2
            	                );
            	            }


            	        }
            	        break;
            	    case 5:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:4: ( linkFunction LEFTPOINTER )=>lne3= logicalNodeExpr
            	        {
            	            this->followPush(FOLLOW_logicalNodeExpr_in_statements439);
            	            lne3=logicalNodeExpr();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return stat;
            	            }


            	            if ( this->get_backtracking()==0 )
            	            {
            	                stat
            	                .push_back(lne3
            	                );
            	            }


            	        }
            	        break;
            	    case 6:
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:94:4: sf= startFor stats= statements endFor
            	        {
            	            this->followPush(FOLLOW_startFor_in_statements449);
            	            sf=startFor();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return stat;
            	            }


            	            this->followPush(FOLLOW_statements_in_statements453);
            	            stats=statements();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return stat;
            	            }


            	            this->followPush(FOLLOW_endFor_in_statements455);
            	            endFor();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulestatementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return stat;
            	            }


            	            if ( this->get_backtracking()==0 )
            	            {

            	                	ForStatement* forstat = new ForStatement();
            	                	forstat->loopvariable = sf.loopvariable
            	                ;
            	                	forstat->loopbegin = sf.loopbegin
            	                ;
            	                	forstat->loopend = sf.loopend
            	                ;
            	                	forstat->begintype = sf.begintype
            	                ;
            	                	forstat->endtype=sf.endtype
            	                ;
            	                	forstat->statements = stats
            	                ;
            	                	stat
            	                .push_back(forstat);
            	                	
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return stat;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< BUGSParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulestatementsEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatementsEx; /* Prevent compiler warnings */
    rulestatementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return stat;
}
/* $ANTLR end statements */

/**
 * $ANTLR start stochasticNodeExpr
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:108:1: stochasticNodeExpr returns [StochasticNodeStatement* stochasticNodeStatement = new StochasticNodeStatement()] : ( ( uvNode )=>uvsne= uvStochasticNodeExpr ( censor | truncation )? |mvsne= mvStochasticNodeExpr );
 */
StochasticNodeStatement*
BUGSParser::stochasticNodeExpr()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    StochasticNodeStatement* stochasticNodeStatement;


    BUGSParser_uvStochasticNodeExpr_return uvsne;
    typedef	BUGSParser_uvStochasticNodeExpr_return RETURN_TYPE_uvsne;

    BUGSParser_mvStochasticNodeExpr_return mvsne;
    typedef	BUGSParser_mvStochasticNodeExpr_return RETURN_TYPE_mvsne;

    StochasticNodeLimitation* censor2;
    typedef	StochasticNodeLimitation* RETURN_TYPE_censor2;

    StochasticNodeLimitation* truncation3;
    typedef	StochasticNodeLimitation* RETURN_TYPE_truncation3;

    /* Initialize rule variables
     */
    stochasticNodeStatement =  new StochasticNodeStatement();



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:2: ( ( uvNode )=>uvsne= uvStochasticNodeExpr ( censor | truncation )? |mvsne= mvStochasticNodeExpr )

            ANTLR_UINT32 alt3;

            alt3=2;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		{
            		    int LA3_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred6_BUGS>() )))
            		    {
            		        alt3=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt3=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return stochasticNodeStatement;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 3 );
            		        ex->set_state( 1 );


            		        goto rulestochasticNodeExprEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return stochasticNodeStatement;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto rulestochasticNodeExprEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:4: ( uvNode )=>uvsne= uvStochasticNodeExpr ( censor | truncation )?
        	    {
        	        this->followPush(FOLLOW_uvStochasticNodeExpr_in_stochasticNodeExpr485);
        	        uvsne=uvStochasticNodeExpr();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestochasticNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return stochasticNodeStatement;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            stochasticNodeStatement
        	            ->node = uvsne.uvnode
        	            ; 
        	            	stochasticNodeStatement
        	            ->distribution = uvsne.uvdistribution
        	            ;
        	            	stochasticNodeStatement
        	            ->limitationType=NOLIMITATION;
        	        }


        	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:113:3: ( censor | truncation )?
        	        {
        	            int alt2=3;
        	            switch ( this->LA(1) )
        	            {
        	                case CENSORBEGINWITHC:
        	                case CENSORBEGINWITHI:
        	                	{
        	                		alt2=1;
        	                	}
        	                    break;
        	                case TRUNCATIONBEGIN:
        	                	{
        	                		alt2=2;
        	                	}
        	                    break;
        	            }

        	            switch (alt2)
        	            {
        	        	case 1:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:113:4: censor
        	        	    {
        	        	        this->followPush(FOLLOW_censor_in_stochasticNodeExpr494);
        	        	        censor2=censor();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestochasticNodeExprEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return stochasticNodeStatement;
        	        	        }


        	        	        if ( this->get_backtracking()==0 )
        	        	        {
        	        	            stochasticNodeStatement
        	        	            ->limitationType=CENSOR; stochasticNodeStatement
        	        	            ->limitation=censor2
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:114:5: truncation
        	        	    {
        	        	        this->followPush(FOLLOW_truncation_in_stochasticNodeExpr502);
        	        	        truncation3=truncation();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestochasticNodeExprEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return stochasticNodeStatement;
        	        	        }


        	        	        if ( this->get_backtracking()==0 )
        	        	        {
        	        	            stochasticNodeStatement
        	        	            ->limitationType=TRUNCATION; stochasticNodeStatement
        	        	            ->limitation=truncation3
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:115:4: mvsne= mvStochasticNodeExpr
        	    {
        	        this->followPush(FOLLOW_mvStochasticNodeExpr_in_stochasticNodeExpr514);
        	        mvsne=mvStochasticNodeExpr();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestochasticNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return stochasticNodeStatement;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            stochasticNodeStatement
        	            ->node = mvsne.mvnode
        	            ; stochasticNodeStatement
        	            ->distribution = mvsne.mvdistribution
        	            ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestochasticNodeExprEx; /* Prevent compiler warnings */
    rulestochasticNodeExprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return stochasticNodeStatement;
}
/* $ANTLR end stochasticNodeExpr */

/**
 * $ANTLR start uvStochasticNodeExpr
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:119:1: uvStochasticNodeExpr returns [UnivariateNode* uvnode, UnivariateDistribution* uvdistribution] : uvNode TILDE uvDistribution ;
 */
BUGSParser_uvStochasticNodeExpr_return
BUGSParser::uvStochasticNodeExpr()
{
    BUGSParser_uvStochasticNodeExpr_return retval(this);


    UnivariateNode* uvNode4;
    typedef	UnivariateNode* RETURN_TYPE_uvNode4;

    UnivariateDistribution* uvDistribution5;
    typedef	UnivariateDistribution* RETURN_TYPE_uvDistribution5;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:120:2: ( uvNode TILDE uvDistribution )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:120:3: uvNode TILDE uvDistribution
        {
            this->followPush(FOLLOW_uvNode_in_uvStochasticNodeExpr532);
            uvNode4=uvNode();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            if ( this->get_backtracking()==0 )
            {
                retval.uvnode= 
                uvNode4
                ;

            }


             this->matchToken(TILDE, &FOLLOW_TILDE_in_uvStochasticNodeExpr538);
            if  (this->hasException())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_uvDistribution_in_uvStochasticNodeExpr542);
            uvDistribution5=uvDistribution();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            if ( this->get_backtracking()==0 )
            {
                retval.uvdistribution= 
                uvDistribution5
                ;

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuvStochasticNodeExprEx; /* Prevent compiler warnings */
    ruleuvStochasticNodeExprEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end uvStochasticNodeExpr */

/**
 * $ANTLR start mvStochasticNodeExpr
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:124:1: mvStochasticNodeExpr returns [MultivariateNode* mvnode, MultivariateDistribution* mvdistribution] : mvNode TILDE mvDistribution ;
 */
BUGSParser_mvStochasticNodeExpr_return
BUGSParser::mvStochasticNodeExpr()
{
    BUGSParser_mvStochasticNodeExpr_return retval(this);


    MultivariateNode* mvNode6;
    typedef	MultivariateNode* RETURN_TYPE_mvNode6;

    MultivariateDistribution* mvDistribution7;
    typedef	MultivariateDistribution* RETURN_TYPE_mvDistribution7;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:125:2: ( mvNode TILDE mvDistribution )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:125:3: mvNode TILDE mvDistribution
        {
            this->followPush(FOLLOW_mvNode_in_mvStochasticNodeExpr557);
            mvNode6=mvNode();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            if ( this->get_backtracking()==0 )
            {
                retval.mvnode= 
                mvNode6
                ;

            }


             this->matchToken(TILDE, &FOLLOW_TILDE_in_mvStochasticNodeExpr563);
            if  (this->hasException())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_mvDistribution_in_mvStochasticNodeExpr567);
            mvDistribution7=mvDistribution();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemvStochasticNodeExprEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            if ( this->get_backtracking()==0 )
            {
                retval.mvdistribution= 
                mvDistribution7
                ;

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemvStochasticNodeExprEx; /* Prevent compiler warnings */
    rulemvStochasticNodeExprEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end mvStochasticNodeExpr */

/**
 * $ANTLR start censor
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:130:1: censor returns [StochasticNodeLimitation* limitation = new StochasticNodeLimitation()] : ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper |u= upperWithOptionalLower ) CLOSEBRACKET ;
 */
StochasticNodeLimitation*
BUGSParser::censor()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    StochasticNodeLimitation* limitation;


    BUGSParser_lowerWithOptionalUpper_return l;
    typedef	BUGSParser_lowerWithOptionalUpper_return RETURN_TYPE_l;

    BUGSParser_upperWithOptionalLower_return u;
    typedef	BUGSParser_upperWithOptionalLower_return RETURN_TYPE_u;

    /* Initialize rule variables
     */
    limitation =  new StochasticNodeLimitation();



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:131:3: ( ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper |u= upperWithOptionalLower ) CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:131:5: ( CENSORBEGINWITHC | CENSORBEGINWITHI ) ( ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper |u= upperWithOptionalLower ) CLOSEBRACKET
        {
            if ( ((this->LA(1) >= CENSORBEGINWITHC) && (this->LA(1) <= CENSORBEGINWITHI)) )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return limitation;
                }

                new ANTLR_Exception< BUGSParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulecensorEx;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:132:3: ( ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper |u= upperWithOptionalLower )
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case NODENAME:
                	{
                		{
                		    int LA4_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred7_BUGS>() )))
                		    {
                		        alt4=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt4=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return limitation;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 4 );
                		        ex->set_state( 1 );


                		        goto rulecensorEx;

                		    }
                		}
                	}
                    break;
                case CONSTANTINT:
                	{
                		{
                		    int LA4_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred7_BUGS>() )))
                		    {
                		        alt4=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt4=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return limitation;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 4 );
                		        ex->set_state( 2 );


                		        goto rulecensorEx;

                		    }
                		}
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		{
                		    int LA4_3 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred7_BUGS>() )))
                		    {
                		        alt4=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt4=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return limitation;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 4 );
                		        ex->set_state( 3 );


                		        goto rulecensorEx;

                		    }
                		}
                	}
                    break;
                case COMMA:
                	{
                		alt4=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return limitation;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 4 );
                    ex->set_state( 0 );


                    goto rulecensorEx;

                }

                switch (alt4)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:132:5: ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper
            	    {
            	        this->followPush(FOLLOW_lowerWithOptionalUpper_in_censor609);
            	        l=lowerWithOptionalUpper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecensorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return limitation;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            limitation
            	            ->optional=l.optional
            	            ; 
            	            	 limitation
            	            ->lowerlimit=l.lowerlimit
            	            ;
            	            	 limitation
            	            ->upperlimit=l.upperlimit
            	            ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:137:5: u= upperWithOptionalLower
            	    {
            	        this->followPush(FOLLOW_upperWithOptionalLower_in_censor623);
            	        u=upperWithOptionalLower();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecensorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return limitation;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            limitation
            	            ->optional=u.optional
            	            ; 
            	            	 limitation
            	            ->lowerlimit=u.lowerlimit
            	            ;
            	            	 limitation
            	            ->upperlimit=u.upperlimit
            	            ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_censor632);
            if  (this->hasException())
            {
                goto rulecensorEx;
            }
            if (this->hasFailed())
            {
                return limitation;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecensorEx; /* Prevent compiler warnings */
    rulecensorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return limitation;
}
/* $ANTLR end censor */

/**
 * $ANTLR start truncation
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:142:1: truncation returns [StochasticNodeLimitation* limitation = new StochasticNodeLimitation()] : TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper |u= upperWithOptionalLower ) CLOSEBRACKET ;
 */
StochasticNodeLimitation*
BUGSParser::truncation()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    StochasticNodeLimitation* limitation;


    BUGSParser_lowerWithOptionalUpper_return l;
    typedef	BUGSParser_lowerWithOptionalUpper_return RETURN_TYPE_l;

    BUGSParser_upperWithOptionalLower_return u;
    typedef	BUGSParser_upperWithOptionalLower_return RETURN_TYPE_u;

    /* Initialize rule variables
     */
    limitation =  new StochasticNodeLimitation();



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:143:2: ( TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper |u= upperWithOptionalLower ) CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:143:4: TRUNCATIONBEGIN ( ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper |u= upperWithOptionalLower ) CLOSEBRACKET
        {
             this->matchToken(TRUNCATIONBEGIN, &FOLLOW_TRUNCATIONBEGIN_in_truncation647);
            if  (this->hasException())
            {
                goto ruletruncationEx;
            }
            if (this->hasFailed())
            {
                return limitation;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:143:20: ( ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper |u= upperWithOptionalLower )
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                case NODENAME:
                	{
                		{
                		    int LA5_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred8_BUGS>() )))
                		    {
                		        alt5=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt5=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return limitation;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 5 );
                		        ex->set_state( 1 );


                		        goto ruletruncationEx;

                		    }
                		}
                	}
                    break;
                case CONSTANTINT:
                	{
                		{
                		    int LA5_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred8_BUGS>() )))
                		    {
                		        alt5=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt5=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return limitation;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 5 );
                		        ex->set_state( 2 );


                		        goto ruletruncationEx;

                		    }
                		}
                	}
                    break;
                case CONSTANTVALUE:
                	{
                		{
                		    int LA5_3 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred8_BUGS>() )))
                		    {
                		        alt5=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt5=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return limitation;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 5 );
                		        ex->set_state( 3 );


                		        goto ruletruncationEx;

                		    }
                		}
                	}
                    break;
                case COMMA:
                	{
                		alt5=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return limitation;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 5 );
                    ex->set_state( 0 );


                    goto ruletruncationEx;

                }

                switch (alt5)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:143:23: ( uvNode | CONSTANTVALUE )=>l= lowerWithOptionalUpper
            	    {
            	        this->followPush(FOLLOW_lowerWithOptionalUpper_in_truncation664);
            	        l=lowerWithOptionalUpper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletruncationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return limitation;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            limitation
            	            ->optional=l.optional
            	            ; 
            	            	 limitation
            	            ->lowerlimit=l.lowerlimit
            	            ;
            	            	 limitation
            	            ->upperlimit=l.upperlimit
            	            ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:148:5: u= upperWithOptionalLower
            	    {
            	        this->followPush(FOLLOW_upperWithOptionalLower_in_truncation677);
            	        u=upperWithOptionalLower();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletruncationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return limitation;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            limitation
            	            ->optional=u.optional
            	            ; 
            	            	 limitation
            	            ->lowerlimit=u.lowerlimit
            	            ;
            	            	 limitation
            	            ->upperlimit=u.upperlimit
            	            ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_truncation686);
            if  (this->hasException())
            {
                goto ruletruncationEx;
            }
            if (this->hasFailed())
            {
                return limitation;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletruncationEx; /* Prevent compiler warnings */
    ruletruncationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return limitation;
}
/* $ANTLR end truncation */

/**
 * $ANTLR start lowerWithOptionalUpper
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:154:1: lowerWithOptionalUpper returns [OptionalComponent optional = UPPER, Expression* lowerlimit, Expression* upperlimit] : (dp1= distributionParameter ) COMMA (dp2= distributionParameter )? ;
 */
BUGSParser_lowerWithOptionalUpper_return
BUGSParser::lowerWithOptionalUpper()
{
    BUGSParser_lowerWithOptionalUpper_return retval(this);


    Expression* dp1;
    typedef	Expression* RETURN_TYPE_dp1;

    Expression* dp2;
    typedef	Expression* RETURN_TYPE_dp2;

    /* Initialize rule variables
     */
    retval.optional =  UPPER;


    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:155:2: ( (dp1= distributionParameter ) COMMA (dp2= distributionParameter )? )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:155:5: (dp1= distributionParameter ) COMMA (dp2= distributionParameter )?
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:155:5: (dp1= distributionParameter )
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:155:6: dp1= distributionParameter
            {
                this->followPush(FOLLOW_distributionParameter_in_lowerWithOptionalUpper705);
                dp1=distributionParameter();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulelowerWithOptionalUpperEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }


                if ( this->get_backtracking()==0 )
                {
                    retval.lowerlimit= 
                    dp1
                    ;

                }


            }


             this->matchToken(COMMA, &FOLLOW_COMMA_in_lowerWithOptionalUpper712);
            if  (this->hasException())
            {
                goto rulelowerWithOptionalUpperEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:157:3: (dp2= distributionParameter )?
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                    case CONSTANTINT:
                    case CONSTANTVALUE:
                    case NODENAME:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:157:5: dp2= distributionParameter
            	    {
            	        this->followPush(FOLLOW_distributionParameter_in_lowerWithOptionalUpper721);
            	        dp2=distributionParameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelowerWithOptionalUpperEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            retval.upperlimit= 
            	            dp2
            	            ;
            	            retval.optional= NOOPTIONAL;

            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulelowerWithOptionalUpperEx; /* Prevent compiler warnings */
    rulelowerWithOptionalUpperEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end lowerWithOptionalUpper */

/**
 * $ANTLR start upperWithOptionalLower
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:160:1: upperWithOptionalLower returns [OptionalComponent optional = LOWER, Expression* lowerlimit, Expression* upperlimit] : (dp1= distributionParameter )? COMMA (dp2= distributionParameter ) ;
 */
BUGSParser_upperWithOptionalLower_return
BUGSParser::upperWithOptionalLower()
{
    BUGSParser_upperWithOptionalLower_return retval(this);


    Expression* dp1;
    typedef	Expression* RETURN_TYPE_dp1;

    Expression* dp2;
    typedef	Expression* RETURN_TYPE_dp2;

    /* Initialize rule variables
     */
    retval.optional =  LOWER;


    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:161:2: ( (dp1= distributionParameter )? COMMA (dp2= distributionParameter ) )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:161:5: (dp1= distributionParameter )? COMMA (dp2= distributionParameter )
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:161:5: (dp1= distributionParameter )?
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                    case CONSTANTINT:
                    case CONSTANTVALUE:
                    case NODENAME:
                    	{
                    		alt7=1;
                    	}
                        break;
                }

                switch (alt7)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:161:6: dp1= distributionParameter
            	    {
            	        this->followPush(FOLLOW_distributionParameter_in_upperWithOptionalLower744);
            	        dp1=distributionParameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupperWithOptionalLowerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            retval.lowerlimit= 
            	            dp1
            	            ;
            	             retval.optional= NOOPTIONAL;

            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(COMMA, &FOLLOW_COMMA_in_upperWithOptionalLower752);
            if  (this->hasException())
            {
                goto ruleupperWithOptionalLowerEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:163:2: (dp2= distributionParameter )
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:163:3: dp2= distributionParameter
            {
                this->followPush(FOLLOW_distributionParameter_in_upperWithOptionalLower759);
                dp2=distributionParameter();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleupperWithOptionalLowerEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }


                if ( this->get_backtracking()==0 )
                {
                    retval.upperlimit= 
                    dp2
                    ;

                }


            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupperWithOptionalLowerEx; /* Prevent compiler warnings */
    ruleupperWithOptionalLowerEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end upperWithOptionalLower */

/**
 * $ANTLR start logicalNodeExpr
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:166:1: logicalNodeExpr returns [LogicalNodeStatement* logicalNodeStatement = new LogicalNodeStatement()] : ( ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER ex1= exprWithNodesFunctions | mvNode LEFTPOINTER ex2= exprWithNodesFunctions );
 */
LogicalNodeStatement*
BUGSParser::logicalNodeExpr()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    LogicalNodeStatement* logicalNodeStatement;


    LogicalNodeExpression* ex1;
    typedef	LogicalNodeExpression* RETURN_TYPE_ex1;

    LogicalNodeExpression* ex2;
    typedef	LogicalNodeExpression* RETURN_TYPE_ex2;

    UnivariateNode* uvNode8;
    typedef	UnivariateNode* RETURN_TYPE_uvNode8;

    LinkFunctionNode* linkFunction9;
    typedef	LinkFunctionNode* RETURN_TYPE_linkFunction9;

    MultivariateNode* mvNode10;
    typedef	MultivariateNode* RETURN_TYPE_mvNode10;

    /* Initialize rule variables
     */
    logicalNodeStatement =  new LogicalNodeStatement();



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:167:2: ( ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER ex1= exprWithNodesFunctions | mvNode LEFTPOINTER ex2= exprWithNodesFunctions )

            ANTLR_UINT32 alt9;

            alt9=2;

            {
                int LA9_0 = this->LA(1);
                if ( (LA9_0 == NODENAME))
                {
                    {
                        int LA9_1 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )))
                        {
                            alt9=1;
                        }
                        else if ( (true))
                        {
                            alt9=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return logicalNodeStatement;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 9 );
                            ex->set_state( 1 );


                            goto rulelogicalNodeExprEx;

                        }
                    }
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )) && (LA9_0 == LOGOPENBRACKET))
                {
                    alt9=1;
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )) && (LA9_0 == LOGITOPENBRACKET))
                {
                    alt9=1;
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )) && (LA9_0 == CLOGLOGOPENBRACKET))
                {
                    alt9=1;
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_BUGS>() )) && (LA9_0 == PROBITOPENBRACKET))
                {
                    alt9=1;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return logicalNodeStatement;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 9 );
                    ex->set_state( 0 );


                    goto rulelogicalNodeExprEx;

                }
            }
            switch (alt9)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:167:4: ( uvNode | linkFunction )=> ( uvNode | linkFunction ) LEFTPOINTER ex1= exprWithNodesFunctions
        	    {
        	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:168:2: ( uvNode | linkFunction )
        	        {
        	            int alt8=2;
        	            switch ( this->LA(1) )
        	            {
        	            case NODENAME:
        	            	{
        	            		alt8=1;
        	            	}
        	                break;
        	            case CLOGLOGOPENBRACKET:
        	            case LOGITOPENBRACKET:
        	            case LOGOPENBRACKET:
        	            case PROBITOPENBRACKET:
        	            	{
        	            		alt8=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return logicalNodeStatement;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 8 );
        	                ex->set_state( 0 );


        	                goto rulelogicalNodeExprEx;

        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:168:3: uvNode
        	        	    {
        	        	        this->followPush(FOLLOW_uvNode_in_logicalNodeExpr790);
        	        	        uvNode8=uvNode();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelogicalNodeExprEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return logicalNodeStatement;
        	        	        }


        	        	        if ( this->get_backtracking()==0 )
        	        	        {
        	        	            logicalNodeStatement
        	        	            ->logicalNode = uvNode8
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:169:4: linkFunction
        	        	    {
        	        	        this->followPush(FOLLOW_linkFunction_in_logicalNodeExpr797);
        	        	        linkFunction9=linkFunction();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelogicalNodeExprEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return logicalNodeStatement;
        	        	        }


        	        	        if ( this->get_backtracking()==0 )
        	        	        {
        	        	            logicalNodeStatement
        	        	            ->logicalNode = linkFunction9
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_logicalNodeExpr804);
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return logicalNodeStatement;
        	        }


        	        this->followPush(FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr808);
        	        ex1=exprWithNodesFunctions();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return logicalNodeStatement;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            logicalNodeStatement
        	            ->logicalnodeexp= ex1
        	            ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:171:5: mvNode LEFTPOINTER ex2= exprWithNodesFunctions
        	    {
        	        this->followPush(FOLLOW_mvNode_in_logicalNodeExpr816);
        	        mvNode10=mvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return logicalNodeStatement;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            logicalNodeStatement
        	            ->logicalNode = mvNode10
        	            ;
        	        }


        	         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_logicalNodeExpr821);
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return logicalNodeStatement;
        	        }


        	        this->followPush(FOLLOW_exprWithNodesFunctions_in_logicalNodeExpr827);
        	        ex2=exprWithNodesFunctions();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelogicalNodeExprEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return logicalNodeStatement;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            logicalNodeStatement
        	            ->logicalnodeexp= ex2
        	            ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelogicalNodeExprEx; /* Prevent compiler warnings */
    rulelogicalNodeExprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return logicalNodeStatement;
}
/* $ANTLR end logicalNodeExpr */

/**
 * $ANTLR start linkFunction
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:176:1: linkFunction returns [LinkFunctionNode* linkfunction = new LinkFunctionNode()] : ( LOGOPENBRACKET uvNode CLOSEBRACKET | LOGITOPENBRACKET uvNode CLOSEBRACKET | CLOGLOGOPENBRACKET uvNode CLOSEBRACKET | PROBITOPENBRACKET uvNode CLOSEBRACKET );
 */
LinkFunctionNode*
BUGSParser::linkFunction()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    LinkFunctionNode* linkfunction;


    UnivariateNode* uvNode11;
    typedef	UnivariateNode* RETURN_TYPE_uvNode11;

    UnivariateNode* uvNode12;
    typedef	UnivariateNode* RETURN_TYPE_uvNode12;

    UnivariateNode* uvNode13;
    typedef	UnivariateNode* RETURN_TYPE_uvNode13;

    UnivariateNode* uvNode14;
    typedef	UnivariateNode* RETURN_TYPE_uvNode14;

    /* Initialize rule variables
     */
    linkfunction =  new LinkFunctionNode();



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:177:2: ( LOGOPENBRACKET uvNode CLOSEBRACKET | LOGITOPENBRACKET uvNode CLOSEBRACKET | CLOGLOGOPENBRACKET uvNode CLOSEBRACKET | PROBITOPENBRACKET uvNode CLOSEBRACKET )

            ANTLR_UINT32 alt10;

            alt10=4;

            switch ( this->LA(1) )
            {
            case LOGOPENBRACKET:
            	{
            		alt10=1;
            	}
                break;
            case LOGITOPENBRACKET:
            	{
            		alt10=2;
            	}
                break;
            case CLOGLOGOPENBRACKET:
            	{
            		alt10=3;
            	}
                break;
            case PROBITOPENBRACKET:
            	{
            		alt10=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return linkfunction;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 10 );
                ex->set_state( 0 );


                goto rulelinkFunctionEx;

            }

            switch (alt10)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:177:4: LOGOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         this->matchToken(LOGOPENBRACKET, &FOLLOW_LOGOPENBRACKET_in_linkFunction845);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	        this->followPush(FOLLOW_uvNode_in_linkFunction847);
        	        uvNode11=uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction849);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            linkfunction
        	            ->linkfunction = "LOG"; linkfunction
        	            ->uvnode=uvNode11
        	            ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:178:4: LOGITOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         this->matchToken(LOGITOPENBRACKET, &FOLLOW_LOGITOPENBRACKET_in_linkFunction857);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	        this->followPush(FOLLOW_uvNode_in_linkFunction859);
        	        uvNode12=uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction861);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            linkfunction
        	            ->linkfunction = "LOGIT"; linkfunction
        	            ->uvnode=uvNode12
        	            ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:179:4: CLOGLOGOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         this->matchToken(CLOGLOGOPENBRACKET, &FOLLOW_CLOGLOGOPENBRACKET_in_linkFunction868);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	        this->followPush(FOLLOW_uvNode_in_linkFunction870);
        	        uvNode13=uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction872);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            linkfunction
        	            ->linkfunction = "CLOGLOG"; linkfunction
        	            ->uvnode=uvNode13
        	            ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:180:4: PROBITOPENBRACKET uvNode CLOSEBRACKET
        	    {
        	         this->matchToken(PROBITOPENBRACKET, &FOLLOW_PROBITOPENBRACKET_in_linkFunction879);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	        this->followPush(FOLLOW_uvNode_in_linkFunction881);
        	        uvNode14=uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_linkFunction883);
        	        if  (this->hasException())
        	        {
        	            goto rulelinkFunctionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return linkfunction;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            linkfunction
        	            ->linkfunction = "PROBIT"; linkfunction
        	            ->uvnode=uvNode14
        	            ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelinkFunctionEx; /* Prevent compiler warnings */
    rulelinkFunctionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return linkfunction;
}
/* $ANTLR end linkFunction */

/**
 * $ANTLR start exprWithNodesFunctions
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:183:1: exprWithNodesFunctions returns [LogicalNodeExpression* exp = new LogicalNodeExpression()] : (ue1= unaryExpression | uvNode | OPENBRACKET MINUS ue2= unaryExpression CLOSEBRACKET | scalarFunctions | vectorFunctions | OPENBRACKET ex1= exprWithNodesFunctions CLOSEBRACKET ) ( ( PLUS | MINUS | MULT | DIV ) ex2= exprWithNodesFunctions )? ;
 */
LogicalNodeExpression*
BUGSParser::exprWithNodesFunctions()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    LogicalNodeExpression* exp;


    float ue1;
    typedef	float RETURN_TYPE_ue1;

    float ue2;
    typedef	float RETURN_TYPE_ue2;

    LogicalNodeExpression* ex1;
    typedef	LogicalNodeExpression* RETURN_TYPE_ex1;

    LogicalNodeExpression* ex2;
    typedef	LogicalNodeExpression* RETURN_TYPE_ex2;

    UnivariateNode* uvNode15;
    typedef	UnivariateNode* RETURN_TYPE_uvNode15;

    ScalarFunction* scalarFunctions16;
    typedef	ScalarFunction* RETURN_TYPE_scalarFunctions16;

    VectorFunction* vectorFunctions17;
    typedef	VectorFunction* RETURN_TYPE_vectorFunctions17;

    /* Initialize rule variables
     */
    exp =  new LogicalNodeExpression();



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:184:2: ( (ue1= unaryExpression | uvNode | OPENBRACKET MINUS ue2= unaryExpression CLOSEBRACKET | scalarFunctions | vectorFunctions | OPENBRACKET ex1= exprWithNodesFunctions CLOSEBRACKET ) ( ( PLUS | MINUS | MULT | DIV ) ex2= exprWithNodesFunctions )? )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:184:4: (ue1= unaryExpression | uvNode | OPENBRACKET MINUS ue2= unaryExpression CLOSEBRACKET | scalarFunctions | vectorFunctions | OPENBRACKET ex1= exprWithNodesFunctions CLOSEBRACKET ) ( ( PLUS | MINUS | MULT | DIV ) ex2= exprWithNodesFunctions )?
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:184:4: (ue1= unaryExpression | uvNode | OPENBRACKET MINUS ue2= unaryExpression CLOSEBRACKET | scalarFunctions | vectorFunctions | OPENBRACKET ex1= exprWithNodesFunctions CLOSEBRACKET )
            {
                int alt11=6;
                switch ( this->LA(1) )
                {
                case CONSTANTINT:
                case CONSTANTVALUE:
                	{
                		alt11=1;
                	}
                    break;
                case NODENAME:
                	{
                		alt11=2;
                	}
                    break;
                case OPENBRACKET:
                	{
                		switch ( this->LA(2) )
                		{
                		case MINUS:
                			{
                				alt11=3;
                			}
                		    break;
                		case ABSOPENBRACKET:
                		case CONSTANTINT:
                		case CONSTANTVALUE:
                		case INVERSEOPENBRACKET:
                		case NODENAME:
                		case OPENBRACKET:
                			{
                				alt11=6;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return exp;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 11 );
                		    ex->set_state( 3 );


                		    goto ruleexprWithNodesFunctionsEx;

                		}

                	}
                    break;
                case ABSOPENBRACKET:
                	{
                		alt11=4;
                	}
                    break;
                case INVERSEOPENBRACKET:
                	{
                		alt11=5;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return exp;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 11 );
                    ex->set_state( 0 );


                    goto ruleexprWithNodesFunctionsEx;

                }

                switch (alt11)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:184:5: ue1= unaryExpression
            	    {
            	        this->followPush(FOLLOW_unaryExpression_in_exprWithNodesFunctions903);
            	        ue1=unaryExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->expvalue = ue1
            	            ; exp
            	            ->type=LCONSTANT;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:185:4: uvNode
            	    {
            	        this->followPush(FOLLOW_uvNode_in_exprWithNodesFunctions910);
            	        uvNode15=uvNode();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->uvnode = uvNode15
            	            ;  exp
            	            ->type=LNODE;
            	        }


            	    }
            	    break;
            	case 3:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:186:4: OPENBRACKET MINUS ue2= unaryExpression CLOSEBRACKET
            	    {
            	         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_exprWithNodesFunctions917);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	         this->matchToken(MINUS, &FOLLOW_MINUS_in_exprWithNodesFunctions919);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        this->followPush(FOLLOW_unaryExpression_in_exprWithNodesFunctions923);
            	        ue2=unaryExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions926);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->expvalue = -ue1
            	            ; exp
            	            ->type=LCONSTANT;
            	        }


            	    }
            	    break;
            	case 4:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:187:4: scalarFunctions
            	    {
            	        this->followPush(FOLLOW_scalarFunctions_in_exprWithNodesFunctions933);
            	        scalarFunctions16=scalarFunctions();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->function = scalarFunctions16
            	            ; exp
            	            ->type=LFUNCTION;
            	        }


            	    }
            	    break;
            	case 5:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:188:4: vectorFunctions
            	    {
            	        this->followPush(FOLLOW_vectorFunctions_in_exprWithNodesFunctions940);
            	        vectorFunctions17=vectorFunctions();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->function = vectorFunctions17
            	            ; exp
            	            ->type=LFUNCTION;
            	        }


            	    }
            	    break;
            	case 6:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:189:4: OPENBRACKET ex1= exprWithNodesFunctions CLOSEBRACKET
            	    {
            	         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_exprWithNodesFunctions947);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        this->followPush(FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions951);
            	        ex1=exprWithNodesFunctions();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_exprWithNodesFunctions953);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->exp = ex1
            	            ; exp
            	            ->type=LEXPRESSION;
            	        }


            	    }
            	    break;

                }
            }

            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:190:2: ( ( PLUS | MINUS | MULT | DIV ) ex2= exprWithNodesFunctions )?
            {
                int alt13=2;
                switch ( this->LA(1) )
                {
                    case DIV:
                    case MINUS:
                    case MULT:
                    case PLUS:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:190:3: ( PLUS | MINUS | MULT | DIV ) ex2= exprWithNodesFunctions
            	    {
            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:190:3: ( PLUS | MINUS | MULT | DIV )
            	        {
            	            int alt12=4;
            	            switch ( this->LA(1) )
            	            {
            	            case PLUS:
            	            	{
            	            		alt12=1;
            	            	}
            	                break;
            	            case MINUS:
            	            	{
            	            		alt12=2;
            	            	}
            	                break;
            	            case MULT:
            	            	{
            	            		alt12=3;
            	            	}
            	                break;
            	            case DIV:
            	            	{
            	            		alt12=4;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return exp;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 12 );
            	                ex->set_state( 0 );


            	                goto ruleexprWithNodesFunctionsEx;

            	            }

            	            switch (alt12)
            	            {
            	        	case 1:
            	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:190:4: PLUS
            	        	    {
            	        	         this->matchToken(PLUS, &FOLLOW_PLUS_in_exprWithNodesFunctions961);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleexprWithNodesFunctionsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return exp;
            	        	        }


            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            exp
            	        	            ->op ='+';
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:191:3: MINUS
            	        	    {
            	        	         this->matchToken(MINUS, &FOLLOW_MINUS_in_exprWithNodesFunctions968);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleexprWithNodesFunctionsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return exp;
            	        	        }


            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            exp
            	        	            ->op ='-';
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:192:4: MULT
            	        	    {
            	        	         this->matchToken(MULT, &FOLLOW_MULT_in_exprWithNodesFunctions975);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleexprWithNodesFunctionsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return exp;
            	        	        }


            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            exp
            	        	            ->op ='*';
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:193:3: DIV
            	        	    {
            	        	         this->matchToken(DIV, &FOLLOW_DIV_in_exprWithNodesFunctions981);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleexprWithNodesFunctionsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return exp;
            	        	        }


            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            exp
            	        	            ->op ='/';
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_exprWithNodesFunctions_in_exprWithNodesFunctions990);
            	        ex2=exprWithNodesFunctions();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprWithNodesFunctionsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->children.push_back(ex2
            	            );
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexprWithNodesFunctionsEx; /* Prevent compiler warnings */
    ruleexprWithNodesFunctionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return exp;
}
/* $ANTLR end exprWithNodesFunctions */

/**
 * $ANTLR start uvNode
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:197:1: uvNode returns [UnivariateNode* uvnode = new UnivariateNode()] : NODENAME ( OPENSQUAREBRACKET exp1= expression ( COMMA exp2= expression )* CLOSESQUAREBRACKET )? ;
 */
UnivariateNode*
BUGSParser::uvNode()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    UnivariateNode* uvnode;


    const CommonTokenType*    NODENAME18;
    Expression* exp1;
    typedef	Expression* RETURN_TYPE_exp1;

    Expression* exp2;
    typedef	Expression* RETURN_TYPE_exp2;

    /* Initialize rule variables
     */
    uvnode =  new UnivariateNode();


    NODENAME18       = NULL;


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:198:2: ( NODENAME ( OPENSQUAREBRACKET exp1= expression ( COMMA exp2= expression )* CLOSESQUAREBRACKET )? )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:198:4: NODENAME ( OPENSQUAREBRACKET exp1= expression ( COMMA exp2= expression )* CLOSESQUAREBRACKET )?
        {
            NODENAME18 =  this->matchToken(NODENAME, &FOLLOW_NODENAME_in_uvNode1009);
            if  (this->hasException())
            {
                goto ruleuvNodeEx;
            }
            if (this->hasFailed())
            {
                return uvnode;
            }


            if ( this->get_backtracking()==0 )
            {
                uvnode
                ->nodeid = (NODENAME18->getText());
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:199:2: ( OPENSQUAREBRACKET exp1= expression ( COMMA exp2= expression )* CLOSESQUAREBRACKET )?
            {
                int alt15=2;
                switch ( this->LA(1) )
                {
                    case OPENSQUAREBRACKET:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:200:2: OPENSQUAREBRACKET exp1= expression ( COMMA exp2= expression )* CLOSESQUAREBRACKET
            	    {
            	         this->matchToken(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_uvNode1017);
            	        if  (this->hasException())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return uvnode;
            	        }


            	        this->followPush(FOLLOW_expression_in_uvNode1021);
            	        exp1=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return uvnode;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            uvnode
            	            ->indices.push_back(exp1
            	            );
            	        }


            	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:201:2: ( COMMA exp2= expression )*

            	        for (;;)
            	        {
            	            int alt14=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt14=1;
            	            	}
            	                break;

            	            }

            	            switch (alt14)
            	            {
            	        	case 1:
            	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:202:2: COMMA exp2= expression
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_uvNode1030);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleuvNodeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return uvnode;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_uvNode1034);
            	        	        exp2=expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleuvNodeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return uvnode;
            	        	        }


            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            uvnode
            	        	            ->indices.push_back(exp2
            	        	            );
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop14;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop14: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_uvNode1045);
            	        if  (this->hasException())
            	        {
            	            goto ruleuvNodeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return uvnode;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuvNodeEx; /* Prevent compiler warnings */
    ruleuvNodeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return uvnode;
}
/* $ANTLR end uvNode */

/**
 * $ANTLR start mvNode
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:207:1: mvNode returns [MultivariateNode* mvnode = new MultivariateNode()] : NODENAME OPENSQUAREBRACKET mi= multiIndices CLOSESQUAREBRACKET ;
 */
MultivariateNode*
BUGSParser::mvNode()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    MultivariateNode* mvnode;


    const CommonTokenType*    NODENAME19;
    vector<MultiDimExpression* > mi;
    typedef	vector<MultiDimExpression* > RETURN_TYPE_mi;

    /* Initialize rule variables
     */
    mvnode =  new MultivariateNode();


    NODENAME19       = NULL;


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:208:2: ( NODENAME OPENSQUAREBRACKET mi= multiIndices CLOSESQUAREBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:208:4: NODENAME OPENSQUAREBRACKET mi= multiIndices CLOSESQUAREBRACKET
        {
            NODENAME19 =  this->matchToken(NODENAME, &FOLLOW_NODENAME_in_mvNode1064);
            if  (this->hasException())
            {
                goto rulemvNodeEx;
            }
            if (this->hasFailed())
            {
                return mvnode;
            }


             this->matchToken(OPENSQUAREBRACKET, &FOLLOW_OPENSQUAREBRACKET_in_mvNode1066);
            if  (this->hasException())
            {
                goto rulemvNodeEx;
            }
            if (this->hasFailed())
            {
                return mvnode;
            }


            this->followPush(FOLLOW_multiIndices_in_mvNode1070);
            mi=multiIndices();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemvNodeEx;
            }
            if (this->hasFailed())
            {
                return mvnode;
            }


             this->matchToken(CLOSESQUAREBRACKET, &FOLLOW_CLOSESQUAREBRACKET_in_mvNode1072);
            if  (this->hasException())
            {
                goto rulemvNodeEx;
            }
            if (this->hasFailed())
            {
                return mvnode;
            }


            if ( this->get_backtracking()==0 )
            {
                mvnode
                ->nodeid = (NODENAME19->getText()); 
                mvnode
                ->indices=mi
                ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemvNodeEx; /* Prevent compiler warnings */
    rulemvNodeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return mvnode;
}
/* $ANTLR end mvNode */

/**
 * $ANTLR start expression
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:212:1: expression returns [Expression* exp = new Expression()] : ( unaryExpression | uvNode | OPENBRACKET e5= expression CLOSEBRACKET ) ( PLUS e1= expression | MINUS e2= expression | MULT e3= expression | DIV e4= expression )? ;
 */
Expression*
BUGSParser::expression()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    Expression* exp;


    Expression* e5;
    typedef	Expression* RETURN_TYPE_e5;

    Expression* e1;
    typedef	Expression* RETURN_TYPE_e1;

    Expression* e2;
    typedef	Expression* RETURN_TYPE_e2;

    Expression* e3;
    typedef	Expression* RETURN_TYPE_e3;

    Expression* e4;
    typedef	Expression* RETURN_TYPE_e4;

    float unaryExpression20;
    typedef	float RETURN_TYPE_unaryExpression20;

    UnivariateNode* uvNode21;
    typedef	UnivariateNode* RETURN_TYPE_uvNode21;

    /* Initialize rule variables
     */
    exp =  new Expression();



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:213:2: ( ( unaryExpression | uvNode | OPENBRACKET e5= expression CLOSEBRACKET ) ( PLUS e1= expression | MINUS e2= expression | MULT e3= expression | DIV e4= expression )? )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:213:4: ( unaryExpression | uvNode | OPENBRACKET e5= expression CLOSEBRACKET ) ( PLUS e1= expression | MINUS e2= expression | MULT e3= expression | DIV e4= expression )?
        {
            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:213:4: ( unaryExpression | uvNode | OPENBRACKET e5= expression CLOSEBRACKET )
            {
                int alt16=3;
                switch ( this->LA(1) )
                {
                case CONSTANTINT:
                case CONSTANTVALUE:
                	{
                		alt16=1;
                	}
                    break;
                case NODENAME:
                	{
                		alt16=2;
                	}
                    break;
                case OPENBRACKET:
                	{
                		alt16=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return exp;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 16 );
                    ex->set_state( 0 );


                    goto ruleexpressionEx;

                }

                switch (alt16)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:213:5: unaryExpression
            	    {
            	        this->followPush(FOLLOW_unaryExpression_in_expression1091);
            	        unaryExpression20=unaryExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->expvalue=unaryExpression20
            	            ; exp
            	            ->type=CONSTANT;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:214:4: uvNode
            	    {
            	        this->followPush(FOLLOW_uvNode_in_expression1099);
            	        uvNode21=uvNode();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->uvnode=uvNode21
            	            ; exp
            	            ->type=NODE;
            	        }


            	    }
            	    break;
            	case 3:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:215:4: OPENBRACKET e5= expression CLOSEBRACKET
            	    {
            	         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_expression1106);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        this->followPush(FOLLOW_expression_in_expression1110);
            	        e5=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_expression1112);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->exp = e5
            	            ; exp
            	            ->type=EXPRESSION;
            	        }


            	    }
            	    break;

                }
            }

            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:216:2: ( PLUS e1= expression | MINUS e2= expression | MULT e3= expression | DIV e4= expression )?
            {
                int alt17=5;
                switch ( this->LA(1) )
                {
                    case PLUS:
                    	{
                    		alt17=1;
                    	}
                        break;
                    case MINUS:
                    	{
                    		alt17=2;
                    	}
                        break;
                    case MULT:
                    	{
                    		alt17=3;
                    	}
                        break;
                    case DIV:
                    	{
                    		alt17=4;
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:216:3: PLUS e1= expression
            	    {
            	         this->matchToken(PLUS, &FOLLOW_PLUS_in_expression1119);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        this->followPush(FOLLOW_expression_in_expression1123);
            	        e1=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->op ='+'; exp
            	            ->children.push_back(e1
            	            );
            	        }


            	    }
            	    break;
            	case 2:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:217:3: MINUS e2= expression
            	    {
            	         this->matchToken(MINUS, &FOLLOW_MINUS_in_expression1129);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        this->followPush(FOLLOW_expression_in_expression1133);
            	        e2=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->op ='-'; exp
            	            ->children.push_back(e2
            	            );
            	        }


            	    }
            	    break;
            	case 3:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:218:3: MULT e3= expression
            	    {
            	         this->matchToken(MULT, &FOLLOW_MULT_in_expression1139);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        this->followPush(FOLLOW_expression_in_expression1143);
            	        e3=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->op ='*'; exp
            	            ->children.push_back(e3
            	            );
            	        }


            	    }
            	    break;
            	case 4:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:219:3: DIV e4= expression
            	    {
            	         this->matchToken(DIV, &FOLLOW_DIV_in_expression1149);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        this->followPush(FOLLOW_expression_in_expression1153);
            	        e4=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return exp;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            exp
            	            ->op ='/'; exp
            	            ->children.push_back(e4
            	            );
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return exp;
}
/* $ANTLR end expression */

/**
 * $ANTLR start unaryExpression
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:222:1: unaryExpression returns [float uexpvalue] : ( CONSTANTINT | CONSTANTVALUE );
 */
float
BUGSParser::unaryExpression()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    float uexpvalue;


    const CommonTokenType*    CONSTANTINT22;
    const CommonTokenType*    CONSTANTVALUE23;

    /* Initialize rule variables
     */

    CONSTANTINT22       = NULL;
    CONSTANTVALUE23       = NULL;


 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:223:2: ( CONSTANTINT | CONSTANTVALUE )

            ANTLR_UINT32 alt18;

            alt18=2;

            switch ( this->LA(1) )
            {
            case CONSTANTINT:
            	{
            		alt18=1;
            	}
                break;
            case CONSTANTVALUE:
            	{
            		alt18=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return uexpvalue;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 18 );
                ex->set_state( 0 );


                goto ruleunaryExpressionEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:223:4: CONSTANTINT
        	    {
        	        CONSTANTINT22 =  this->matchToken(CONSTANTINT, &FOLLOW_CONSTANTINT_in_unaryExpression1172);
        	        if  (this->hasException())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return uexpvalue;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            uexpvalue= ::atoi((CONSTANTINT22->getText()).c_str());

        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:224:4: CONSTANTVALUE
        	    {
        	        CONSTANTVALUE23 =  this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_unaryExpression1180);
        	        if  (this->hasException())
        	        {
        	            goto ruleunaryExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return uexpvalue;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            uexpvalue= ::atof((CONSTANTVALUE23->getText()).c_str());

        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleunaryExpressionEx; /* Prevent compiler warnings */
    ruleunaryExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return uexpvalue;
}
/* $ANTLR end unaryExpression */

/**
 * $ANTLR start multiIndices
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:226:1: multiIndices returns [vector<MultiDimExpression* > indices] : me1= multiDimExpression ( COMMA me2= multiDimExpression )* ;
 */
vector<MultiDimExpression* >
BUGSParser::multiIndices()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    vector<MultiDimExpression* > indices;


    MultiDimExpression* me1;
    typedef	MultiDimExpression* RETURN_TYPE_me1;

    MultiDimExpression* me2;
    typedef	MultiDimExpression* RETURN_TYPE_me2;

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:227:2: (me1= multiDimExpression ( COMMA me2= multiDimExpression )* )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:227:4: me1= multiDimExpression ( COMMA me2= multiDimExpression )*
        {
            this->followPush(FOLLOW_multiDimExpression_in_multiIndices1198);
            me1=multiDimExpression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiIndicesEx;
            }
            if (this->hasFailed())
            {
                return indices;
            }


            if ( this->get_backtracking()==0 )
            {
                indices
                .push_back(me1
                );
            }


            // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:228:3: ( COMMA me2= multiDimExpression )*

            for (;;)
            {
                int alt19=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt19=1;
                	}
                    break;

                }

                switch (alt19)
                {
            	case 1:
            	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:228:4: COMMA me2= multiDimExpression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_multiIndices1205);
            	        if  (this->hasException())
            	        {
            	            goto rulemultiIndicesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return indices;
            	        }


            	        this->followPush(FOLLOW_multiDimExpression_in_multiIndices1209);
            	        me2=multiDimExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiIndicesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return indices;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            indices
            	            .push_back(me2
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiIndicesEx; /* Prevent compiler warnings */
    rulemultiIndicesEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return indices;
}
/* $ANTLR end multiIndices */

/**
 * $ANTLR start multiDimExpression
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:231:1: multiDimExpression returns [MultiDimExpression* exp = new MultiDimExpression()] : ( ( OPENBRACKET expression COLON )=> OPENBRACKET ex1= expression COLON ex2= expression CLOSEBRACKET |ex3= expression ( COLON ex4= expression )? );
 */
MultiDimExpression*
BUGSParser::multiDimExpression()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    MultiDimExpression* exp;


    Expression* ex1;
    typedef	Expression* RETURN_TYPE_ex1;

    Expression* ex2;
    typedef	Expression* RETURN_TYPE_ex2;

    Expression* ex3;
    typedef	Expression* RETURN_TYPE_ex3;

    Expression* ex4;
    typedef	Expression* RETURN_TYPE_ex4;

    /* Initialize rule variables
     */
    exp =  new MultiDimExpression();



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:232:2: ( ( OPENBRACKET expression COLON )=> OPENBRACKET ex1= expression COLON ex2= expression CLOSEBRACKET |ex3= expression ( COLON ex4= expression )? )

            ANTLR_UINT32 alt21;

            alt21=2;

            switch ( this->LA(1) )
            {
            case OPENBRACKET:
            	{
            		{
            		    int LA21_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred10_BUGS>() )))
            		    {
            		        alt21=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt21=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return exp;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 21 );
            		        ex->set_state( 1 );


            		        goto rulemultiDimExpressionEx;

            		    }
            		}
            	}
                break;
            case CONSTANTINT:
            case CONSTANTVALUE:
            case NODENAME:
            	{
            		alt21=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return exp;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 21 );
                ex->set_state( 0 );


                goto rulemultiDimExpressionEx;

            }

            switch (alt21)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:232:4: ( OPENBRACKET expression COLON )=> OPENBRACKET ex1= expression COLON ex2= expression CLOSEBRACKET
        	    {
        	         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_multiDimExpression1238);
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return exp;
        	        }


        	        this->followPush(FOLLOW_expression_in_multiDimExpression1242);
        	        ex1=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return exp;
        	        }


        	         this->matchToken(COLON, &FOLLOW_COLON_in_multiDimExpression1244);
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return exp;
        	        }


        	        this->followPush(FOLLOW_expression_in_multiDimExpression1248);
        	        ex2=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return exp;
        	        }


        	         this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_multiDimExpression1250);
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return exp;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            exp
        	            ->colon=true; exp
        	            ->expbeforecolon=ex1
        	            ; exp
        	            ->expaftercolon=ex2
        	            ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:234:4: ex3= expression ( COLON ex4= expression )?
        	    {
        	        this->followPush(FOLLOW_expression_in_multiDimExpression1260);
        	        ex3=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiDimExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return exp;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            exp
        	            ->colon=false; exp
        	            ->expbeforecolon=ex3
        	            ;
        	        }


        	        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:235:2: ( COLON ex4= expression )?
        	        {
        	            int alt20=2;
        	            switch ( this->LA(1) )
        	            {
        	                case COLON:
        	                	{
        	                		alt20=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt20)
        	            {
        	        	case 1:
        	        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:235:3: COLON ex4= expression
        	        	    {
        	        	         this->matchToken(COLON, &FOLLOW_COLON_in_multiDimExpression1266);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemultiDimExpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return exp;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_in_multiDimExpression1270);
        	        	        ex4=expression();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemultiDimExpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return exp;
        	        	        }


        	        	        if ( this->get_backtracking()==0 )
        	        	        {
        	        	            exp
        	        	            ->colon=true; exp
        	        	            ->expaftercolon=ex4
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulemultiDimExpressionEx; /* Prevent compiler warnings */
    rulemultiDimExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return exp;
}
/* $ANTLR end multiDimExpression */

/**
 * $ANTLR start startFor
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:238:1: startFor returns [string loopvariable, LoopParam loopbegin, LoopParamType begintype, LoopParam loopend, LoopParamType endtype] : FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE ;
 */
BUGSParser_startFor_return
BUGSParser::startFor()
{
    BUGSParser_startFor_return retval(this);


    BUGSParser_loopVariable_return loopVariable24;
    typedef	BUGSParser_loopVariable_return RETURN_TYPE_loopVariable24;

    BUGSParser_loopBegin_return loopBegin25;
    typedef	BUGSParser_loopBegin_return RETURN_TYPE_loopBegin25;

    BUGSParser_loopEnd_return loopEnd26;
    typedef	BUGSParser_loopEnd_return RETURN_TYPE_loopEnd26;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:239:2: ( FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:239:4: FORSTART OPENBRACKET loopVariable IN loopBegin COLON loopEnd CLOSEBRACKET OPENBRACE
        {
             this->matchToken(FORSTART, &FOLLOW_FORSTART_in_startFor1290);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


             this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_startFor1292);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_loopVariable_in_startFor1294);
            loopVariable24=loopVariable();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


             this->matchToken(IN, &FOLLOW_IN_in_startFor1296);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_loopBegin_in_startFor1298);
            loopBegin25=loopBegin();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


             this->matchToken(COLON, &FOLLOW_COLON_in_startFor1300);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_loopEnd_in_startFor1302);
            loopEnd26=loopEnd();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_startFor1304);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


             this->matchToken(OPENBRACE, &FOLLOW_OPENBRACE_in_startFor1306);
            if  (this->hasException())
            {
                goto rulestartForEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            if ( this->get_backtracking()==0 )
            {
                retval.loopvariable= 
                (this->get_strstream()->toStringTT(loopVariable24.start, loopVariable24.stop))
                ;
                 
                	retval.loopbegin= 
                loopBegin25.loopbegin
                ;

                	retval.loopend= 
                loopEnd26.loopend
                ;

                	retval.begintype= 
                loopBegin25.type
                ;

                	retval.endtype= 
                loopEnd26.type
                ;

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestartForEx; /* Prevent compiler warnings */
    rulestartForEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end startFor */

/**
 * $ANTLR start endFor
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:247:1: endFor : CLOSEBRACE ;
 */
void
BUGSParser::endFor()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:248:2: ( CLOSEBRACE )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:248:4: CLOSEBRACE
        {
             this->matchToken(CLOSEBRACE, &FOLLOW_CLOSEBRACE_in_endFor1322);
            if  (this->hasException())
            {
                goto ruleendForEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleendForEx; /* Prevent compiler warnings */
    ruleendForEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end endFor */

/**
 * $ANTLR start loopVariable
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:251:1: loopVariable : NODENAME ;
 */
BUGSParser_loopVariable_return
BUGSParser::loopVariable()
{
    BUGSParser_loopVariable_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:252:2: ( NODENAME )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:252:4: NODENAME
        {
             this->matchToken(NODENAME, &FOLLOW_NODENAME_in_loopVariable1334);
            if  (this->hasException())
            {
                goto ruleloopVariableEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleloopVariableEx; /* Prevent compiler warnings */
    ruleloopVariableEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end loopVariable */

/**
 * $ANTLR start loopBegin
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:255:1: loopBegin returns [LoopParam loopbegin, LoopParamType type] : ( uvNode | CONSTANTINT );
 */
BUGSParser_loopBegin_return
BUGSParser::loopBegin()
{
    BUGSParser_loopBegin_return retval(this);


    const CommonTokenType*    CONSTANTINT28;
    UnivariateNode* uvNode27;
    typedef	UnivariateNode* RETURN_TYPE_uvNode27;

    /* Initialize rule variables
     */

    CONSTANTINT28       = NULL;
    retval.call_start_placeholder(); 



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:256:2: ( uvNode | CONSTANTINT )

            ANTLR_UINT32 alt22;

            alt22=2;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		alt22=1;
            	}
                break;
            case CONSTANTINT:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 22 );
                ex->set_state( 0 );


                goto ruleloopBeginEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:256:4: uvNode
        	    {
        	        this->followPush(FOLLOW_uvNode_in_loopBegin1350);
        	        uvNode27=uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleloopBeginEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            retval.loopbegin
        	            .uvnode = uvNode27
        	            ; retval.type=LOOPNODE;

        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:257:4: CONSTANTINT
        	    {
        	        CONSTANTINT28 =  this->matchToken(CONSTANTINT, &FOLLOW_CONSTANTINT_in_loopBegin1357);
        	        if  (this->hasException())
        	        {
        	            goto ruleloopBeginEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            retval.loopbegin
        	            .constant = ::atoi((CONSTANTINT28->getText()).c_str()); 
        	            retval.type=LOOPINT;

        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleloopBeginEx; /* Prevent compiler warnings */
    ruleloopBeginEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end loopBegin */

/**
 * $ANTLR start loopEnd
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:260:1: loopEnd returns [LoopParam loopend, LoopParamType type] : ( uvNode | CONSTANTINT );
 */
BUGSParser_loopEnd_return
BUGSParser::loopEnd()
{
    BUGSParser_loopEnd_return retval(this);


    const CommonTokenType*    CONSTANTINT30;
    UnivariateNode* uvNode29;
    typedef	UnivariateNode* RETURN_TYPE_uvNode29;

    /* Initialize rule variables
     */

    CONSTANTINT30       = NULL;
    retval.call_start_placeholder(); 



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:261:2: ( uvNode | CONSTANTINT )

            ANTLR_UINT32 alt23;

            alt23=2;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		alt23=1;
            	}
                break;
            case CONSTANTINT:
            	{
            		alt23=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 23 );
                ex->set_state( 0 );


                goto ruleloopEndEx;

            }

            switch (alt23)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:261:4: uvNode
        	    {
        	        this->followPush(FOLLOW_uvNode_in_loopEnd1375);
        	        uvNode29=uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleloopEndEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            retval.loopend
        	            .uvnode = uvNode29
        	            ; retval.type=LOOPNODE;

        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:262:4: CONSTANTINT
        	    {
        	        CONSTANTINT30 =  this->matchToken(CONSTANTINT, &FOLLOW_CONSTANTINT_in_loopEnd1383);
        	        if  (this->hasException())
        	        {
        	            goto ruleloopEndEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            retval.loopend
        	            .constant = ::atoi((CONSTANTINT30->getText()).c_str()); 
        	            retval.type=LOOPINT;

        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleloopEndEx; /* Prevent compiler warnings */
    ruleloopEndEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end loopEnd */

/**
 * $ANTLR start scalarFunctions
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:280:1: scalarFunctions returns [ScalarFunction* function = new ScalarFunction()] : ABSOPENBRACKET ex1= exprWithNodesFunctions CLOSEBRACKET ;
 */
ScalarFunction*
BUGSParser::scalarFunctions()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ScalarFunction* function;


    LogicalNodeExpression* ex1;
    typedef	LogicalNodeExpression* RETURN_TYPE_ex1;

    /* Initialize rule variables
     */
    function =  new ScalarFunction();



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:281:2: ( ABSOPENBRACKET ex1= exprWithNodesFunctions CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:281:4: ABSOPENBRACKET ex1= exprWithNodesFunctions CLOSEBRACKET
        {
             this->matchToken(ABSOPENBRACKET, &FOLLOW_ABSOPENBRACKET_in_scalarFunctions1589);
            if  (this->hasException())
            {
                goto rulescalarFunctionsEx;
            }
            if (this->hasFailed())
            {
                return function;
            }


            this->followPush(FOLLOW_exprWithNodesFunctions_in_scalarFunctions1593);
            ex1=exprWithNodesFunctions();

            this->followPop();
            if  (this->hasException())
            {
                goto rulescalarFunctionsEx;
            }
            if (this->hasFailed())
            {
                return function;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_scalarFunctions1595);
            if  (this->hasException())
            {
                goto rulescalarFunctionsEx;
            }
            if (this->hasFailed())
            {
                return function;
            }


            if ( this->get_backtracking()==0 )
            {
                function
                ->name="ABS"; function
                ->parameter=ex1
                ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulescalarFunctionsEx; /* Prevent compiler warnings */
    rulescalarFunctionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return function;
}
/* $ANTLR end scalarFunctions */

/**
 * $ANTLR start vectorFunctions
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:284:1: vectorFunctions returns [VectorFunction* function = new VectorFunction()] : INVERSEOPENBRACKET mvNode CLOSEBRACKET ;
 */
VectorFunction*
BUGSParser::vectorFunctions()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    VectorFunction* function;


    MultivariateNode* mvNode31;
    typedef	MultivariateNode* RETURN_TYPE_mvNode31;

    /* Initialize rule variables
     */
    function =  new VectorFunction();



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:285:2: ( INVERSEOPENBRACKET mvNode CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:285:4: INVERSEOPENBRACKET mvNode CLOSEBRACKET
        {
             this->matchToken(INVERSEOPENBRACKET, &FOLLOW_INVERSEOPENBRACKET_in_vectorFunctions1612);
            if  (this->hasException())
            {
                goto rulevectorFunctionsEx;
            }
            if (this->hasFailed())
            {
                return function;
            }


            this->followPush(FOLLOW_mvNode_in_vectorFunctions1614);
            mvNode31=mvNode();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevectorFunctionsEx;
            }
            if (this->hasFailed())
            {
                return function;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_vectorFunctions1616);
            if  (this->hasException())
            {
                goto rulevectorFunctionsEx;
            }
            if (this->hasFailed())
            {
                return function;
            }


            if ( this->get_backtracking()==0 )
            {
                function
                ->name="INVERSE"; function
                ->mvnode=mvNode31
                ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevectorFunctionsEx; /* Prevent compiler warnings */
    rulevectorFunctionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return function;
}
/* $ANTLR end vectorFunctions */

/**
 * $ANTLR start uvDistribution
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:288:1: uvDistribution returns [UnivariateDistribution* distribution = new UnivariateDistribution()] : ( discreteUnivariate | continuousUnivariate );
 */
UnivariateDistribution*
BUGSParser::uvDistribution()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    UnivariateDistribution* distribution;


    BUGSParser_discreteUnivariate_return discreteUnivariate32;
    typedef	BUGSParser_discreteUnivariate_return RETURN_TYPE_discreteUnivariate32;

    BUGSParser_continuousUnivariate_return continuousUnivariate33;
    typedef	BUGSParser_continuousUnivariate_return RETURN_TYPE_continuousUnivariate33;

    /* Initialize rule variables
     */
    distribution =  new UnivariateDistribution();



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:289:2: ( discreteUnivariate | continuousUnivariate )

            ANTLR_UINT32 alt24;

            alt24=2;

            switch ( this->LA(1) )
            {
            case BERNOULLIOPENBRACKET:
            case BINOMIALOPENBRACKET:
            	{
            		alt24=1;
            	}
                break;
            case BETAOPENBRACKET:
            	{
            		alt24=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return distribution;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 24 );
                ex->set_state( 0 );


                goto ruleuvDistributionEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:289:4: discreteUnivariate
        	    {
        	        this->followPush(FOLLOW_discreteUnivariate_in_uvDistribution1634);
        	        discreteUnivariate32=discreteUnivariate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleuvDistributionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return distribution;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            distribution
        	            ->name = discreteUnivariate32.name
        	            ; distribution
        	            ->distributionParameters = discreteUnivariate32.parameters
        	            ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:290:4: continuousUnivariate
        	    {
        	        this->followPush(FOLLOW_continuousUnivariate_in_uvDistribution1641);
        	        continuousUnivariate33=continuousUnivariate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleuvDistributionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return distribution;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            distribution
        	            ->name = continuousUnivariate33.name
        	            ; distribution
        	            ->distributionParameters = continuousUnivariate33.parameters
        	            ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleuvDistributionEx; /* Prevent compiler warnings */
    ruleuvDistributionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return distribution;
}
/* $ANTLR end uvDistribution */

/**
 * $ANTLR start mvDistribution
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:293:1: mvDistribution returns [MultivariateDistribution* distribution = new MultivariateDistribution()] : ( discreteMultivariate | continuousMultivariate );
 */
MultivariateDistribution*
BUGSParser::mvDistribution()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    MultivariateDistribution* distribution;


    BUGSParser_discreteMultivariate_return discreteMultivariate34;
    typedef	BUGSParser_discreteMultivariate_return RETURN_TYPE_discreteMultivariate34;

    BUGSParser_continuousMultivariate_return continuousMultivariate35;
    typedef	BUGSParser_continuousMultivariate_return RETURN_TYPE_continuousMultivariate35;

    /* Initialize rule variables
     */
    distribution =  new MultivariateDistribution();



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:294:2: ( discreteMultivariate | continuousMultivariate )

            ANTLR_UINT32 alt25;

            alt25=2;

            switch ( this->LA(1) )
            {
            case MUTLTINOMIALOPENBRACKET:
            	{
            		alt25=1;
            	}
                break;
            case DIRICHLETOPENBRACKET:
            	{
            		alt25=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return distribution;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 25 );
                ex->set_state( 0 );


                goto rulemvDistributionEx;

            }

            switch (alt25)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:294:4: discreteMultivariate
        	    {
        	        this->followPush(FOLLOW_discreteMultivariate_in_mvDistribution1658);
        	        discreteMultivariate34=discreteMultivariate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemvDistributionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return distribution;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            distribution
        	            ->name = discreteMultivariate34.name
        	            ; distribution
        	            ->distributionParameters = discreteMultivariate34.parameters
        	            ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:295:4: continuousMultivariate
        	    {
        	        this->followPush(FOLLOW_continuousMultivariate_in_mvDistribution1665);
        	        continuousMultivariate35=continuousMultivariate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemvDistributionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return distribution;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            distribution
        	            ->name = continuousMultivariate35.name
        	            ; distribution
        	            ->distributionParameters = continuousMultivariate35.parameters
        	            ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulemvDistributionEx; /* Prevent compiler warnings */
    rulemvDistributionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return distribution;
}
/* $ANTLR end mvDistribution */

/**
 * $ANTLR start discreteUnivariate
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:298:1: discreteUnivariate returns [string name, vector<Expression* > parameters] : ( bernoulli | binomial );
 */
BUGSParser_discreteUnivariate_return
BUGSParser::discreteUnivariate()
{
    BUGSParser_discreteUnivariate_return retval(this);


    vector<Expression* > bernoulli36;
    typedef	vector<Expression* > RETURN_TYPE_bernoulli36;

    vector<Expression* > binomial37;
    typedef	vector<Expression* > RETURN_TYPE_binomial37;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:299:2: ( bernoulli | binomial )

            ANTLR_UINT32 alt26;

            alt26=2;

            switch ( this->LA(1) )
            {
            case BERNOULLIOPENBRACKET:
            	{
            		alt26=1;
            	}
                break;
            case BINOMIALOPENBRACKET:
            	{
            		alt26=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 26 );
                ex->set_state( 0 );


                goto rulediscreteUnivariateEx;

            }

            switch (alt26)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:299:4: bernoulli
        	    {
        	        this->followPush(FOLLOW_bernoulli_in_discreteUnivariate1682);
        	        bernoulli36=bernoulli();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulediscreteUnivariateEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            retval.name="BERNOULLI";
        	             retval.parameters=
        	            bernoulli36
        	            ;

        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:300:4: binomial
        	    {
        	        this->followPush(FOLLOW_binomial_in_discreteUnivariate1689);
        	        binomial37=binomial();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulediscreteUnivariateEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            retval.name="BINOMIAL";
        	             retval.parameters=
        	            binomial37
        	            ;

        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulediscreteUnivariateEx; /* Prevent compiler warnings */
    rulediscreteUnivariateEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end discreteUnivariate */

/**
 * $ANTLR start continuousUnivariate
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:303:1: continuousUnivariate returns [std::string name, vector<Expression* > parameters] : beta ;
 */
BUGSParser_continuousUnivariate_return
BUGSParser::continuousUnivariate()
{
    BUGSParser_continuousUnivariate_return retval(this);


    vector<Expression* > beta38;
    typedef	vector<Expression* > RETURN_TYPE_beta38;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:304:2: ( beta )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:304:4: beta
        {
            this->followPush(FOLLOW_beta_in_continuousUnivariate1706);
            beta38=beta();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecontinuousUnivariateEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            if ( this->get_backtracking()==0 )
            {
                retval.name="BETA";
                 retval.parameters=
                beta38
                ;

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontinuousUnivariateEx; /* Prevent compiler warnings */
    rulecontinuousUnivariateEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end continuousUnivariate */

/**
 * $ANTLR start discreteMultivariate
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:307:1: discreteMultivariate returns [string name, vector<MVDParameters* > parameters] : multinomial ;
 */
BUGSParser_discreteMultivariate_return
BUGSParser::discreteMultivariate()
{
    BUGSParser_discreteMultivariate_return retval(this);


    vector<MVDParameters* > multinomial39;
    typedef	vector<MVDParameters* > RETURN_TYPE_multinomial39;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:308:2: ( multinomial )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:308:4: multinomial
        {
            this->followPush(FOLLOW_multinomial_in_discreteMultivariate1723);
            multinomial39=multinomial();

            this->followPop();
            if  (this->hasException())
            {
                goto rulediscreteMultivariateEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            if ( this->get_backtracking()==0 )
            {
                retval.name="MULTINOMIAL";
                 retval.parameters=
                multinomial39
                ;

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulediscreteMultivariateEx; /* Prevent compiler warnings */
    rulediscreteMultivariateEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end discreteMultivariate */

/**
 * $ANTLR start continuousMultivariate
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:311:1: continuousMultivariate returns [string name, vector<MVDParameters* > parameters] : dirichlet ;
 */
BUGSParser_continuousMultivariate_return
BUGSParser::continuousMultivariate()
{
    BUGSParser_continuousMultivariate_return retval(this);


    vector<MVDParameters* > dirichlet40;
    typedef	vector<MVDParameters* > RETURN_TYPE_dirichlet40;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:312:2: ( dirichlet )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:312:4: dirichlet
        {
            this->followPush(FOLLOW_dirichlet_in_continuousMultivariate1740);
            dirichlet40=dirichlet();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecontinuousMultivariateEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            if ( this->get_backtracking()==0 )
            {
                retval.name="DIRICHLET";
                 retval.parameters=
                dirichlet40
                ;

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontinuousMultivariateEx; /* Prevent compiler warnings */
    rulecontinuousMultivariateEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end continuousMultivariate */

/**
 * $ANTLR start distributionParameter
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:315:1: distributionParameter returns [Expression* exp = new Expression()] : ( uvNode | unaryExpression );
 */
Expression*
BUGSParser::distributionParameter()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    Expression* exp;


    UnivariateNode* uvNode41;
    typedef	UnivariateNode* RETURN_TYPE_uvNode41;

    float unaryExpression42;
    typedef	float RETURN_TYPE_unaryExpression42;

    /* Initialize rule variables
     */
    exp =  new Expression();



 
    {
        {
            //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:316:2: ( uvNode | unaryExpression )

            ANTLR_UINT32 alt27;

            alt27=2;

            switch ( this->LA(1) )
            {
            case NODENAME:
            	{
            		alt27=1;
            	}
                break;
            case CONSTANTINT:
            case CONSTANTVALUE:
            	{
            		alt27=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return exp;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 27 );
                ex->set_state( 0 );


                goto ruledistributionParameterEx;

            }

            switch (alt27)
            {
        	case 1:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:316:4: uvNode
        	    {
        	        this->followPush(FOLLOW_uvNode_in_distributionParameter1758);
        	        uvNode41=uvNode();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledistributionParameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return exp;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            exp
        	            ->uvnode=uvNode41
        	            ; exp
        	            ->type=NODE;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:317:4: unaryExpression
        	    {
        	        this->followPush(FOLLOW_unaryExpression_in_distributionParameter1765);
        	        unaryExpression42=unaryExpression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledistributionParameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return exp;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            exp
        	            ->expvalue=unaryExpression42
        	            ; exp
        	            ->type=CONSTANT;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledistributionParameterEx; /* Prevent compiler warnings */
    ruledistributionParameterEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return exp;
}
/* $ANTLR end distributionParameter */

/**
 * $ANTLR start bernoulli
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:320:1: bernoulli returns [vector<Expression* > parameters] : BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET ;
 */
vector<Expression* >
BUGSParser::bernoulli()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    vector<Expression* > parameters;


    Expression* distributionParameter43;
    typedef	Expression* RETURN_TYPE_distributionParameter43;

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:321:2: ( BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:321:4: BERNOULLIOPENBRACKET distributionParameter CLOSEBRACKET
        {
             this->matchToken(BERNOULLIOPENBRACKET, &FOLLOW_BERNOULLIOPENBRACKET_in_bernoulli1783);
            if  (this->hasException())
            {
                goto rulebernoulliEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            this->followPush(FOLLOW_distributionParameter_in_bernoulli1785);
            distributionParameter43=distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebernoulliEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_bernoulli1787);
            if  (this->hasException())
            {
                goto rulebernoulliEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            if ( this->get_backtracking()==0 )
            {
                parameters
                .push_back(distributionParameter43
                );
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebernoulliEx; /* Prevent compiler warnings */
    rulebernoulliEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return parameters;
}
/* $ANTLR end bernoulli */

/**
 * $ANTLR start binomial
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:324:1: binomial returns [vector<Expression* > parameters] : BINOMIALOPENBRACKET dp1= distributionParameter COMMA dp2= distributionParameter CLOSEBRACKET ;
 */
vector<Expression* >
BUGSParser::binomial()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    vector<Expression* > parameters;


    Expression* dp1;
    typedef	Expression* RETURN_TYPE_dp1;

    Expression* dp2;
    typedef	Expression* RETURN_TYPE_dp2;

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:325:2: ( BINOMIALOPENBRACKET dp1= distributionParameter COMMA dp2= distributionParameter CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:325:4: BINOMIALOPENBRACKET dp1= distributionParameter COMMA dp2= distributionParameter CLOSEBRACKET
        {
             this->matchToken(BINOMIALOPENBRACKET, &FOLLOW_BINOMIALOPENBRACKET_in_binomial1804);
            if  (this->hasException())
            {
                goto rulebinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            this->followPush(FOLLOW_distributionParameter_in_binomial1808);
            dp1=distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


             this->matchToken(COMMA, &FOLLOW_COMMA_in_binomial1810);
            if  (this->hasException())
            {
                goto rulebinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            this->followPush(FOLLOW_distributionParameter_in_binomial1814);
            dp2=distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_binomial1816);
            if  (this->hasException())
            {
                goto rulebinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            if ( this->get_backtracking()==0 )
            {
                parameters
                .push_back(dp1
                ); parameters
                .push_back(dp2
                );
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinomialEx; /* Prevent compiler warnings */
    rulebinomialEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return parameters;
}
/* $ANTLR end binomial */

/**
 * $ANTLR start beta
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:328:1: beta returns [vector<Expression* > parameters] : BETAOPENBRACKET dp1= distributionParameter COMMA dp2= distributionParameter CLOSEBRACKET ;
 */
vector<Expression* >
BUGSParser::beta()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    vector<Expression* > parameters;


    Expression* dp1;
    typedef	Expression* RETURN_TYPE_dp1;

    Expression* dp2;
    typedef	Expression* RETURN_TYPE_dp2;

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:329:2: ( BETAOPENBRACKET dp1= distributionParameter COMMA dp2= distributionParameter CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:329:4: BETAOPENBRACKET dp1= distributionParameter COMMA dp2= distributionParameter CLOSEBRACKET
        {
             this->matchToken(BETAOPENBRACKET, &FOLLOW_BETAOPENBRACKET_in_beta1833);
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            this->followPush(FOLLOW_distributionParameter_in_beta1837);
            dp1=distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


             this->matchToken(COMMA, &FOLLOW_COMMA_in_beta1840);
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            this->followPush(FOLLOW_distributionParameter_in_beta1844);
            dp2=distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_beta1846);
            if  (this->hasException())
            {
                goto rulebetaEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            if ( this->get_backtracking()==0 )
            {
                parameters
                .push_back(dp1
                ); parameters
                .push_back(dp2
                );
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebetaEx; /* Prevent compiler warnings */
    rulebetaEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return parameters;
}
/* $ANTLR end beta */

/**
 * $ANTLR start multinomial
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:332:1: multinomial returns [vector<MVDParameters* > parameters] : MUTLTINOMIALOPENBRACKET dp1= mvNode COMMA dp2= distributionParameter CLOSEBRACKET ;
 */
vector<MVDParameters* >
BUGSParser::multinomial()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    vector<MVDParameters* > parameters;


    MultivariateNode* dp1;
    typedef	MultivariateNode* RETURN_TYPE_dp1;

    Expression* dp2;
    typedef	Expression* RETURN_TYPE_dp2;

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:333:2: ( MUTLTINOMIALOPENBRACKET dp1= mvNode COMMA dp2= distributionParameter CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:333:4: MUTLTINOMIALOPENBRACKET dp1= mvNode COMMA dp2= distributionParameter CLOSEBRACKET
        {
             this->matchToken(MUTLTINOMIALOPENBRACKET, &FOLLOW_MUTLTINOMIALOPENBRACKET_in_multinomial1863);
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            this->followPush(FOLLOW_mvNode_in_multinomial1867);
            dp1=mvNode();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


             this->matchToken(COMMA, &FOLLOW_COMMA_in_multinomial1869);
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            this->followPush(FOLLOW_distributionParameter_in_multinomial1875);
            dp2=distributionParameter();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_multinomial1877);
            if  (this->hasException())
            {
                goto rulemultinomialEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            if ( this->get_backtracking()==0 )
            {
                MVDParameters* param1 = new MVDParameters(); param1->type=MVNODE; param1->mvnode = dp1
                ; parameters
                .push_back(param1);
                	MVDParameters* param2  = new MVDParameters(); param2->type=MVDEXPRESSION; param1->exp = dp2
                ; parameters
                .push_back(param2);
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultinomialEx; /* Prevent compiler warnings */
    rulemultinomialEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return parameters;
}
/* $ANTLR end multinomial */

/**
 * $ANTLR start dirichlet
 * /u/s/h/shrirams/bugsparser/Parser/BUGS.g:339:1: dirichlet returns [vector<MVDParameters* > parameters] : DIRICHLETOPENBRACKET dp1= mvNode CLOSEBRACKET ;
 */
vector<MVDParameters* >
BUGSParser::dirichlet()
{
        BUGSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    vector<MVDParameters* > parameters;


    MultivariateNode* dp1;
    typedef	MultivariateNode* RETURN_TYPE_dp1;

    /* Initialize rule variables
     */


 
    {
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:340:2: ( DIRICHLETOPENBRACKET dp1= mvNode CLOSEBRACKET )
        // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:340:4: DIRICHLETOPENBRACKET dp1= mvNode CLOSEBRACKET
        {
             this->matchToken(DIRICHLETOPENBRACKET, &FOLLOW_DIRICHLETOPENBRACKET_in_dirichlet1895);
            if  (this->hasException())
            {
                goto ruledirichletEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            this->followPush(FOLLOW_mvNode_in_dirichlet1899);
            dp1=mvNode();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledirichletEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


             this->matchToken(CLOSEBRACKET, &FOLLOW_CLOSEBRACKET_in_dirichlet1901);
            if  (this->hasException())
            {
                goto ruledirichletEx;
            }
            if (this->hasFailed())
            {
                return parameters;
            }


            if ( this->get_backtracking()==0 )
            {
                MVDParameters* param1 = new MVDParameters(); param1->type=MVNODE; param1->mvnode = dp1
                ; parameters
                .push_back(param1);
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledirichletEx; /* Prevent compiler warnings */
    ruledirichletEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return parameters;
}
/* $ANTLR end dirichlet */

// $ANTLR start synpred1_BUGS
void BUGSParser::msynpred1_BUGS_fragment(  )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:3: ( uvNode TILDE )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:89:4: uvNode TILDE
    {
        this->followPush(FOLLOW_uvNode_in_synpred1_BUGS361);
        uvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(TILDE, &FOLLOW_TILDE_in_synpred1_BUGS363);
        if  (this->hasException())
        {
            goto rulesynpred1_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_BUGSEx; /* Prevent compiler warnings */
rulesynpred1_BUGSEx: ;

}
// $ANTLR end synpred1_BUGS

// $ANTLR start synpred2_BUGS
void BUGSParser::msynpred2_BUGS_fragment(  )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:90:4: ( mvNode TILDE )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:90:5: mvNode TILDE
    {
        this->followPush(FOLLOW_mvNode_in_synpred2_BUGS378);
        mvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(TILDE, &FOLLOW_TILDE_in_synpred2_BUGS380);
        if  (this->hasException())
        {
            goto rulesynpred2_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_BUGSEx; /* Prevent compiler warnings */
rulesynpred2_BUGSEx: ;

}
// $ANTLR end synpred2_BUGS

// $ANTLR start synpred3_BUGS
void BUGSParser::msynpred3_BUGS_fragment(  )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:91:4: ( uvNode LEFTPOINTER )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:91:5: uvNode LEFTPOINTER
    {
        this->followPush(FOLLOW_uvNode_in_synpred3_BUGS395);
        uvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred3_BUGS397);
        if  (this->hasException())
        {
            goto rulesynpred3_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred3_BUGSEx; /* Prevent compiler warnings */
rulesynpred3_BUGSEx: ;

}
// $ANTLR end synpred3_BUGS

// $ANTLR start synpred4_BUGS
void BUGSParser::msynpred4_BUGS_fragment(  )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:92:4: ( mvNode LEFTPOINTER )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:92:5: mvNode LEFTPOINTER
    {
        this->followPush(FOLLOW_mvNode_in_synpred4_BUGS412);
        mvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred4_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred4_BUGS414);
        if  (this->hasException())
        {
            goto rulesynpred4_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred4_BUGSEx; /* Prevent compiler warnings */
rulesynpred4_BUGSEx: ;

}
// $ANTLR end synpred4_BUGS

// $ANTLR start synpred5_BUGS
void BUGSParser::msynpred5_BUGS_fragment(  )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:4: ( linkFunction LEFTPOINTER )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:93:5: linkFunction LEFTPOINTER
    {
        this->followPush(FOLLOW_linkFunction_in_synpred5_BUGS429);
        linkFunction();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred5_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFTPOINTER, &FOLLOW_LEFTPOINTER_in_synpred5_BUGS431);
        if  (this->hasException())
        {
            goto rulesynpred5_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred5_BUGSEx; /* Prevent compiler warnings */
rulesynpred5_BUGSEx: ;

}
// $ANTLR end synpred5_BUGS

// $ANTLR start synpred6_BUGS
void BUGSParser::msynpred6_BUGS_fragment(  )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:4: ( uvNode )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:109:5: uvNode
    {
        this->followPush(FOLLOW_uvNode_in_synpred6_BUGS478);
        uvNode();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred6_BUGSEx; /* Prevent compiler warnings */
rulesynpred6_BUGSEx: ;

}
// $ANTLR end synpred6_BUGS

// $ANTLR start synpred7_BUGS
void BUGSParser::msynpred7_BUGS_fragment(  )
{
    {
        //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:132:5: ( uvNode | CONSTANTVALUE )

        ANTLR_UINT32 alt28;

        alt28=2;

        switch ( this->LA(1) )
        {
        case NODENAME:
        	{
        		alt28=1;
        	}
            break;
        case CONSTANTVALUE:
        	{
        		alt28=2;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 28 );
            ex->set_state( 0 );


            goto rulesynpred7_BUGSEx;

        }

        switch (alt28)
        {
    	case 1:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:132:6: uvNode
    	    {
    	        this->followPush(FOLLOW_uvNode_in_synpred7_BUGS598);
    	        uvNode();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred7_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:132:13: CONSTANTVALUE
    	    {
    	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_synpred7_BUGS600);
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred7_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred7_BUGSEx; /* Prevent compiler warnings */
rulesynpred7_BUGSEx: ;

}
// $ANTLR end synpred7_BUGS

// $ANTLR start synpred8_BUGS
void BUGSParser::msynpred8_BUGS_fragment(  )
{
    {
        //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:143:23: ( uvNode | CONSTANTVALUE )

        ANTLR_UINT32 alt29;

        alt29=2;

        switch ( this->LA(1) )
        {
        case NODENAME:
        	{
        		alt29=1;
        	}
            break;
        case CONSTANTVALUE:
        	{
        		alt29=2;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 29 );
            ex->set_state( 0 );


            goto rulesynpred8_BUGSEx;

        }

        switch (alt29)
        {
    	case 1:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:143:24: uvNode
    	    {
    	        this->followPush(FOLLOW_uvNode_in_synpred8_BUGS653);
    	        uvNode();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred8_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:143:31: CONSTANTVALUE
    	    {
    	         this->matchToken(CONSTANTVALUE, &FOLLOW_CONSTANTVALUE_in_synpred8_BUGS655);
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred8_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred8_BUGSEx; /* Prevent compiler warnings */
rulesynpred8_BUGSEx: ;

}
// $ANTLR end synpred8_BUGS

// $ANTLR start synpred9_BUGS
void BUGSParser::msynpred9_BUGS_fragment(  )
{
    {
        //  /u/s/h/shrirams/bugsparser/Parser/BUGS.g:167:4: ( uvNode | linkFunction )

        ANTLR_UINT32 alt30;

        alt30=2;

        switch ( this->LA(1) )
        {
        case NODENAME:
        	{
        		alt30=1;
        	}
            break;
        case CLOGLOGOPENBRACKET:
        case LOGITOPENBRACKET:
        case LOGOPENBRACKET:
        case PROBITOPENBRACKET:
        	{
        		alt30=2;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< BUGSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 30 );
            ex->set_state( 0 );


            goto rulesynpred9_BUGSEx;

        }

        switch (alt30)
        {
    	case 1:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:167:5: uvNode
    	    {
    	        this->followPush(FOLLOW_uvNode_in_synpred9_BUGS778);
    	        uvNode();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred9_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:167:14: linkFunction
    	    {
    	        this->followPush(FOLLOW_linkFunction_in_synpred9_BUGS782);
    	        linkFunction();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred9_BUGSEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }
// This is where rules clean up and exit
//
goto rulesynpred9_BUGSEx; /* Prevent compiler warnings */
rulesynpred9_BUGSEx: ;

}
// $ANTLR end synpred9_BUGS

// $ANTLR start synpred10_BUGS
void BUGSParser::msynpred10_BUGS_fragment(  )
{
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:232:4: ( OPENBRACKET expression COLON )
    // /u/s/h/shrirams/bugsparser/Parser/BUGS.g:232:5: OPENBRACKET expression COLON
    {
         this->matchToken(OPENBRACKET, &FOLLOW_OPENBRACKET_in_synpred10_BUGS1229);
        if  (this->hasException())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_expression_in_synpred10_BUGS1231);
        expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(COLON, &FOLLOW_COLON_in_synpred10_BUGS1233);
        if  (this->hasException())
        {
            goto rulesynpred10_BUGSEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred10_BUGSEx; /* Prevent compiler warnings */
rulesynpred10_BUGSEx: ;

}
// $ANTLR end synpred10_BUGS
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred5_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred1_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred9_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred7_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred7_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred2_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred8_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred8_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred3_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred10_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred6_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool BUGSParser::msynpred( antlr3::ClassForwarder< synpred4_BUGS >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_BUGS_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
